diff -U10 -Naupr fvwm-2.5.21-15/libs/FTips.c fvwm-2.5.21-16/libs/FTips.c
--- fvwm-2.5.21-15/libs/FTips.c	2007-03-03 13:24:15.000000000 +0100
+++ fvwm-2.5.21-16/libs/FTips.c	2007-03-03 13:25:14.000000000 +0100
@@ -496,21 +496,21 @@ void FTipsOn(
 	unsigned long delay;
 
 	box.x = x;
 	box.y = y;
 	box.width = w;
 	box.height = h;
 
 	if (fc == NULL)
 	{
 		fc = default_config;
-	}
+	} 
 	current_config = fc;
 
 	if (label != NULL)
 	{
 		free(label);
 	}
 	CopyString(&label, str);
 	win_for = win_f;
 
 	if (id == boxID)
diff -U10 -Naupr fvwm-2.5.21-15/modules/FvwmButtons/FvwmButtons.c fvwm-2.5.21-16/modules/FvwmButtons/FvwmButtons.c
--- fvwm-2.5.21-15/modules/FvwmButtons/FvwmButtons.c	2007-03-03 13:24:15.000000000 +0100
+++ fvwm-2.5.21-16/modules/FvwmButtons/FvwmButtons.c	2007-03-03 13:25:14.000000000 +0100
@@ -56,20 +56,21 @@
 #include "libs/FRenderInit.h"
 #include "libs/Grab.h"
 #include <libs/gravity.h>
 #include "fvwm/fvwm.h"
 #include "libs/Module.h"
 #include "libs/fvwmsignal.h"
 #include "libs/Colorset.h"
 #include "libs/vpacket.h"
 #include "libs/FRender.h"
 #include "libs/fsm.h"
+#include "libs/FTips.h"
 
 #include "FvwmButtons.h"
 #include "misc.h" /* ConstrainSize() */
 #include "parse.h" /* ParseConfiguration(), parse_window_geometry() */
 #include "draw.h"
 #include "dynamic.h"
 
 
 #define MW_EVENTS ( \
 	ExposureMask | \
@@ -922,20 +923,21 @@ static button_info *handle_new_position(
 		redraw = True;
 	}
 
 	if (b != ActiveButton && CurrentButton == NULL)
 	{
 		if (ActiveButton)
 		{
 			button_info *tmp = ActiveButton;
 			ActiveButton = b;
 			RedrawButton(tmp, DRAW_FORCE, NULL);
+			
 		}
 		if (b->flags.b_ActiveIcon || b->flags.b_ActiveTitle ||
 		    UberButton->c->flags.b_ActiveColorset)
 		{
 			ActiveButton = b;
 			redraw = True;
 		}
 	}
 	if (redraw)
 	{
@@ -1075,20 +1077,23 @@ void Loop(void)
 	char buffer[10], *act;
 	int i, button;
 	int x;
 	int y;
 	button_info *ub, *b;
 	button_info *tmpb;
 	FlocaleNameString tmp;
 
 	tmp.name = NULL;
 	tmp.name_list = NULL;
+
+	FTipsInit(Dpy);
+
 	while ( !isTerminated )
 	{
 		if (My_FNextEvent(Dpy, &Event))
 		{
 			if (FShapesSupported && Event.type == FShapeEventBase + FShapeNotify)
 			{
 				FShapeEvent *sev = (FShapeEvent *) &Event;
 
 				if (sev->kind != FShapeBounding)
 				{
@@ -1200,20 +1205,24 @@ void Loop(void)
       {
 	XEvent event;
 	unsigned int depth, tw, th, border_width;
 	Window root;
 
 	while (FCheckTypedWindowEvent(Dpy, MyWindow, ConfigureNotify, &event))
 	{
 	  if (!event.xconfigure.send_event &&
 	      Event.xconfigure.window != MyWindow)
 	    continue;
+
+	  if(FTipsHandleEvents(Dpy, &event))
+		  continue;
+
 	  Event.xconfigure.x = event.xconfigure.x;
 	  Event.xconfigure.y = event.xconfigure.y;
 	  Event.xconfigure.send_event = True;
 	}
 	if (!XGetGeometry(Dpy, MyWindow, &root, &x, &y, &tw, &th,
 			  &border_width, &depth))
 	{
 	  break;
 	}
 	if (tw != Width || th != Height)
@@ -1242,41 +1251,66 @@ void Loop(void)
 		 Event.xconfigure.send_event)
 	{
 	  update_root_transparency(&Event);
 	}
       }
       break;
 
 	case EnterNotify:
 		b = handle_new_position(
 			b, Event.xcrossing.x, Event.xcrossing.y);
+
+		if(Event.xcrossing.mode == NotifyNormal)
+		{
+			b = handle_new_position(
+			b, Event.xcrossing.x, Event.xcrossing.y);
+			FTipsOn(Dpy,MyWindow,UberButton->c->tips_config, 
+			    (void *)UberButton, b->tipslabel, 
+			    b->x, b->y, Width,Height);
+			FTipsUpdateLabel(Dpy, b->tipslabel);
+		}
 		break;
 
 	case MotionNotify:
+
 		b = handle_new_position(b, Event.xmotion.x, Event.xmotion.y);
+			
+		x = Event.xbutton.x;
+		y = Event.xbutton.y;	
+
+		if(b->tipslabel != NULL)
+		{
+			FTipsOn(Dpy,MyWindow,UberButton->c->tips_config, (void *)UberButton, b->tipslabel, x, y, w, h);
+			FTipsUpdateLabel(Dpy, b->tipslabel);
+		} else {
+			 FTipsCancel(Dpy);
+		}
+		
 		break;
 
 	case LeaveNotify:
 	{
 		if (reallyLeaveWindow(Event.xcrossing.x, Event.xcrossing.y,
 			Event.xcrossing.window, NULL))
 		{
 			if (ActiveButton)
 			{
 				b = ActiveButton;
 				ActiveButton = NULL;
 				RedrawButton(b, DRAW_FORCE, NULL);
+
 			}
 			if (CurrentButton)
 			{
 				RedrawButton(b, DRAW_FORCE, NULL);
 			}
+			FTipsCancel(Dpy);
 		}
 		break;
 	}
       case KeyPress:
 	XLookupString(&Event.xkey, buffer, 10, &keysym, 0);
 	if (
 		keysym != XK_Return && keysym != XK_KP_Enter &&
 		keysym != XK_Linefeed)
 	  break;                        /* fall through to ButtonPress */
 
@@ -1284,22 +1318,22 @@ void Loop(void)
 	if (Event.xbutton.window == MyWindow)
 	{
 	  x = Event.xbutton.x;
 	  y = Event.xbutton.y;
 	}
 	else
 	{
 	  Window dummy;
 
 	  XTranslateCoordinates(
-	    Dpy, Event.xbutton.window, MyWindow, Event.xbutton.x,
-	    Event.xbutton.y, &x, &y, &dummy);
+			  Dpy, Event.xbutton.window, MyWindow, Event.xbutton.x,
+			  Event.xbutton.y, &x, &y, &dummy);
 	}
 	if (CurrentButton)
 	{
 	  b = CurrentButton;
 	  CurrentButton = NULL;
 	  ActiveButton = select_button(UberButton, x, y);
 	  RedrawButton(b, DRAW_FORCE, NULL);
 	  if (ActiveButton != b)
 	  {
 		  RedrawButton(ActiveButton, DRAW_FORCE, NULL);
@@ -1327,21 +1361,24 @@ void Loop(void)
 
 	/* Undraw ActiveButton (if there is one). */
 	if (ActiveButton)
 	{
 	  /* $b & $ActiveButton are always the same button. */
 	  button_info *tmp = ActiveButton;
 	  ActiveButton = NULL;
 	  RedrawButton(tmp, DRAW_FORCE, NULL);
 	}
 	else
+	{
 	  RedrawButton(b, DRAW_FORCE, NULL);
+	}
+	  
 	if (!act)
 	{
 	  break;
 	}
 	if (act && !b->flags.b_ActionOnPress &&
 	    strncasecmp(act, "popup", 5) != 0)
 	{
 	  free(act);
 	  act = NULL;
 	  break;
diff -U10 -Naupr fvwm-2.5.21-15/modules/FvwmButtons/FvwmButtons.h fvwm-2.5.21-16/modules/FvwmButtons/FvwmButtons.h
--- fvwm-2.5.21-15/modules/FvwmButtons/FvwmButtons.h	2007-03-03 13:24:15.000000000 +0100
+++ fvwm-2.5.21-16/modules/FvwmButtons/FvwmButtons.h	2007-03-03 13:25:14.000000000 +0100
@@ -31,20 +31,22 @@
 
 /* ---------------------------- compatibility ------------------------------ */
 
 /*#define OLD_EXPOSE*/     /* Try this if resizing/exposes screw up */
 
 /* -------------------------------- more  ---------------------------------- */
 
 #include "libs/fvwmlib.h"
 #include "libs/Picture.h"
 #include "libs/Flocale.h"
+#include "libs/FTips.h"
+#define FONT_STRING "-*-fixed-medium-r-normal--13-*"
 
 /* ------------------------------- structs --------------------------------- */
 
 /* flags for b->flags */
 typedef struct
 {
 	unsigned b_Container  : 1;     /* Contains several buttons */
 	unsigned b_Font       : 1;     /* Has personal font data */
 	unsigned b_Fore       : 1;     /* Has personal text color */
 	unsigned b_Back       : 1;     /* Has personal background color (or "none") */
@@ -74,20 +76,21 @@ typedef struct
 	                               /* Actions work only on the background
 	                                  of a button with a swallowed app. */
 	unsigned b_ActionOnPress  : 1; /* By default this only done on Popup */
 	unsigned b_Id             : 1; /* Has user-defined id for referencing */
 	unsigned b_ActiveIcon     : 1; /* Use alternate Icon on hover */
 	unsigned b_ActiveColorset : 1; /* Use alternate colorset on hover */
 	unsigned b_ActiveTitle    : 1; /* Use alternate Title text on hover */
 	unsigned b_PressIcon      : 1; /* Use alternate Icon on press */
 	unsigned b_PressColorset  : 1; /* Use alternate Colorset on press */
 	unsigned b_PressTitle     : 1; /* Use alternate Title text on press */
+	unsigned b_UseTips	  : 1; /* Whether to use tips or not. */	
 } flags_type;
 
 /* Flags for b->swallow */
 #define b_Count       0x0003 /* Init counter for swallowing */
 #define b_NoHints     0x0004 /* Ignore window hints from swallowed window */
 #define b_NoClose     0x0008 /* Don't close window when exiting, unswallow it */
 #define b_Kill        0x0010 /* Don't close window when exiting, kill it */
 #define b_Respawn     0x0020 /* Respawn if swallowed window dies */
 #define b_UseOld      0x0040 /* Try to capture old window, don't spawn it */
 #define b_UseTitle    0x0080 /* Allow window to write to b->title */
@@ -123,20 +126,23 @@ struct container_info_struct
 	byte xpad, ypad;           /* b_Padding */
 	signed char framew;        /* b_Frame */
 	FlocaleFont *Ffont;        /* b_Font */
 	char *font_string;         /* b_Font */
 	char *back;                /* b_Back && !b_IconBack */
 	char *back_file;           /* b_Back && b_IconBack */
 	char *fore;                /* b_Fore */
 	int colorset;              /* b_Colorset */
 	int activeColorset;        /* b_ActiveColorset */
 	int pressColorset;         /* b_PressColorset */
+	char *tipsfont;		   /* b_TipsFont*/
+	ftips_config *tips_config; /* Struct that holds tips info.*/
+
 	Pixel fc;                  /* b_Fore */
 	Pixel bc, hc, sc;          /* b_Back && !b_IconBack */
 	FvwmPicture *backicon;     /* b_Back && b_IconBack */
 	ushort minx, miny;         /* b_Size */
 };
 
 typedef struct
 {
 	unsigned smooth : 1;
 	unsigned ignore_lrborder : 1;
@@ -179,20 +185,21 @@ struct button_info_struct
 	char *hangon;            /* b_Hangon || b_Swallow */
 	Pixel fc;                /* b_Fore */
 	Pixel bc, hc, sc;        /* b_Back && !b_IconBack */
 	ushort minx, miny;       /* b_Size */
 	FvwmPicture *icon;       /* b_Icon */
 	FvwmPicture *backicon;   /* b_Back && b_IconBack */
 	FvwmPicture *activeicon; /* b_ActiveIcon */
 	FvwmPicture *pressicon;  /* b_PressIcon */
 	int activeColorset;      /* b_ActiveColorset */
 	int pressColorset;       /* b_PressColorset */
+	char *tipslabel;	 /* b_TipsLabel */
 	Window IconWin;          /* b_Swallow */
 	Window PanelWin;         /* b_Panel */
 	Window BackIconWin;      /* b_Back && b_IconBack */
 
 	unsigned int swallow;      /* b_Swallow */
 	unsigned int swallow_mask; /* b_Swallow */
 	int icon_w, icon_h;        /* b_Swallow */
 	Window IconWinParent;      /* b_Swallow */
 	XSizeHints *hints;         /* b_Swallow && !b_NoHints */
 	char *spawn;               /* b_Swallow */
diff -U10 -Naupr fvwm-2.5.21-15/modules/FvwmButtons/parse.c fvwm-2.5.21-16/modules/FvwmButtons/parse.c
--- fvwm-2.5.21-15/modules/FvwmButtons/parse.c	2007-03-03 13:24:15.000000000 +0100
+++ fvwm-2.5.21-16/modules/FvwmButtons/parse.c	2007-03-03 13:25:14.000000000 +0100
@@ -880,20 +880,21 @@ static void ParseButton(button_info **ub
 			"center",
 			"colorset",
 			"action",
 			"id",
 			"activeicon",
 			"activetitle",
 			"pressicon",
 			"presstitle",
 			"activecolorset",
 			"presscolorset",
+			"tipslabel",
 			NULL
 		};
 		s = trimleft(s);
 		while (*s && *s != ')')
 		{
 			Bool is_swallow = False;
 
 			if (*s == ',')
 			{
 				s++;
@@ -1618,21 +1619,47 @@ static void ParseButton(button_info **ub
 					b->pressColorset = i;
 					b->flags.b_PressColorset = 1;
 					s = t;
 					AllocColorset(i);
 				}
 				else
 				{
 					b->flags.b_PressColorset = 0;
 				}
 				break;
+			/* --------- TipsLabel ---------*/
+			case 27:
+				s = trimleft(s);
+				t = seekright(&s);
+				if(ub->c->flags.b_UseTips)
+				{
+					if (*s == '(')
+					{
+						fprintf(stderr,
+						"%s: justification not allowed "
+						"for TipsLabel.\n", MyName);
+					}
+					
+					
+
+					if (t && *t && (t[0] != '-' || t[1] != 0))
+					{
+						if (b->tipslabel != NULL)
+						{
+							free(b->tipslabel);
+						} else {
+							b->tipslabel = t;
+						}
+					}
+				}
 
+				break;
 			/* --------------- --------------- */
 			default:
 				t = seekright(&s);
 				fprintf(stderr,
 					"%s: Illegal button option \"%s\"\n",
 					MyName, (t) ? t : "");
 				if (t)
 				{
 					free(t);
 				}
@@ -1771,20 +1798,28 @@ static void ParseConfigLine(button_info 
 		"rows",
 		"back",
 		"fore",
 		"frame",
 		"file",
 		"pixmap",
 		"boxsize",
 		"colorset",
 		"activecolorset",
 		"presscolorset",
+		"usetips",
+		"tipsfont",
+		"tipsdelay",
+		"tipscolorset",
+		"tipsborderwidth",
+		"tipsplacement",
+		"tipsjustification",
+		"tipsoffset",
 		NULL
 	};
 	int i, j, k;
 
 	switch (GetTokenIndex(s, opts, -1, &s))
 	{
 	case 0:/* Geometry */
 	{
 		char geom[64];
 
@@ -1918,21 +1953,111 @@ static void ParseConfigLine(button_info 
 		{
 			ub->c->pressColorset = j;
 			ub->c->flags.b_PressColorset = 1;
 			AllocColorset(j);
 		}
 		else
 		{
 			ub->c->flags.b_PressColorset = 0;
 		}
 		break;
+	case 15: /* UseTips */
+		/* We're using tips.*/
+		ub->c->flags.b_UseTips = 1;
+
+		/* Set the defaults up. */
+		ub->c->tips_config = FTipsNewConfig();
+
+		/* Include fonts. */
+		CopyStringWithQuotes(&ub->c->tipsfont,FONT_STRING);
+		ub->c->tips_config->Ffont = FlocaleLoadFont(Dpy, 
+				ub->c->tipsfont, MyName);
+		break;
+	case 16: /* TipsFont */
+		if(ub->c->flags.b_UseTips)
+		{
+			CopyStringWithQuotes(&ub->c->tipsfont,s);
 
+		ub->c->tips_config->Ffont = FlocaleLoadFont(Dpy, ub->c->tipsfont, 
+				MyName);
+		}
+				
+		break;
+	case 17: /*TipsDelay */
+		if(ub->c->flags.b_UseTips)
+		{
+			i = sscanf(s, "%d %d", &j, &k);
+			if( i > 0)
+			{
+				/* Then only one value was given.  Set the
+				 * mapped_delay option to this given value
+				 * also since it's optional. 
+				 */
+				ub->c->tips_config->delay = ub->c->tips_config->mapped_delay = j;
+			}
+			if( i > 1)
+			{
+				/* Two values passed in.  We only need to
+				 * change the value for mapped_delay here.
+				 */
+
+				ub->c->tips_config->mapped_delay = k;
+
+			}
+		}
+			break;
+	case 18: /* TipsColorset */
+		if (ub->c->flags.b_UseTips)
+		{
+			i = sscanf(s, "%d", &j);
+			if (i > 0)
+			{
+				ub->c->tips_config->colorset = j;
+				AllocColorset(j);
+			}
+		}
+		break;
+	case 19: /* TipsBorderWidth */
+		if (ub->c->flags.b_UseTips)
+		{
+			i = sscanf(s, "%d", &j);
+
+			if(i > 0)
+			{
+				ub->c->tips_config->border_width = j;
+			}
+		}
+		break;
+	case 20: /* TipsPlacement */
+		if(ub->c->flags.b_UseTips)
+		{
+			s = trimleft(s);
+
+			/* Options ... */
+			if(!strcasecmp(s, "up"))
+			{
+				i = FTIPS_PLACEMENT_UP;
+			} else if(!strcasecmp(s, "down")) {
+				i = FTIPS_PLACEMENT_DOWN;
+			} else if(!strcasecmp(s, "left")) {
+				i = FTIPS_PLACEMENT_LEFT;
+			} else if(!strcasecmp(s, "right")) {
+				i = FTIPS_PLACEMENT_RIGHT;
+			} else if(!strcasecmp(s, "updown")) {
+				i = FTIPS_PLACEMENT_AUTO_UPDOWN;
+			} else if(!strcasecmp(s, "leftright")) {
+				i = FTIPS_PLACEMENT_AUTO_LEFTRIGHT;
+			}
+
+			ub->c->tips_config->placement = i;
+		}
+			break;
 	default:
 		s = trimleft(s);
 		ParseButton(ubb, s);
 		break;
 	}
 }
 
 /**
 *** ParseConfigFile()
 *** Parses optional separate configuration file for FvwmButtons
