diff -U10 -Naupr fvwm-2.5.21-04/fvwm/borders.c fvwm-2.5.21-05/fvwm/borders.c
--- fvwm-2.5.21-04/fvwm/borders.c	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/borders.c	2007-03-03 13:18:49.000000000 +0100
@@ -4590,20 +4590,21 @@ int border_context_to_parts(
 	}
 
 	return PART_NONE;
 }
 
 void border_get_part_geometry(
 	FvwmWindow *fw, window_parts part, rectangle *sidebar_g,
 	rectangle *ret_g, Window *ret_w)
 {
 	int bw;
+	Bool title;
 
 	bw = fw->boundary_width;
 	/* ret_g->x and ret->y is just an offset relatively to the w,
 	 * maybe we can take the relief in account? */
 	switch (part)
 	{
 	case PART_BORDER_N:
 		ret_g->x = sidebar_g->x;
 		ret_g->y = 0;
 		*ret_w = FW_W_SIDE(fw, 0);
@@ -4660,21 +4661,46 @@ void border_get_part_geometry(
 		ret_g->height = sidebar_g->height;
 		break;
 	case PART_BORDER_NW:
 	case PART_BORDER_NE:
 	case PART_BORDER_SW:
 	case PART_BORDER_SE:
 		ret_g->width = sidebar_g->x;
 		ret_g->height = sidebar_g->y;
 		break;
 	default:
-		return;
+		break;
+	}
+
+	if (HAS_BORDER_UNDER_TITLE(fw))
+	{
+		title = False;
+		switch (GET_TITLE_DIR(fw))
+		{
+		case DIR_N: title = part & PART_TOP; break;
+		case DIR_E: title = part & PART_RIGHT; break;
+		case DIR_S: title = part & PART_BOTTOM; break;
+		case DIR_W: title = part & PART_LEFT; break;
+		}
+		if (title)
+		{
+			ret_g->width = max(ret_g->width, 2 * bw + fw->title_thickness);
+			ret_g->height = max(ret_g->height, 2 * bw + fw->title_thickness);
+			if (part & PART_RIGHT)
+			{
+				ret_g->x = 2 * sidebar_g->x + sidebar_g->width - ret_g->width;
+			}
+			if (part & PART_BOTTOM)
+			{
+				ret_g->y = 2 * sidebar_g->y + sidebar_g->height - ret_g->height;
+			}
+		}
 	}
 
 	return;
 }
 
 int get_button_number(int context)
 {
 	int i;
 
 	for (i = 0; (C_L1 << i) & (C_LALL | C_RALL); i++)
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/borders.c~ fvwm-2.5.21-05/fvwm/borders.c~
--- fvwm-2.5.21-04/fvwm/borders.c~	1970-01-01 01:00:00.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/borders.c~	2007-03-03 13:18:42.000000000 +0100
@@ -0,0 +1,5118 @@
+/* -*-c-*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This module is all original code
+ * by Rob Nation
+ * Copyright 1993, Robert Nation
+ *     You may use this code for any purpose, as long as the original
+ *     copyright remains in the source code and all documentation
+ */
+
+/* IMPORTANT NOTE:
+ *
+ * The functions in this module *must not* assume that the geometries in the
+ * FvwmWindow structure reflect the desired geometry of the window or its
+ * parts.  While the window is resized or shaded, they may hold the old
+ * geometry instead of the new one (but you can not rely on this).  Therefore,
+ * these geometries must not be accessed directly or indirectly (by the
+ * functions from geometry,c).  Use the geometries that are passed in via
+ * structure pointers, e.d. "td".
+ */
+
+/* ---------------------------- included header files ---------------------- */
+
+#include "config.h"
+
+#include <stdio.h>
+
+#include "libs/fvwmlib.h"
+#include "libs/Picture.h"
+#include "libs/PictureGraphics.h"
+#include "libs/FRenderInit.h"
+#include "libs/charmap.h"
+#include "libs/wcontext.h"
+#include "fvwm.h"
+#include "execcontext.h"
+#include "externs.h"
+#include "misc.h"
+#include "screen.h"
+#include "geometry.h"
+#include "borders.h"
+#include "builtins.h"
+#include "icons.h"
+#include "frame.h"
+
+/* ---------------------------- local definitions -------------------------- */
+
+/* ---------------------------- local macros ------------------------------- */
+
+#define SWAP_ARGS(f,a1,a2) (f)?(a2):(a1),(f)?(a1):(a2)
+
+/* ---------------------------- imports ------------------------------------ */
+
+extern Window PressedW;
+
+/* ---------------------------- included code files ------------------------ */
+
+/* ---------------------------- local types -------------------------------- */
+
+typedef struct
+{
+	struct
+	{
+		unsigned use_pixmap : 1;
+	} flags;
+	Pixel pixel;
+	struct
+	{
+		Pixmap p;
+		Pixmap shape;
+		Pixmap alpha;
+		int depth;
+		FvwmRenderAttributes fra;
+		rectangle g;
+		int stretch_w;
+		int stretch_h;
+		struct
+		{
+			unsigned is_tiled : 1;
+			unsigned is_stretched : 1;
+		} flags;
+	} pixmap;
+} pixmap_background_type;
+
+typedef struct
+{
+	Pixmap p;
+	FvwmPicture *mp_created_pic;
+	int cs;
+	FvwmPicture *mp_pic;
+	int mp_part;
+	Bool created;
+} bar_pixmap;
+
+typedef struct
+{
+	int count;
+	bar_pixmap *bps;
+} bar_bs_pixmaps;    /* for UseTitleStyle & Colorset */
+
+typedef struct
+{
+	Pixmap frame_pixmap;
+	bar_bs_pixmaps bar_pixmaps[BS_MaxButtonState];
+} dynamic_common_decorations;
+
+typedef struct
+{
+	int relief_width;
+	GC relief_gc;
+	GC shadow_gc;
+	Pixel fore_color;
+	Pixel back_color;
+	int cs;
+	int border_cs;		/* for UseBorderStyle */
+	int bg_border_cs;	/* for UseBorderStyle */
+	Pixmap back_pixmap;
+	XSetWindowAttributes attributes;
+	unsigned long valuemask;
+	Pixmap texture_pixmap;
+	int texture_pixmap_width;
+	int texture_pixmap_height;
+	XSetWindowAttributes notex_attributes;
+	unsigned long notex_valuemask;
+	dynamic_common_decorations dynamic_cd;
+} common_decorations_type;
+
+typedef struct
+{
+	GC relief;
+	GC shadow;
+	GC transparent;
+} draw_border_gcs;
+
+typedef struct
+{
+	int offset_tl;
+	int offset_br;
+	int thickness;
+	int length;
+	unsigned has_x_marks : 1;
+	unsigned has_y_marks : 1;
+} border_marks_descr;
+
+typedef struct
+{
+	int w_dout;
+	int w_hiout;
+	int w_trout;
+	int w_c;
+	int w_trin;
+	int w_shin;
+	int w_din;
+	int sum;
+	int trim;
+	unsigned is_flat : 1;
+} border_relief_size_descr;
+
+typedef struct
+{
+	rectangle sidebar_g;
+	border_relief_size_descr relief;
+	border_marks_descr marks;
+	draw_border_gcs gcs;
+} border_relief_descr;
+
+typedef struct
+{
+	unsigned pressed_bmask : NUMBER_OF_TITLE_BUTTONS;
+	unsigned lit_bmask : NUMBER_OF_TITLE_BUTTONS;
+	unsigned toggled_bmask : NUMBER_OF_TITLE_BUTTONS;
+	unsigned clear_bmask : NUMBER_OF_TITLE_BUTTONS;
+	unsigned draw_bmask : NUMBER_OF_TITLE_BUTTONS;
+	unsigned max_bmask : NUMBER_OF_TITLE_BUTTONS;
+	ButtonState bstate[NUMBER_OF_TITLE_BUTTONS];
+	unsigned is_title_pressed : 1;
+	unsigned is_title_lit : 1;
+	unsigned do_clear_title : 1;
+	ButtonState tstate;
+} border_titlebar_state;
+
+typedef struct
+{
+	GC rgc;
+	GC sgc;
+	FlocaleWinString fstr;
+	DecorFaceStyle *tstyle;
+	DecorFace *df;
+	unsigned is_toggled : 1;
+} title_draw_descr;
+
+typedef struct
+{
+	common_decorations_type *cd;
+	rectangle frame_g;
+	rectangle bar_g;		/* titlebar geo vs the frame */
+	rectangle left_buttons_g;	/* vs the frame */
+	rectangle right_buttons_g;	/* vs the frame */
+	frame_title_layout_t layout;
+	frame_title_layout_t old_layout;
+	border_titlebar_state tbstate;
+	int length;			/* text */
+	int offset;			/* text offset */
+	/* MultiPixmap Geometries */
+	rectangle under_text_g;		/* vs the titlebar */
+	rectangle left_main_g;		/* vs the titlebar */
+	rectangle right_main_g;		/* vs the titlebar */
+	rectangle full_left_main_g;	/* vs the frame */
+	rectangle full_right_main_g;	/* vs the frame */
+	int left_end_length;
+	int left_of_text_length;
+	int right_end_length;
+	int right_of_text_length;
+	rotation_t draw_rotation;
+	rotation_t restore_rotation;
+	unsigned td_is_rotated : 1;
+	unsigned has_been_saved : 1;
+	unsigned has_vt : 1;		/* vertical title ? */
+	unsigned has_an_upsidedown_rotation : 1;  /* 270 || 180 */
+} titlebar_descr;
+
+/* ---------------------------- forward declarations ----------------------- */
+/*  forward declarations are not so good */
+
+/* for grouping titlebar_descr computation */
+static void border_rotate_titlebar_descr(FvwmWindow *fw, titlebar_descr *td);
+
+/* for grouping the MultiPixmap stuff */
+static Bool border_mp_get_use_title_style_parts_and_geometry(
+	titlebar_descr *td, FvwmPicture **pm, FvwmAcs *acs,
+	unsigned short sf, int is_left, rectangle *g, int *part);
+
+/* ---------------------------- local variables ---------------------------- */
+
+static const char ulgc[] = { 1, 0, 0, 0x7f, 2, 1, 1 };
+static const char brgc[] = { 1, 1, 2, 0x7f, 0, 0, 3 };
+
+/* ---------------------------- exported variables (globals) --------------- */
+
+XGCValues Globalgcv;
+unsigned long Globalgcm;
+
+/* ---------------------------- local functions ---------------------------- */
+
+static Bool is_button_toggled(
+	FvwmWindow *fw, int button)
+{
+	mwm_flags mf;
+
+	if (!HAS_MWM_BUTTONS(fw))
+	{
+		return False;
+	}
+	mf = TB_MWM_DECOR_FLAGS(GetDecor(fw, buttons[button]));
+	if ((mf & MWM_DECOR_MAXIMIZE) && IS_MAXIMIZED(fw))
+	{
+		return True;
+	}
+	if ((mf & MWM_DECOR_SHADE) && IS_SHADED(fw))
+	{
+		return True;
+	}
+	if ((mf & MWM_DECOR_STICK) &&
+	    (IS_STICKY_ACROSS_PAGES(fw) || IS_STICKY_ACROSS_DESKS(fw)))
+	{
+		return True;
+	}
+	if (TB_FLAGS(fw->decor->buttons[button]).has_layer &&
+	    fw->layer == TB_LAYER(fw->decor->buttons[button]))
+	{
+		return True;
+	}
+
+	return False;
+}
+
+
+/* rules to get button state */
+static ButtonState border_flags_to_button_state(
+	int is_pressed, int is_lit, int is_toggled)
+{
+	if (!is_lit && Scr.gs.use_inactive_buttons)
+	{
+		if (is_pressed && Scr.gs.use_inactive_down_buttons)
+		{
+			return (is_toggled) ?
+				BS_ToggledInactiveDown : BS_InactiveDown;
+		}
+		else
+		{
+			return (is_toggled) ?
+				BS_ToggledInactiveUp : BS_InactiveUp;
+		}
+	}
+	else
+	{
+		if (is_pressed && Scr.gs.use_active_down_buttons)
+		{
+			return (is_toggled) ?
+				BS_ToggledActiveDown : BS_ActiveDown;
+		}
+		else
+		{
+			return (is_toggled) ?
+				BS_ToggledActiveUp : BS_ActiveUp;
+		}
+	}
+}
+
+static void get_common_decorations(
+	common_decorations_type *cd, FvwmWindow *t,
+	window_parts draw_parts, Bool has_focus, Bool is_border,
+	Bool do_change_gcs)
+{
+	DecorFace *df;
+	color_quad *draw_colors;
+
+	df = border_get_border_style(t, has_focus);
+	cd->bg_border_cs = -1;
+	cd->cs = -1;
+	if (has_focus)
+	{
+		/* are we using textured borders? */
+		if (DFS_FACE_TYPE(df->style) == TiledPixmapButton &&
+		    GetDecor(t, BorderStyle.active.u.p->depth) == Pdepth)
+		{
+			cd->texture_pixmap = GetDecor(
+				t, BorderStyle.active.u.p->picture);
+			cd->texture_pixmap_width = GetDecor(
+				t, BorderStyle.active.u.p->width);
+			cd->texture_pixmap_height = GetDecor(
+				t, BorderStyle.active.u.p->height);
+		}
+		else if (DFS_FACE_TYPE(df->style) == ColorsetButton)
+		{
+			cd->bg_border_cs = GetDecor(
+				t, BorderStyle.active.u.acs.cs);
+		}
+		cd->back_pixmap = Scr.gray_pixmap;
+		if (is_border)
+		{
+			draw_colors = &(t->border_hicolors);
+			cd->cs = t->border_cs_hi;
+		}
+		else
+		{
+			draw_colors = &(t->hicolors);
+			cd->cs = t->cs_hi;
+		}
+	}
+	else
+	{
+		if (DFS_FACE_TYPE(df->style) == TiledPixmapButton &&
+		    GetDecor(t, BorderStyle.inactive.u.p->depth) == Pdepth)
+		{
+			cd->texture_pixmap = GetDecor(
+				t, BorderStyle.inactive.u.p->picture);
+			cd->texture_pixmap_width = GetDecor(
+				t, BorderStyle.inactive.u.p->width);
+			cd->texture_pixmap_height = GetDecor(
+				t, BorderStyle.inactive.u.p->height);
+		}
+		else if (DFS_FACE_TYPE(df->style) == ColorsetButton)
+		{
+			cd->bg_border_cs = GetDecor(
+				t, BorderStyle.inactive.u.acs.cs);
+		}
+		if (IS_STICKY_ACROSS_PAGES(t) || IS_STICKY_ACROSS_DESKS(t))
+		{
+			cd->back_pixmap = Scr.sticky_gray_pixmap;
+		}
+		else
+		{
+			cd->back_pixmap = Scr.light_gray_pixmap;
+		}
+		if (is_border)
+		{
+			draw_colors = &(t->border_colors);
+			cd->cs = t->border_cs;
+		}
+		else
+		{
+			draw_colors = &(t->colors);
+			cd->cs = t->cs;
+		}
+	}
+	cd->fore_color = draw_colors->fore;
+	cd->back_color = draw_colors->back;
+	if (do_change_gcs)
+	{
+		Globalgcv.foreground = draw_colors->hilight;
+		Globalgcm = GCForeground;
+		XChangeGC(dpy, Scr.ScratchGC1, Globalgcm, &Globalgcv);
+		Globalgcv.foreground = draw_colors->shadow;
+		XChangeGC(dpy, Scr.ScratchGC2, Globalgcm, &Globalgcv);
+		cd->relief_gc = Scr.ScratchGC1;
+		cd->shadow_gc = Scr.ScratchGC2;
+	}
+
+	/* MWMBorder style means thin 3d effects */
+	cd->relief_width = (HAS_MWM_BORDER(t) ? 1 : 2);
+
+	if (cd->texture_pixmap)
+	{
+		cd->attributes.background_pixmap = cd->texture_pixmap;
+		cd->valuemask = CWBackPixmap;
+	}
+	else
+	{
+		if (Pdepth < 2)
+		{
+			cd->attributes.background_pixmap = cd->back_pixmap;
+			cd->valuemask = CWBackPixmap;
+		}
+		else
+		{
+			cd->attributes.background_pixel = cd->back_color;
+			cd->valuemask = CWBackPixel;
+		}
+	}
+	if (Pdepth < 2)
+	{
+		cd->notex_attributes.background_pixmap = cd->back_pixmap;
+		cd->notex_valuemask = CWBackPixmap;
+	}
+	else
+	{
+		cd->notex_attributes.background_pixel = cd->back_color;
+		cd->notex_valuemask = CWBackPixel;
+	}
+
+	return;
+}
+
+static window_parts border_get_changed_border_parts(
+	FvwmWindow *fw, rectangle *old_sidebar_g, rectangle *new_sidebar_g,
+	int cs)
+{
+	window_parts changed_parts;
+
+	changed_parts = PART_NONE;
+	if (!CSET_IS_TRANSPARENT_PR(cs) && CSET_HAS_PIXMAP(cs) &&
+	    (old_sidebar_g->x != new_sidebar_g->x ||
+	     old_sidebar_g->y != new_sidebar_g->y ||
+	     old_sidebar_g->width != new_sidebar_g->width ||
+	     old_sidebar_g->height != new_sidebar_g->height))
+	{
+		/* optimizable? */
+		changed_parts |= PART_FRAME;
+		return changed_parts;
+	}
+	if (old_sidebar_g->x != new_sidebar_g->x)
+	{
+		changed_parts |= (PART_FRAME & (~PART_BORDER_W));
+	}
+	if (old_sidebar_g->y != new_sidebar_g->y)
+	{
+		changed_parts |= (PART_FRAME & (~PART_BORDER_N));
+	}
+	if (old_sidebar_g->width != new_sidebar_g->width)
+	{
+		changed_parts |=
+			PART_BORDER_N | PART_BORDER_S;
+		if (DFS_FACE_TYPE(GetDecor(fw, BorderStyle.active.style)) ==
+		    TiledPixmapButton)
+		{
+			changed_parts |=
+				PART_BORDER_NE | PART_BORDER_E | PART_BORDER_SE;
+		}
+	}
+	if (old_sidebar_g->height != new_sidebar_g->height)
+	{
+		changed_parts |=
+			PART_BORDER_W | PART_BORDER_E;
+		if (DFS_FACE_TYPE(GetDecor(fw, BorderStyle.active.style)) ==
+		    TiledPixmapButton)
+		{
+			changed_parts |=
+				PART_BORDER_SW | PART_BORDER_S | PART_BORDER_SE;
+		}
+	}
+
+	return changed_parts;
+}
+
+static int border_get_parts_and_pos_to_draw(
+	common_decorations_type *cd, FvwmWindow *fw,
+	window_parts pressed_parts, window_parts force_draw_parts,
+	rectangle *old_g, rectangle *new_g, Bool do_hilight,
+	border_relief_descr *br)
+{
+	window_parts draw_parts;
+	window_parts parts_to_light;
+	rectangle sidebar_g_old;
+	DecorFaceStyle *borderstyle;
+	Bool has_x_marks;
+	Bool has_x_marks_old;
+	Bool has_y_marks;
+	Bool has_y_marks_old;
+	int cs = cd->bg_border_cs;
+
+	draw_parts = 0;
+	borderstyle = (do_hilight) ?
+		&GetDecor(fw, BorderStyle.active.style) :
+		&GetDecor(fw, BorderStyle.inactive.style);
+	frame_get_sidebar_geometry(
+		fw, borderstyle,  new_g, &br->sidebar_g, &has_x_marks,
+		&has_y_marks);
+	if (has_x_marks == True)
+	{
+		draw_parts |= PART_X_HANDLES;
+		br->marks.has_x_marks = 1;
+	}
+	else
+	{
+		br->marks.has_x_marks = 0;
+	}
+	if (has_y_marks == True)
+	{
+		draw_parts |= PART_Y_HANDLES;
+		br->marks.has_y_marks = 1;
+	}
+	else
+	{
+		br->marks.has_y_marks = 0;
+	}
+	draw_parts |= (pressed_parts ^ fw->decor_state.parts_inverted);
+	parts_to_light = (do_hilight == True) ? PART_FRAME : PART_NONE;
+	draw_parts |= (parts_to_light ^ fw->decor_state.parts_lit);
+	draw_parts |= (~(fw->decor_state.parts_drawn) & PART_FRAME);
+	draw_parts |= force_draw_parts;
+	if (old_g == NULL)
+	{
+		old_g = &fw->g.frame;
+	}
+	if ((draw_parts & PART_FRAME) == PART_FRAME)
+	{
+		draw_parts |= PART_FRAME;
+		return draw_parts;
+	}
+	frame_get_sidebar_geometry(
+		fw, borderstyle, old_g, &sidebar_g_old, &has_x_marks_old,
+		&has_y_marks_old);
+	if (has_x_marks_old != has_x_marks)
+	{
+		draw_parts |= (PART_FRAME & (~(PART_BORDER_N | PART_BORDER_S)));
+	}
+	if (has_y_marks_old != has_y_marks)
+	{
+		draw_parts |= (PART_FRAME & (~(PART_BORDER_W | PART_BORDER_E)));
+	}
+	draw_parts |= border_get_changed_border_parts(
+		fw, &sidebar_g_old, &br->sidebar_g, cs);
+	draw_parts &= (PART_FRAME | PART_HANDLES);
+
+	return draw_parts;
+}
+
+static window_parts border_get_tb_parts_to_draw(
+	FvwmWindow *fw, titlebar_descr *td, rectangle *old_g, rectangle *new_g,
+	window_parts force_draw_parts)
+{
+	window_parts draw_parts;
+	ButtonState old_state;
+	int i;
+	DecorFace *df,*tdf;
+
+	td->tbstate.draw_bmask = 0;
+	draw_parts = PART_NONE;
+	/* first time? */
+	draw_parts |= (~(fw->decor_state.parts_drawn) & PART_TITLE);
+	td->tbstate.draw_bmask |= (~(fw->decor_state.buttons_drawn));
+	/* forced? */
+	draw_parts |= force_draw_parts;
+	td->tbstate.draw_bmask |= (force_draw_parts & PART_BUTTONS) ? ~0 : 0;
+	/* check if state changed */
+	old_state = border_flags_to_button_state(
+		(fw->decor_state.parts_inverted & PART_TITLE),
+		(fw->decor_state.parts_lit & PART_TITLE), 0);
+	if (old_state != td->tbstate.tstate)
+	{
+		draw_parts |= PART_TITLE;
+	}
+	/* size changed? */
+	if ((td->old_layout.title_g.width != td->layout.title_g.width ||
+	     td->old_layout.title_g.height != td->layout.title_g.height) &&
+	    td->layout.title_g.x >= 0 && td->layout.title_g.y >= 0)
+	{
+		draw_parts |= PART_TITLE;
+	}
+	/* same for buttons */
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		unsigned int mask = (1 << i);
+
+		if (FW_W_BUTTON(fw, i) == None)
+		{
+			continue;
+		}
+		old_state = border_flags_to_button_state(
+			(fw->decor_state.buttons_inverted & mask),
+			(fw->decor_state.buttons_lit & mask),
+			(fw->decor_state.buttons_toggled & mask));
+		if (old_state != td->tbstate.bstate[i])
+		{
+			draw_parts |= PART_BUTTONS;
+			td->tbstate.draw_bmask |= mask;
+		}
+		if ((td->old_layout.button_g[i].width !=
+		     td->layout.button_g[i].width ||
+		     td->old_layout.button_g[i].height !=
+		     td->layout.button_g[i].height) &&
+		    td->layout.button_g[i].x >= 0 &&
+		    td->layout.button_g[i].y >= 0)
+		{
+			draw_parts |= PART_BUTTONS;
+			td->tbstate.draw_bmask |= mask;
+		}
+	}
+	/* position changed and background is tiled or a cset? */
+	if ((draw_parts & PART_TITLE) == PART_NONE &&
+	    td->layout.title_g.x >= 0 &&
+	    td->layout.title_g.y >= 0)
+	{
+		df = &TB_STATE(GetDecor(fw, titlebar))[td->tbstate.tstate];
+		if (DFS_USE_BORDER_STYLE(df->style) &&
+		    (((td->old_layout.title_g.x != td->layout.title_g.x ||
+		       td->old_layout.title_g.y != td->layout.title_g.y) &&
+		      ((td->cd->valuemask & CWBackPixmap) ||
+		       CSET_PIXMAP_IS_TILED(td->cd->bg_border_cs)))
+		     ||
+		     (old_g->width != new_g->width &&
+		      CSET_PIXMAP_IS_X_STRETCHED(td->cd->bg_border_cs))
+		     ||
+		     (old_g->height != new_g->height
+		      && CSET_PIXMAP_IS_Y_STRETCHED(td->cd->bg_border_cs))
+		     ||
+		     ((old_g->x != new_g->x || old_g->y != new_g->y)
+		      && CSET_IS_TRANSPARENT_ROOT(td->cd->bg_border_cs))))
+		{
+				draw_parts |= PART_TITLE;
+		}
+		if ((draw_parts & PART_TITLE) == PART_NONE &&
+		    (old_g->x != new_g->x || old_g->y != new_g->y))
+		{
+			for (tdf = df; tdf != NULL; tdf = tdf->next)
+			{
+				if (DFS_FACE_TYPE(tdf->style) ==
+				    ColorsetButton &&
+				    CSET_IS_TRANSPARENT_ROOT(tdf->u.acs.cs))
+				{
+					draw_parts |= PART_TITLE;
+					break;
+				}
+			}
+		}
+	}
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		unsigned int mask;
+		DecorFaceStyle *bs;
+
+		mask = (1 << i);
+		bs = &TB_STATE(
+			GetDecor(fw, buttons[i]))[td->tbstate.bstate[i]].style;
+		if ((td->tbstate.draw_bmask & mask) ||
+		    td->layout.button_g[i].x < 0 ||
+		    td->layout.button_g[i].y < 0)
+		{
+			continue;
+		}
+		if (DFS_USE_BORDER_STYLE(*bs) &&
+		    (((td->old_layout.button_g[i].x !=
+		       td->layout.button_g[i].x||
+		       td->old_layout.button_g[i].y !=
+		       td->layout.button_g[i].y)
+		      && ((td->cd->valuemask & CWBackPixmap) ||
+			  CSET_PIXMAP_IS_TILED(td->cd->bg_border_cs)))
+		     ||
+		     (old_g->width != new_g->width &&
+		      CSET_PIXMAP_IS_X_STRETCHED(td->cd->bg_border_cs))
+		     ||
+		     (old_g->height != new_g->height
+		      && CSET_PIXMAP_IS_Y_STRETCHED(td->cd->bg_border_cs))
+		     ||
+		     ((old_g->x != new_g->x || old_g->y != new_g->y)
+		      && CSET_IS_TRANSPARENT_ROOT(td->cd->bg_border_cs))))
+		{
+			td->tbstate.draw_bmask |= mask;
+		}
+		else if (DFS_USE_TITLE_STYLE(*bs))
+		{
+			df = &TB_STATE(GetDecor(
+				fw, titlebar))[td->tbstate.bstate[i]];
+			for(tdf = df; tdf != NULL; tdf = tdf->next)
+			{
+				int cs;
+				if (DFS_FACE_TYPE(tdf->style) == MultiPixmap)
+				{
+					/* can be improved */
+					td->tbstate.draw_bmask |= mask;
+					break;
+				}
+				if (DFS_FACE_TYPE(tdf->style) != ColorsetButton
+				    || !CSET_HAS_PIXMAP(tdf->u.acs.cs))
+				{
+					continue;
+				}
+				cs = tdf->u.acs.cs;
+				if(((td->old_layout.button_g[i].x !=
+				     td->layout.button_g[i].x ||
+				     td->old_layout.button_g[i].y !=
+				     td->layout.button_g[i].y) ||
+				    CSET_PIXMAP_IS_TILED(cs))
+				   ||
+				   (old_g->width != new_g->width &&
+				    CSET_PIXMAP_IS_X_STRETCHED(cs))
+				   ||
+				   (old_g->height != new_g->height &&
+				    CSET_PIXMAP_IS_Y_STRETCHED(cs))
+					||
+				   ((old_g->x != new_g->x ||
+				     old_g->y != new_g->y)
+				    && CSET_IS_TRANSPARENT_ROOT(cs)))
+				{
+					td->tbstate.draw_bmask |= mask;
+					break;
+				}
+			}
+		}
+		if (td->tbstate.draw_bmask & mask)
+		{
+			continue;
+		}
+		if (old_g->x != new_g->x || old_g->y != new_g->y)
+		{
+			df = &TB_STATE(GetDecor(
+				fw, buttons[i]))[td->tbstate.bstate[i]];
+			for(tdf = df; tdf != NULL; tdf = tdf->next)
+			{
+				if (DFS_FACE_TYPE(tdf->style) ==
+				    ColorsetButton &&
+				    CSET_IS_TRANSPARENT_ROOT(tdf->u.acs.cs))
+				{
+					td->tbstate.draw_bmask |= mask;
+					break;
+				}
+			}
+		}
+	}
+	td->tbstate.max_bmask = 0;
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		if (FW_W_BUTTON(fw, i) == None)
+		{
+			continue;
+		}
+		if ((i & 1) == 1 && i / 2 < Scr.nr_right_buttons)
+		{
+			td->tbstate.max_bmask |= (1 << i);
+		}
+		else if ((i & 1) == 0 && i / 2 < Scr.nr_left_buttons)
+		{
+			td->tbstate.max_bmask |= (1 << i);
+		}
+	}
+	td->tbstate.draw_bmask &= td->tbstate.max_bmask;
+	td->tbstate.pressed_bmask &= td->tbstate.max_bmask;
+	td->tbstate.lit_bmask &= td->tbstate.max_bmask;
+	td->tbstate.toggled_bmask &= td->tbstate.max_bmask;
+	td->tbstate.clear_bmask &= td->tbstate.max_bmask;
+	if (td->tbstate.draw_bmask == 0)
+	{
+		draw_parts &= ~PART_BUTTONS;
+	}
+	else
+	{
+		draw_parts |= PART_BUTTONS;
+	}
+	draw_parts &= PART_TITLEBAR;
+
+	return draw_parts;
+}
+
+static void border_get_border_gcs(
+	draw_border_gcs *ret_gcs, common_decorations_type *cd, FvwmWindow *fw,
+	Bool do_hilight)
+{
+	static GC transparent_gc = None;
+	DecorFaceStyle *borderstyle;
+	Bool is_reversed = False;
+
+	if (transparent_gc == None && !HAS_NO_BORDER(fw) && !HAS_MWM_BORDER(fw))
+	{
+		XGCValues xgcv;
+
+		xgcv.function = GXnoop;
+		xgcv.plane_mask = 0;
+		transparent_gc = fvwmlib_XCreateGC(
+			dpy, Scr.NoFocusWin, GCFunction | GCPlaneMask, &xgcv);
+	}
+	ret_gcs->transparent = transparent_gc;
+	/* get the border style bits */
+	borderstyle = (do_hilight) ?
+		&GetDecor(fw, BorderStyle.active.style) :
+		&GetDecor(fw, BorderStyle.inactive.style);
+	if (borderstyle->flags.button_relief == DFS_BUTTON_IS_SUNK)
+	{
+		is_reversed = True;
+	}
+	if (is_reversed)
+	{
+		ret_gcs->shadow = cd->relief_gc;
+		ret_gcs->relief = cd->shadow_gc;
+	}
+	else
+	{
+		ret_gcs->relief = cd->relief_gc;
+		ret_gcs->shadow = cd->shadow_gc;
+	}
+
+	return;
+}
+
+static void trim_border_layout(
+	FvwmWindow *fw, DecorFaceStyle *borderstyle,
+	border_relief_size_descr *ret_size_descr)
+{
+	/* If the border is too thin to accomodate the standard look, we remove
+	 * parts of the border so that at least one pixel of the original
+	 * colour is visible. We make an exception for windows with a border
+	 * width of 2, though. */
+	if ((!IS_SHADED(fw) || HAS_TITLE(fw)) && fw->boundary_width == 2)
+	{
+		ret_size_descr->trim--;
+	}
+	if (ret_size_descr->trim < 0)
+	{
+		ret_size_descr->trim = 0;
+	}
+	for ( ; ret_size_descr->trim > 0; ret_size_descr->trim--)
+	{
+		if (ret_size_descr->w_hiout > 1)
+		{
+			ret_size_descr->w_hiout--;
+		}
+		else if (ret_size_descr->w_shin > 0)
+		{
+			ret_size_descr->w_shin--;
+		}
+		else if (ret_size_descr->w_hiout > 0)
+		{
+			ret_size_descr->w_hiout--;
+		}
+		else if (ret_size_descr->w_trout > 0)
+		{
+			ret_size_descr->w_trout = 0;
+			ret_size_descr->w_trin = 0;
+			ret_size_descr->w_din = 0;
+			ret_size_descr->w_hiout = 1;
+		}
+		ret_size_descr->sum--;
+	}
+	ret_size_descr->w_c = fw->boundary_width - ret_size_descr->sum;
+
+	return;
+}
+
+static void check_remove_inset(
+	DecorFaceStyle *borderstyle, border_relief_size_descr *ret_size_descr)
+{
+	if (!DFS_HAS_NO_INSET(*borderstyle))
+	{
+		return;
+	}
+	ret_size_descr->w_shin = 0;
+	ret_size_descr->sum--;
+	ret_size_descr->trim--;
+	if (ret_size_descr->w_trin)
+	{
+		ret_size_descr->w_trout = 0;
+		ret_size_descr->w_trin = 0;
+		ret_size_descr->w_din = 0;
+		ret_size_descr->w_hiout = 1;
+		ret_size_descr->sum -= 2;
+		ret_size_descr->trim -= 2;
+	}
+
+	return;
+}
+
+static void border_fetch_mwm_layout(
+	FvwmWindow *fw, DecorFaceStyle *borderstyle,
+	border_relief_size_descr *ret_size_descr)
+{
+	/* MWM borders look like this:
+	 *
+	 * HHCCCCS  from outside to inside on the left and top border
+	 * SSCCCCH  from outside to inside on the bottom and right border
+	 * |||||||
+	 * |||||||__ w_shin	(inner shadow area)
+	 * ||||||___ w_c	(transparent area)
+	 * |||||____ w_c	(transparent area)
+	 * ||||_____ w_c	(transparent area)
+	 * |||______ w_c	(transparent area)
+	 * ||_______ w_hiout	(outer hilight area)
+	 * |________ w_hiout	(outer hilight area)
+	 *
+	 *
+	 * C = original colour
+	 * H = hilight
+	 * S = shadow
+	 */
+	ret_size_descr->w_dout = 0;
+	ret_size_descr->w_hiout = 2;
+	ret_size_descr->w_trout = 0;
+	ret_size_descr->w_trin = 0;
+	ret_size_descr->w_shin = 1;
+	ret_size_descr->w_din = 0;
+	ret_size_descr->sum = 3;
+	ret_size_descr->trim = ret_size_descr->sum - fw->boundary_width + 1;
+	check_remove_inset(borderstyle, ret_size_descr);
+	trim_border_layout(fw, borderstyle, ret_size_descr);
+
+	return;
+}
+
+static void border_fetch_fvwm_layout(
+	FvwmWindow *fw, DecorFaceStyle *borderstyle,
+	border_relief_size_descr *ret_size_descr)
+{
+	/* Fvwm borders look like this:
+	 *
+	 * SHHCCSS  from outside to inside on the left and top border
+	 * SSCCHHS  from outside to inside on the bottom and right border
+	 * |||||||
+	 * |||||||__ w_din	(inner dark area)
+	 * ||||||___ w_shin	(inner shadow area)
+	 * |||||____ w_trin	(inner transparent/shadow area)
+	 * ||||_____ w_c	(transparent area)
+	 * |||______ w_trout	(outer transparent/hilight area)
+	 * ||_______ w_hiout	(outer hilight area)
+	 * |________ w_dout	(outer dark area)
+	 *
+	 * C = original colour
+	 * H = hilight
+	 * S = shadow
+	 *
+	 * reduced to 5 pixels it looks like this:
+	 *
+	 * SHHCS
+	 * SSCHS
+	 * |||||
+	 * |||||__ w_din	(inner dark area)
+	 * ||||___ w_trin	(inner transparent/shadow area)
+	 * |||____ w_trout	(outer transparent/hilight area)
+	 * ||_____ w_hiout	(outer hilight area)
+	 * |______ w_dout	(outer dark area)
+	 */
+	ret_size_descr->w_dout = 1;
+	ret_size_descr->w_hiout = 1;
+	ret_size_descr->w_trout = 1;
+	ret_size_descr->w_trin = 1;
+	ret_size_descr->w_shin = 1;
+	ret_size_descr->w_din = 1;
+	/* w_trout + w_trin counts only as one pixel of border because
+	 * they let one pixel of the original colour shine through. */
+	ret_size_descr->sum = 6;
+	ret_size_descr->trim = ret_size_descr->sum - fw->boundary_width;
+	check_remove_inset(borderstyle, ret_size_descr);
+	trim_border_layout(fw, borderstyle, ret_size_descr);
+
+	return;
+}
+
+static void border_get_border_relief_size_descr(
+	border_relief_size_descr *ret_size_descr, FvwmWindow *fw,
+	Bool do_hilight)
+{
+	DecorFaceStyle *borderstyle;
+
+	if (is_window_border_minimal(fw))
+	{
+		/* the border is too small, only a background but no relief */
+		ret_size_descr->is_flat = 1;
+		return;
+	}
+	borderstyle = (do_hilight) ?
+		&GetDecor(fw, BorderStyle.active.style) :
+		&GetDecor(fw, BorderStyle.inactive.style);
+	if (borderstyle->flags.button_relief == DFS_BUTTON_IS_FLAT)
+	{
+		ret_size_descr->is_flat = 1;
+		return;
+	}
+	ret_size_descr->is_flat = 0;
+	/* get the relief layout */
+	if (HAS_MWM_BORDER(fw))
+	{
+		border_fetch_mwm_layout(fw, borderstyle, ret_size_descr);
+	}
+	else
+	{
+		border_fetch_fvwm_layout(fw, borderstyle, ret_size_descr);
+	}
+
+	return;
+}
+
+static void border_get_border_marks_descr(
+	common_decorations_type *cd, border_relief_descr *br, FvwmWindow *fw)
+{
+	int inset;
+
+	/* get mark's length and thickness */
+	inset = (br->relief.w_shin != 0 || br->relief.w_din != 0);
+	br->marks.length = fw->boundary_width - br->relief.w_dout - inset;
+	if (br->marks.length <= 0)
+	{
+		br->marks.has_x_marks = 0;
+		br->marks.has_y_marks = 0;
+		return;
+	}
+	br->marks.thickness = cd->relief_width;
+	if (br->marks.thickness > br->marks.length)
+	{
+		br->marks.thickness = br->marks.length;
+	}
+	/* get offsets from outer side of window */
+	br->marks.offset_tl = br->relief.w_dout;
+	br->marks.offset_br =
+		-br->relief.w_dout - br->marks.length - br->marks.offset_tl;
+
+	return;
+}
+
+static Pixmap border_create_decor_pixmap(
+	common_decorations_type *cd, rectangle *decor_g)
+{
+	Pixmap p;
+
+	p = XCreatePixmap(
+		dpy, Scr.Root, decor_g->width, decor_g->height, Pdepth);
+
+	return p;
+}
+
+static void border_draw_part_relief(
+	border_relief_descr *br, rectangle *frame_g, rectangle *part_g,
+	Pixmap dest_pix, Bool is_inverted)
+{
+	int i;
+	int off_x = 0;
+	int off_y = 0;
+	int width = frame_g->width - 1;
+	int height = frame_g->height - 1;
+	int w[7];
+	GC gc[4];
+
+	w[0] = br->relief.w_dout;
+	w[1] = br->relief.w_hiout;
+	w[2] = br->relief.w_trout;
+	w[3] = br->relief.w_c;
+	w[4] = br->relief.w_trin;
+	w[5] = br->relief.w_shin;
+	w[6] = br->relief.w_din;
+	gc[(is_inverted == True)] = br->gcs.relief;
+	gc[!(is_inverted == True)] = br->gcs.shadow;
+	gc[2] = br->gcs.transparent;
+	gc[3] = br->gcs.shadow;
+
+	off_x = -part_g->x;
+	off_y = -part_g->y;
+	width = frame_g->width - 1;
+	height = frame_g->height - 1;
+	for (i = 0; i < 7; i++)
+	{
+		if (ulgc[i] != 0x7f && w[i] > 0)
+		{
+			do_relieve_rectangle(
+				dpy, dest_pix, off_x, off_y,
+				width, height, gc[(int)ulgc[i]],
+				gc[(int)brgc[i]], w[i], False);
+		}
+		off_x += w[i];
+		off_y += w[i];
+		width -= 2 * w[i];
+		height -= 2 * w[i];
+	}
+
+	return;
+}
+
+static void border_draw_x_mark(
+	border_relief_descr *br, int x, int y, Pixmap dest_pix,
+	Bool do_draw_shadow)
+{
+	int k;
+	int length;
+	GC gc;
+
+	if (br->marks.has_x_marks == 0)
+	{
+		return;
+	}
+	x += br->marks.offset_tl;
+	gc = (do_draw_shadow) ? br->gcs.shadow : br->gcs.relief;
+	/* draw it */
+	for (k = 0, length = br->marks.length - 1; k < br->marks.thickness;
+	     k++, length--)
+	{
+		int x1;
+		int x2;
+		int y1;
+		int y2;
+
+		if (length < 0)
+		{
+			break;
+		}
+		if (do_draw_shadow)
+		{
+			x1 = x + k;
+			y1 = y - 1 - k;
+		}
+		else
+		{
+			x1 = x;
+			y1 = y + k;
+		}
+		x2 = x1 + length;
+		y2 = y1;
+		XDrawLine(dpy, dest_pix, gc, x1, y1, x2, y2);
+	}
+
+	return;
+}
+
+static void border_draw_y_mark(
+	border_relief_descr *br, int x, int y, Pixmap dest_pix,
+	Bool do_draw_shadow)
+{
+	int k;
+	int length;
+	GC gc;
+
+	if (br->marks.has_y_marks == 0)
+	{
+		return;
+	}
+	y += br->marks.offset_tl;
+	gc = (do_draw_shadow) ? br->gcs.shadow : br->gcs.relief;
+	/* draw it */
+	for (k = 0, length = br->marks.length; k < br->marks.thickness;
+	     k++, length--)
+	{
+		int x1;
+		int x2;
+		int y1;
+		int y2;
+
+		if (length <= 0)
+		{
+			break;
+		}
+		if (do_draw_shadow)
+		{
+			x1 = x - 1 - k;
+			y1 = y + k;
+		}
+		else
+		{
+			x1 = x + k;
+			y1 = y;
+		}
+		x2 = x1;
+		y2 = y1 + length - 1;
+		XDrawLine(dpy, dest_pix, gc, x1, y1, x2, y2);
+	}
+
+	return;
+}
+
+static void border_draw_part_marks(
+	border_relief_descr *br, rectangle *part_g, window_parts part,
+	Pixmap dest_pix)
+{
+	int l;
+	int t;
+	int w;
+	int h;
+	int o;
+
+	l = br->sidebar_g.x;
+	t = br->sidebar_g.y;
+	w = part_g->width;
+	h = part_g->height;
+	o = br->marks.offset_br;
+	switch (part)
+	{
+	case PART_BORDER_N:
+		border_draw_y_mark(br, 0, 0, dest_pix, False);
+		border_draw_y_mark(br, w, 0, dest_pix, True);
+		break;
+	case PART_BORDER_S:
+		border_draw_y_mark(br, 0, h + o, dest_pix, False);
+		border_draw_y_mark(br, w, h + o, dest_pix, True);
+		break;
+	case PART_BORDER_E:
+		border_draw_x_mark(br, w + o, 0, dest_pix, False);
+		border_draw_x_mark(br, w + o, h, dest_pix, True);
+		break;
+	case PART_BORDER_W:
+		border_draw_x_mark(br, 0, 0, dest_pix, False);
+		border_draw_x_mark(br, 0, h, dest_pix, True);
+		break;
+	case PART_BORDER_NW:
+		border_draw_x_mark(br, 0, t, dest_pix, True);
+		border_draw_y_mark(br, l, 0, dest_pix, True);
+		break;
+	case PART_BORDER_NE:
+		border_draw_x_mark(br, l + o, t, dest_pix, True);
+		border_draw_y_mark(br, 0, 0, dest_pix, False);
+		break;
+	case PART_BORDER_SW:
+		border_draw_x_mark(br, 0, 0, dest_pix, False);
+		border_draw_y_mark(br, l, t + o, dest_pix, True);
+		break;
+	case PART_BORDER_SE:
+		border_draw_x_mark(br, l + o, 0, dest_pix, False);
+		border_draw_y_mark(br, 0, t + o, dest_pix, False);
+		break;
+	default:
+		return;
+	}
+
+	return;
+}
+
+inline static void border_set_part_background(
+	Window w, Pixmap pix)
+{
+	XSetWindowAttributes xswa;
+
+	xswa.background_pixmap = pix;
+	XChangeWindowAttributes(dpy, w, CWBackPixmap, &xswa);
+
+	return;
+}
+
+/* render the an image into the pixmap */
+static void border_fill_pixmap_background(
+	Pixmap dest_pix, rectangle *dest_g, pixmap_background_type *bg,
+	common_decorations_type *cd)
+{
+	Bool do_tile;
+	Bool do_stretch;
+	XGCValues xgcv;
+	unsigned long valuemask;
+	Pixmap p = None, shape = None, alpha = None;
+	int src_width, src_height;
+
+	do_tile = (bg->flags.use_pixmap && bg->pixmap.flags.is_tiled) ?
+		True : False;
+	do_stretch = (bg->flags.use_pixmap && bg->pixmap.flags.is_stretched) ?
+		True : False;
+	xgcv.fill_style = FillSolid;
+	valuemask = GCFillStyle;
+	if (!bg->flags.use_pixmap)
+	{
+		/* solid pixel */
+		xgcv.foreground = bg->pixel;
+		xgcv.clip_x_origin = 0;
+		xgcv.clip_y_origin = 0;
+		xgcv.clip_mask = None;
+		valuemask |= GCForeground | GCClipMask | GCClipXOrigin |
+			GCClipYOrigin;
+		XChangeGC(dpy, Scr.BordersGC, valuemask, &xgcv);
+		XFillRectangle(
+			dpy, dest_pix, Scr.BordersGC, dest_g->x, dest_g->y,
+			dest_g->width - dest_g->x, dest_g->height - dest_g->y);
+		return;
+	}
+
+	if (do_stretch)
+	{
+		if (bg->pixmap.p)
+		{
+			p = CreateStretchPixmap(
+				dpy, bg->pixmap.p,
+				bg->pixmap.g.width, bg->pixmap.g.height,
+				bg->pixmap.depth,
+				bg->pixmap.stretch_w, bg->pixmap.stretch_h,
+				(bg->pixmap.depth == 1)?
+				Scr.MonoGC:Scr.BordersGC);
+		}
+		if (bg->pixmap.shape)
+		{
+			shape = CreateStretchPixmap(
+				dpy, bg->pixmap.shape,
+				bg->pixmap.g.width, bg->pixmap.g.height, 1,
+				bg->pixmap.stretch_w, bg->pixmap.stretch_h,
+				Scr.MonoGC);
+		}
+		if (bg->pixmap.alpha)
+		{
+			alpha = CreateStretchPixmap(
+				dpy, bg->pixmap.alpha,
+				bg->pixmap.g.width, bg->pixmap.g.height,
+				FRenderGetAlphaDepth(),
+				bg->pixmap.stretch_w, bg->pixmap.stretch_h,
+				Scr.AlphaGC);
+		}
+		src_width = bg->pixmap.stretch_w;
+		src_height = bg->pixmap.stretch_h;
+	}
+	else
+	{
+		p = bg->pixmap.p;
+		shape = bg->pixmap.shape;
+		alpha =	bg->pixmap.alpha;
+		src_width = bg->pixmap.g.width;
+		src_height = bg->pixmap.g.height;
+	}
+
+	if (do_tile == False)
+	{
+		/* pixmap, offset stored in dest_g->x/y */
+		xgcv.foreground = cd->fore_color;
+		xgcv.background = cd->back_color;
+		valuemask |= GCForeground|GCBackground;
+		XChangeGC(dpy, Scr.BordersGC, valuemask, &xgcv);
+		PGraphicsRenderPixmaps(
+			dpy, Scr.NoFocusWin, p, shape, alpha,
+			bg->pixmap.depth, &(bg->pixmap.fra),
+			dest_pix, Scr.BordersGC, Scr.MonoGC, Scr.AlphaGC,
+			bg->pixmap.g.x, bg->pixmap.g.y,
+			src_width, src_height,
+			dest_g->x, dest_g->y, dest_g->width - dest_g->x,
+			dest_g->height - dest_g->y, False);
+	}
+	else
+	{
+		/* tiled pixmap */
+		xgcv.foreground = cd->fore_color;
+		xgcv.background = cd->back_color;
+		valuemask |= GCForeground|GCBackground;
+		XChangeGC(dpy, Scr.BordersGC, valuemask, &xgcv);
+		PGraphicsRenderPixmaps(
+			dpy, Scr.NoFocusWin, p, shape, alpha,
+			bg->pixmap.depth, &(bg->pixmap.fra),
+			dest_pix, Scr.BordersGC, Scr.MonoGC, Scr.AlphaGC,
+			bg->pixmap.g.x, bg->pixmap.g.y,
+			src_width, src_height,
+			dest_g->x, dest_g->y,
+			dest_g->width - dest_g->x,
+			dest_g->height - dest_g->y, True);
+	}
+	if (p && p != bg->pixmap.p)
+	{
+		XFreePixmap(dpy, p);
+	}
+	if (shape && shape != bg->pixmap.shape)
+	{
+		XFreePixmap(dpy, shape);
+	}
+	if (alpha && alpha != bg->pixmap.alpha)
+	{
+		XFreePixmap(dpy, alpha);
+	}
+	return;
+}
+
+/* create a root transparent colorset bg, we take in account a possible
+ * drawing rotation */
+static Pixmap border_create_root_transparent_pixmap(
+	titlebar_descr *td, Window w, int width, int height, int cs)
+{
+	int my_w, my_h;
+	Pixmap p;
+
+	if (!CSET_IS_TRANSPARENT_ROOT(cs))
+	{
+		return None;
+	}
+	if (td->td_is_rotated &&
+	    (td->draw_rotation == ROTATION_90 ||
+	     td->draw_rotation == ROTATION_270))
+	{
+		my_h = width;
+		my_w = height;
+	}
+	else
+	{
+		my_w = width;
+		my_h = height;
+	}
+	p = CreateBackgroundPixmap(
+		dpy, w, my_w, my_h, &Colorset[cs],
+		Pdepth, Scr.BordersGC, False);
+	if (p && td->td_is_rotated)
+	{
+		Pixmap tmp;
+		tmp = CreateRotatedPixmap(
+			dpy, p, my_w, my_h, Pdepth, Scr.BordersGC,
+			td->restore_rotation);
+		XFreePixmap(dpy, p);
+		p = tmp;
+	}
+	return p;
+}
+
+static void border_get_frame_pixmap(
+	common_decorations_type *cd, rectangle *frame_g)
+{
+	dynamic_common_decorations *dcd = &(cd->dynamic_cd);
+
+	if (dcd->frame_pixmap != None)
+	{
+		/* should not happen */
+		fprintf(stderr, "Bad use of border_get_frame_pixmap!!\n");
+		dcd->frame_pixmap = None;
+	}
+
+	if (cd->bg_border_cs < 0 || CSET_IS_TRANSPARENT(cd->bg_border_cs))
+	{
+		/* should not happen */
+	}
+	else
+	{
+		dcd->frame_pixmap = CreateBackgroundPixmap(
+			dpy, Scr.NoFocusWin, frame_g->width, frame_g->height,
+			&Colorset[cd->bg_border_cs], Pdepth, Scr.BordersGC,
+			False);
+	}
+	return;
+}
+
+static void border_get_border_background(
+	pixmap_background_type *bg, common_decorations_type *cd,
+	rectangle *part_g, rectangle *relative_g, int *free_bg_pixmap, Window w)
+{
+	*free_bg_pixmap = False;
+
+	if (cd->texture_pixmap)
+	{
+		bg->flags.use_pixmap = 1;
+		bg->pixmap.p = cd->texture_pixmap;
+		bg->pixmap.g.width = cd->texture_pixmap_width;
+		bg->pixmap.g.height = cd->texture_pixmap_height;
+		bg->pixmap.shape = None;
+		bg->pixmap.alpha = None;
+		bg->pixmap.depth = Pdepth;
+		bg->pixmap.flags.is_tiled = 1;
+		bg->pixmap.flags.is_stretched = 0;
+		bg->pixmap.fra.mask = 0;
+	}
+	else if (cd->bg_border_cs >= 0 &&
+		 !CSET_IS_TRANSPARENT_PR(cd->bg_border_cs))
+	{
+		colorset_t *cs_t = &Colorset[cd->bg_border_cs];
+		XGCValues xgcv;
+
+		if (CSET_IS_TRANSPARENT_ROOT(cd->bg_border_cs))
+		{
+			bg->pixmap.p = CreateBackgroundPixmap(
+				dpy, w, part_g->width, part_g->height, cs_t,
+				Pdepth, Scr.BordersGC, False);
+		}
+		else
+		{
+			/* FIXME */
+			if (cd->dynamic_cd.frame_pixmap == None)
+			{
+				border_get_frame_pixmap(cd, relative_g);
+			}
+			bg->pixmap.p = XCreatePixmap(
+				dpy, cd->dynamic_cd.frame_pixmap, part_g->width,
+				part_g->height, Pdepth);
+			xgcv.fill_style = FillTiled;
+			xgcv.tile = cd->dynamic_cd.frame_pixmap;
+			xgcv.ts_x_origin = - relative_g->x;
+			xgcv.ts_y_origin = - relative_g->y;
+			XChangeGC(
+				dpy, Scr.BordersGC, GCTile | GCTileStipXOrigin |
+				GCTileStipYOrigin | GCFillStyle, &xgcv);
+			XFillRectangle(
+				dpy, bg->pixmap.p, Scr.BordersGC, 0, 0,
+				part_g->width, part_g->height);
+			xgcv.fill_style = FillSolid;
+			XChangeGC(dpy, Scr.BordersGC, GCFillStyle, &xgcv);
+		}
+		bg->pixmap.g.width = part_g->width;
+		bg->pixmap.g.height = part_g->height;
+		bg->flags.use_pixmap = 1;
+		bg->pixmap.shape = None;
+		bg->pixmap.alpha = None;
+		bg->pixmap.depth = Pdepth;
+		bg->pixmap.flags.is_tiled = 1;
+		bg->pixmap.flags.is_stretched = 0;
+		bg->pixmap.fra.mask = 0;
+		*free_bg_pixmap = True;
+	}
+	else
+	{
+		bg->flags.use_pixmap = 0;
+		bg->pixel = cd->attributes.background_pixel;
+	}
+
+	return;
+}
+
+static void border_draw_one_border_part(
+	common_decorations_type *cd, FvwmWindow *fw, rectangle *sidebar_g,
+	rectangle *frame_g, border_relief_descr *br, window_parts part,
+	window_parts draw_handles, Bool is_inverted, Bool do_clear)
+{
+	pixmap_background_type bg;
+	rectangle part_g;
+	rectangle pix_g;
+	rectangle relative_g;
+	Pixmap p;
+	Window w;
+	Bool free_bg_pixmap = False;
+
+	/* make a pixmap */
+	border_get_part_geometry(fw, part, sidebar_g, &part_g, &w);
+	if (part_g.width <= 0 || part_g.height <= 0)
+	{
+		return;
+	}
+	p = border_create_decor_pixmap(cd, &part_g);
+	/* set the background tile */
+	relative_g.width = fw->g.frame.width;
+	relative_g.height = fw->g.frame.height;
+	relative_g.x = part_g.x;
+	relative_g.y = part_g.y;
+	border_get_border_background(
+		&bg, cd, &part_g, &relative_g, &free_bg_pixmap, w);
+	if (cd->texture_pixmap)
+	{
+		switch (part)
+		{
+		case PART_BORDER_E:
+			bg.pixmap.g.x = frame_g->width - fw->boundary_width;
+			break;
+		case PART_BORDER_NE:
+		case PART_BORDER_SE:
+			bg.pixmap.g.x = frame_g->width - fw->corner_width;
+			break;
+		case PART_BORDER_N:
+		case PART_BORDER_S:
+			bg.pixmap.g.x = fw->corner_width;
+			break;
+		default:
+			bg.pixmap.g.x = 0;
+			break;
+		}
+		switch (part)
+		{
+		case PART_BORDER_S:
+			bg.pixmap.g.y = frame_g->height - fw->boundary_width;
+			break;
+		case PART_BORDER_SW:
+		case PART_BORDER_SE:
+			bg.pixmap.g.y = frame_g->height - fw->corner_width;
+			break;
+		case PART_BORDER_W:
+		case PART_BORDER_E:
+			bg.pixmap.g.y = fw->corner_width;
+			break;
+		default:
+			bg.pixmap.g.y = 0;
+			break;
+		}
+	}
+	else
+	{
+		bg.pixmap.g.x = 0;
+		bg.pixmap.g.y = 0;
+	}
+	/* set the geometry for drawing the Tiled pixmap; maybe add the relief
+	 * as offset? */
+	pix_g.x = 0;
+	pix_g.y = 0;
+	pix_g.width = part_g.width;
+	pix_g.height = part_g.height;
+	border_fill_pixmap_background(p, &pix_g, &bg, cd);
+	if (free_bg_pixmap && bg.pixmap.p)
+	{
+		XFreePixmap(dpy, bg.pixmap.p);
+	}
+	/* draw the relief over the background */
+	if (!br->relief.is_flat)
+	{
+		border_draw_part_relief(br, frame_g, &part_g, p, is_inverted);
+		/* draw the handle marks */
+		if (br->marks.has_x_marks || br->marks.has_y_marks)
+		{
+			border_draw_part_marks(br, &part_g, part, p);
+		}
+	}
+	/* apply the pixmap and destroy it */
+	border_set_part_background(w, p);
+	if (do_clear == True)
+	{
+		XClearWindow(dpy,w);
+	}
+	XFreePixmap(dpy, p);
+
+	return;
+}
+
+static void border_draw_all_border_parts(
+	common_decorations_type *cd, FvwmWindow *fw, border_relief_descr *br,
+	rectangle *frame_g, window_parts draw_parts,
+	window_parts pressed_parts, Bool do_hilight, Bool do_clear)
+{
+	window_parts part;
+	window_parts draw_handles;
+
+	/* get the description of the drawing directives */
+	border_get_border_relief_size_descr(&br->relief, fw, do_hilight);
+	border_get_border_marks_descr(cd, br, fw);
+	/* fetch the gcs used to draw the border */
+	border_get_border_gcs(&br->gcs, cd, fw, do_hilight);
+	/* draw everything in a big loop */
+	draw_parts &= (PART_FRAME | PART_HANDLES);
+	draw_handles = (draw_parts & PART_HANDLES);
+
+	for (part = PART_BORDER_N; (part & PART_FRAME); part <<= 1)
+	{
+		if (part & draw_parts)
+		{
+			border_draw_one_border_part(
+				cd, fw, &br->sidebar_g, frame_g, br, part,
+				draw_handles,
+				(pressed_parts & part) ? True : False,
+				do_clear);
+		}
+	}
+
+	return;
+}
+
+/*
+ *
+ *  Draws a little pattern within a window (more complex)
+ *
+ */
+static void border_draw_vector_to_pixmap(
+	Pixmap dest_pix, common_decorations_type *cd, int is_toggled,
+	struct vector_coords *coords, rectangle *pixmap_g)
+{
+	GC gcs[4];
+	int i;
+
+	if (coords->use_fgbg == 1)
+	{
+		Globalgcv.foreground = cd->fore_color;
+		Globalgcm = GCForeground;
+		XChangeGC(dpy, Scr.ScratchGC3, Globalgcm, &Globalgcv);
+		Globalgcv.foreground = cd->back_color;
+		XChangeGC(dpy, Scr.ScratchGC4, Globalgcm, &Globalgcv);
+		gcs[3] = Scr.ScratchGC3; /* @3 is fg */
+		gcs[2] = Scr.ScratchGC4; /* @2 is bg */
+	}
+	if (is_toggled)
+	{
+		gcs[0] = cd->relief_gc;
+		gcs[1] = cd->shadow_gc;
+	}
+	else
+	{
+		gcs[0] = cd->shadow_gc;
+		gcs[1] = cd->relief_gc;
+	}
+	for (i = 1; i < coords->num; i++)
+	{
+		if (coords->c[i] < 0 || coords->c[i] >= 4)
+		{
+			/* don't draw a line */
+			continue;
+		}
+		XDrawLine(
+			dpy, dest_pix, gcs[coords->c[i]],
+			pixmap_g->width * coords->x[i-1] / 100 +
+			coords->xoff[i-1],
+			pixmap_g->height * coords->y[i-1] / 100 +
+			coords->yoff[i-1],
+			pixmap_g->width * coords->x[i] / 100 +
+			coords->xoff[i],
+			pixmap_g->height * coords->y[i] / 100 +
+			coords->yoff[i]);
+	}
+
+	return;
+}
+
+/*
+ *
+ *  Handle Title pixmaps used for UseTitleStyle
+ *
+ */
+static void border_setup_bar_pixmaps(
+	titlebar_descr *td, dynamic_common_decorations *dcd, DecorFace *df,
+	ButtonState bs)
+{
+	int count = dcd->bar_pixmaps[bs].count;
+	DecorFace *tsdf;
+	int i, j, mp_part_left, mp_part_right;
+
+	if (count != 0)
+	{
+		/* ok */
+		return;
+	}
+
+	for (tsdf = df; tsdf != NULL; tsdf = tsdf->next)
+	{
+		if (DFS_FACE_TYPE(tsdf->style) == ColorsetButton)
+		{
+			count++;
+		}
+		else if (DFS_FACE_TYPE(tsdf->style) == MultiPixmap)
+		{
+			border_mp_get_use_title_style_parts_and_geometry(
+				td, tsdf->u.mp.pixmaps, tsdf->u.mp.acs,
+				tsdf->u.mp.solid_flags, True, NULL,
+				&mp_part_left);
+			border_mp_get_use_title_style_parts_and_geometry(
+				td, tsdf->u.mp.pixmaps, tsdf->u.mp.acs,
+				tsdf->u.mp.solid_flags, False, NULL,
+				&mp_part_right);
+			for (j = 0; j < UTS_TBMP_NUM_PIXMAPS; j++)
+			{
+				if (j != mp_part_left && j != mp_part_right)
+				{
+					continue;
+				}
+				if (tsdf->u.mp.acs[j].cs >= 0 ||
+				    tsdf->u.mp.pixmaps[j])
+				{
+					count++;
+				}
+			}
+		}
+	}
+	if (count == 0)
+	{
+		dcd->bar_pixmaps[bs].count = -1;
+		return;
+	}
+	else
+	{
+		dcd->bar_pixmaps[bs].bps =
+			(bar_pixmap *)safemalloc(count*sizeof(bar_pixmap));
+	}
+	dcd->bar_pixmaps[bs].count = count;
+	i = 0;
+	for (tsdf = df; tsdf != NULL; tsdf = tsdf->next)
+	{
+		if (DFS_FACE_TYPE(tsdf->style) == ColorsetButton)
+		{
+			dcd->bar_pixmaps[bs].bps[i].p = None;
+			dcd->bar_pixmaps[bs].bps[i].mp_created_pic = NULL;
+			dcd->bar_pixmaps[bs].bps[i].cs = tsdf->u.acs.cs;
+			dcd->bar_pixmaps[bs].bps[i].mp_pic = NULL;
+			dcd->bar_pixmaps[bs].bps[i].created = 0;
+			dcd->bar_pixmaps[bs].bps[i].mp_part = TBMP_NONE;
+			i++;
+		}
+		else if (DFS_FACE_TYPE(tsdf->style) == MultiPixmap)
+		{
+			border_mp_get_use_title_style_parts_and_geometry(
+				td, tsdf->u.mp.pixmaps, tsdf->u.mp.acs,
+				tsdf->u.mp.solid_flags, True, NULL,
+				&mp_part_left);
+			border_mp_get_use_title_style_parts_and_geometry(
+				td, tsdf->u.mp.pixmaps, tsdf->u.mp.acs,
+				tsdf->u.mp.solid_flags, False, NULL,
+				&mp_part_right);
+			for (j = 0; j < UTS_TBMP_NUM_PIXMAPS; j++)
+			{
+				if (j != mp_part_left && j != mp_part_right)
+				{
+					continue;
+				}
+				if (tsdf->u.mp.acs[j].cs >= 0 ||
+				    tsdf->u.mp.pixmaps[j])
+				{
+					dcd->bar_pixmaps[bs].bps[i].p = None;
+					dcd->bar_pixmaps[bs].bps[i].
+						mp_created_pic = NULL;
+					dcd->bar_pixmaps[bs].bps[i].cs =
+						tsdf->u.mp.acs[j].cs;
+					dcd->bar_pixmaps[bs].bps[i].mp_pic =
+						tsdf->u.mp.pixmaps[j];
+					dcd->bar_pixmaps[bs].bps[i].created = 0;
+					dcd->bar_pixmaps[bs].bps[i].mp_part = j;
+					i++;
+				}
+			}
+		}
+	}
+}
+
+static Pixmap border_get_bar_pixmaps(
+	dynamic_common_decorations *dcd, rectangle *bar_g, ButtonState bs,
+	int cset, FvwmPicture *mp_pic, int mp_part, int stretch,
+	FvwmPicture **mp_ret_pic)
+{
+	ButtonState b;
+	int i,j;
+	int count = dcd->bar_pixmaps[bs].count;
+
+	if (count <= 0)
+	{
+		return None;
+	}
+
+	i = 0;
+	while(i < count &&
+	(dcd->bar_pixmaps[bs].bps[i].cs != cset ||
+	      dcd->bar_pixmaps[bs].bps[i].mp_part != mp_part ||
+	      dcd->bar_pixmaps[bs].bps[i].mp_pic != mp_pic))
+	{
+		i++;
+	}
+	if (i == count)
+	{
+		return None;
+	}
+	if (mp_ret_pic)
+	{
+		*mp_ret_pic = dcd->bar_pixmaps[bs].bps[i].mp_created_pic;
+	}
+	if (dcd->bar_pixmaps[bs].bps[i].p == None)
+	{
+		/* see if we have it */
+		b = 0;
+		while (b < BS_MaxButtonState)
+		{
+			int c = dcd->bar_pixmaps[b].count;
+			j = 0;
+			while(j < c &&
+			      (dcd->bar_pixmaps[b].bps[j].cs != cset ||
+			       dcd->bar_pixmaps[b].bps[j].mp_part != mp_part ||
+			       dcd->bar_pixmaps[b].bps[j].mp_pic != mp_pic))
+			{
+				j++;
+			}
+			if (j < c && dcd->bar_pixmaps[b].bps[j].p)
+			{
+				dcd->bar_pixmaps[bs].bps[i].p =
+					dcd->bar_pixmaps[b].bps[j].p;
+				if (mp_pic && mp_ret_pic)
+				{
+					*mp_ret_pic =
+						dcd->bar_pixmaps[bs].bps[i].
+						mp_created_pic =
+						dcd->bar_pixmaps[b].bps[j].
+						mp_created_pic;
+				}
+				break;
+			}
+			b++;
+		}
+	}
+	if (dcd->bar_pixmaps[bs].bps[i].p == None)
+	{
+		if (cset >= 0)
+		{
+			dcd->bar_pixmaps[bs].bps[i].p = CreateBackgroundPixmap(
+				dpy, Scr.NoFocusWin, bar_g->width, bar_g->height,
+				&Colorset[cset], Pdepth, Scr.BordersGC, False);
+			dcd->bar_pixmaps[bs].bps[i].created = True;
+		}
+		else if (mp_pic && mp_ret_pic)
+		{
+			if (stretch)
+			{
+				dcd->bar_pixmaps[bs].bps[i].mp_created_pic =
+					PGraphicsCreateStretchPicture(
+						dpy, Scr.NoFocusWin, mp_pic,
+						bar_g->width, bar_g->height,
+						Scr.BordersGC, Scr.MonoGC,
+						Scr.AlphaGC);
+			}
+			else
+			{
+				dcd->bar_pixmaps[bs].bps[i].mp_created_pic =
+					PGraphicsCreateTiledPicture(
+						dpy, Scr.NoFocusWin, mp_pic,
+						bar_g->width, bar_g->height,
+						Scr.BordersGC, Scr.MonoGC,
+						Scr.AlphaGC);
+			}
+			if (dcd->bar_pixmaps[bs].bps[i].mp_created_pic)
+			{
+				dcd->bar_pixmaps[bs].bps[i].created = True;
+				*mp_ret_pic =
+					dcd->bar_pixmaps[bs].bps[i].
+					mp_created_pic;
+				dcd->bar_pixmaps[bs].bps[i].p =
+					dcd->bar_pixmaps[bs].bps[i].
+					mp_created_pic->picture;
+			}
+		}
+	}
+	return dcd->bar_pixmaps[bs].bps[i].p;
+}
+
+static void border_free_bar_pixmaps(
+	dynamic_common_decorations *dcd)
+{
+	ButtonState bs;
+	int i;
+
+	for (bs = 0; bs < BS_MaxButtonState; bs++)
+	{
+		if (dcd->bar_pixmaps[bs].count < 1)
+		{
+			continue;
+		}
+		for (i = 0; i < dcd->bar_pixmaps[bs].count; i++)
+		{
+			if (dcd->bar_pixmaps[bs].bps[i].mp_created_pic &&
+			    dcd->bar_pixmaps[bs].bps[i].created)
+			{
+				PDestroyFvwmPicture(
+					dpy,
+					dcd->bar_pixmaps[bs].bps[i].
+					mp_created_pic);
+			}
+			else if (dcd->bar_pixmaps[bs].bps[i].p != None &&
+				 dcd->bar_pixmaps[bs].bps[i].created)
+			{
+				XFreePixmap(
+					dpy, dcd->bar_pixmaps[bs].bps[i].p);
+			}
+		}
+		free(dcd->bar_pixmaps[bs].bps);
+	}
+}
+
+/*
+ *
+ *  MultiPixmap (aka, fancy title bar) (tril@igs.net)
+ *
+ */
+#define TBMP_HAS_PART(p, pm, acs, sf) \
+       (pm[p] || acs[p].cs >= 0 || (sf & (1 << p)))
+
+/*  Tile or stretch src into dest, starting at the given location and
+ *  continuing for the given width and height. This is a utility function used
+ *  by border_mp_draw_mp_titlebar. (tril@igs.net) */
+static void border_mp_render_into_pixmap(
+	titlebar_descr *td, common_decorations_type *cd, FvwmPicture **src,
+	FvwmAcs *acs, Pixel *pixels, unsigned short solid_flags,
+	unsigned short stretch_flags, int part, Pixmap dest, Window w,
+	rectangle *full_g, rectangle *title_g, ButtonState bs, rectangle *g)
+{
+	int x = 0;
+	int y = 0;
+	pixmap_background_type bg;
+	rectangle dest_g;
+	dynamic_common_decorations *dcd;
+
+	dcd = &cd->dynamic_cd;
+	/* setup some default */
+	bg.pixmap.fra.mask = 0;
+	bg.pixmap.flags.is_stretched = 0;
+	bg.pixmap.flags.is_tiled = 0;
+	bg.flags.use_pixmap = 1;
+	bg.pixmap.p = bg.pixmap.alpha = bg.pixmap.shape = None;
+	bg.pixmap.g.x = 0;
+	bg.pixmap.g.y = 0;
+	dest_g.width = g->width + g->x;
+	dest_g.height = g->height + g->y;
+	dest_g.x = g->x;
+	dest_g.y = g->y;
+
+	if (solid_flags & (1 << part))
+	{
+		bg.flags.use_pixmap = 0;
+		bg.pixel = pixels[part];
+		border_fill_pixmap_background(dest, &dest_g, &bg, cd);
+		return;
+	}
+	else if (acs[part].cs >= 0)
+	{
+		Pixmap p = None;
+
+		bg.pixmap.fra.mask = FRAM_HAVE_ADDED_ALPHA;
+		bg.pixmap.fra.added_alpha_percent = acs[part].alpha_percent;
+		if (CSET_IS_TRANSPARENT_PR(acs[part].cs))
+		{
+			return;
+		}
+		if (CSET_IS_TRANSPARENT_ROOT(acs[part].cs))
+		{
+			p = border_create_root_transparent_pixmap(
+				td, w, g->width + g->x, g->height + g->y,
+				acs[part].cs);
+			bg.pixmap.p = p;
+			bg.pixmap.depth = Pdepth;
+			bg.pixmap.g.width = g->width;
+			bg.pixmap.g.height = g->height;
+			bg.pixmap.g.x = g->x;
+			bg.pixmap.g.y = g->y;
+		}
+		else if (full_g != NULL)
+		{
+			bg.pixmap.p = border_get_bar_pixmaps(
+				dcd, full_g, bs, acs[part].cs, NULL, part,
+				(stretch_flags & (1 << part)), NULL);
+			if (bg.pixmap.p)
+			{
+				if (part != TBMP_RIGHT_MAIN)
+				{
+					/* left buttons offset */
+					x = title_g->x - full_g->x;
+					y = title_g->y - full_g->y;
+				}
+				bg.pixmap.g.width = full_g->width;
+				bg.pixmap.g.height = full_g->height;
+				bg.pixmap.flags.is_tiled = 1;
+				bg.pixmap.g.x = x;
+				bg.pixmap.g.y = y;
+				bg.pixmap.depth = Pdepth;
+			}
+		}
+		if (!bg.pixmap.p)
+		{
+			int bg_w, bg_h;
+
+			p = CreateBackgroundPixmap(
+				dpy, w, g->width, g->height,
+				&Colorset[acs[part].cs], Pdepth, Scr.BordersGC,
+				False);
+			bg.pixmap.p = p;
+			GetWindowBackgroundPixmapSize(
+				&Colorset[acs[part].cs], g->width, g->height,
+				&bg_w, &bg_h);
+			bg.pixmap.g.width = bg_w;
+			bg.pixmap.g.height = bg_h;
+			bg.pixmap.depth = Pdepth;
+			bg.pixmap.flags.is_tiled = 1;
+		}
+		if (bg.pixmap.p)
+		{
+			border_fill_pixmap_background(dest, &dest_g, &bg, cd);
+		}
+		if (p)
+		{
+			XFreePixmap(dpy, p);
+		}
+	}
+	else if (src[part])
+	{
+		FvwmPicture *full_pic = NULL;
+		Pixmap p;
+
+		if (full_g != NULL)
+		{
+			p = border_get_bar_pixmaps(
+				dcd, full_g, bs, -1, src[part], part,
+				(stretch_flags & (1 << part)), &full_pic);
+			if (p && full_pic)
+			{
+				if (part != TBMP_RIGHT_MAIN)
+				{
+					/* left buttons offset */
+					x = title_g->x - full_g->x;
+					y = title_g->y - full_g->y;
+				}
+				bg.pixmap.p = full_pic->picture;
+				bg.pixmap.shape = full_pic->mask;
+				bg.pixmap.alpha = full_pic->alpha;
+				bg.pixmap.depth = full_pic->depth;
+				bg.pixmap.g.width = full_pic->width;
+				bg.pixmap.g.height = full_pic->height;
+				bg.pixmap.g.x = x;
+				bg.pixmap.g.y = y;
+			}
+		}
+		if (!bg.pixmap.p)
+		{
+			if (stretch_flags & (1 << part))
+			{
+				bg.pixmap.flags.is_stretched = 1;
+			}
+			else
+			{
+				bg.pixmap.flags.is_tiled = 1;
+			}
+			bg.pixmap.p = src[part]->picture;
+			bg.pixmap.shape = src[part]->mask;
+			bg.pixmap.alpha = src[part]->alpha;
+			bg.pixmap.depth = src[part]->depth;
+			bg.pixmap.g.width = src[part]->width;
+			bg.pixmap.g.height = src[part]->height;
+			bg.pixmap.stretch_w = dest_g.width - dest_g.x;
+			bg.pixmap.stretch_h = dest_g.height - dest_g.y;
+
+		}
+		if (bg.pixmap.p)
+		{
+			border_fill_pixmap_background(dest, &dest_g, &bg, cd);
+		}
+	}
+
+	return;
+}
+
+static int border_mp_get_length(
+	titlebar_descr *td, FvwmPicture **pm, FvwmAcs *acs,
+	unsigned int solid_flags, int part)
+{
+	if (acs[part].cs >= 0 || (solid_flags & (1 << part)))
+	{
+		/* arbitrary */
+		if (td->has_vt)
+		{
+			return td->bar_g.width/2;
+		}
+		else
+		{
+			return td->bar_g.height/2;
+		}
+	}
+	if (pm[part] == NULL)
+	{
+		return 0;
+	}
+	else if (td->has_vt)
+	{
+		return pm[part]->height;
+	}
+	else
+	{
+		return pm[part]->width;
+	}
+}
+
+/* geometries relatively to the frame */
+static void border_mp_get_titlebar_descr(
+	FvwmWindow *fw, titlebar_descr *td, DecorFace *df)
+{
+	DecorFace *tsdf;
+	FvwmPicture **pm;
+	FvwmAcs *acs;
+	int add,tmpi;
+	int left_of_text = 0;
+	int right_of_text = 0;
+	int left_end = 0;
+	int right_end = 0;
+	int before_space, after_space, under_offset, under_width;
+	Bool has_mp = False;
+	JustificationType just;
+	unsigned short sf;
+	int is_start = 0;
+
+	just = TB_JUSTIFICATION(GetDecor(fw, titlebar));
+	/* first compute under text width */
+	if (td->length > 0)
+	{
+		under_width = td->length + 2*TBMP_TITLE_PADDING;
+	}
+	else
+	{
+		under_width = 0;
+	}
+	if (under_width > fw->title_length)
+	{
+		under_width = fw->title_length;
+		td->offset = (fw->title_length - td->length) / 2;
+		just = JUST_CENTER;
+	}
+	for (tsdf = df; tsdf != NULL; tsdf = tsdf->next)
+	{
+		if (tsdf->style.face_type != MultiPixmap)
+		{
+			continue;
+		}
+		has_mp = True;
+		acs = tsdf->u.mp.acs;
+		pm = tsdf->u.mp.pixmaps;
+		sf = tsdf->u.mp.solid_flags;
+		add = border_mp_get_length(
+			td, pm, acs, sf, TBMP_LEFT_OF_TEXT);
+		if (add > left_of_text &&
+		    add + left_end + right_of_text + right_end + under_width +
+		    2*TBMP_MIN_RL_TITLE_LENGTH <= fw->title_length)
+		{
+			left_of_text = add;
+		}
+		add = border_mp_get_length(
+			td, pm, acs, sf, TBMP_RIGHT_OF_TEXT);
+		if (add > right_of_text &&
+		    add + left_end + left_of_text + right_end + under_width +
+		    2*TBMP_MIN_RL_TITLE_LENGTH <= fw->title_length)
+		{
+			right_of_text = add;
+		}
+		add = border_mp_get_length(
+			td, pm, acs, sf, TBMP_LEFT_END);
+		if (add > left_end &&
+		    add + right_of_text + left_of_text + right_end +
+		    under_width + 2*TBMP_MIN_RL_TITLE_LENGTH <= fw->title_length)
+		{
+			left_end = add;
+		}
+		add = border_mp_get_length(
+			td, pm, acs, sf, TBMP_RIGHT_END);
+		if (add > right_end &&
+		    add + right_of_text + left_of_text + left_end +
+		    under_width + 2*TBMP_MIN_RL_TITLE_LENGTH <= fw->title_length)
+		{
+			right_end = add;
+		}
+	}
+
+	if (!has_mp)
+	{
+		return;
+	}
+
+	switch (just)
+	{
+	case JUST_LEFT:
+		is_start = 1;
+		/* fall through */
+	case JUST_RIGHT:
+		if (td->has_an_upsidedown_rotation)
+		{
+			is_start = !is_start;
+		}
+		if (is_start)
+		{
+			if (td->has_an_upsidedown_rotation)
+			{
+				td->offset = max(
+					td->offset, right_of_text + right_end +
+					TBMP_MIN_RL_TITLE_LENGTH +
+					TBMP_TITLE_PADDING);
+			}
+			else
+			{
+				td->offset = max(
+					td->offset, left_of_text + left_end +
+					TBMP_MIN_RL_TITLE_LENGTH +
+					TBMP_TITLE_PADDING);
+			}
+		}
+		else
+		{
+			if (td->has_an_upsidedown_rotation)
+			{
+				td->offset = min(
+					td->offset, fw->title_length -
+					(td->length + left_of_text +
+					 left_end + TBMP_MIN_RL_TITLE_LENGTH +
+					 TBMP_TITLE_PADDING));
+			}
+			else
+			{
+				td->offset = min(
+					td->offset, fw->title_length -
+					(td->length + right_of_text +
+					 right_end + TBMP_MIN_RL_TITLE_LENGTH +
+					 TBMP_TITLE_PADDING));
+			}
+		}
+		break;
+	case JUST_CENTER:
+	default:
+		break;
+	}
+
+	under_offset = td->offset - (under_width - td->length)/2;
+	before_space = under_offset;
+	if (td->has_vt)
+	{
+		after_space =
+			td->layout.title_g.height - before_space - under_width;
+	}
+	else
+	{
+		after_space =
+			td->layout.title_g.width - before_space - under_width;
+	}
+	if (td->has_an_upsidedown_rotation)
+	{
+		td->left_end_length = right_end;
+		td->left_of_text_length = right_of_text;
+		td->right_of_text_length = left_of_text;
+		td->right_end_length = left_end;
+		tmpi = before_space;
+		before_space = after_space;
+		after_space = tmpi;
+	}
+	else
+	{
+		td->left_end_length = left_end;
+		td->left_of_text_length = left_of_text;
+		td->right_of_text_length = right_of_text;
+		td->right_end_length = right_end;
+	}
+
+	if (td->has_vt)
+	{
+		td->under_text_g.width = td->bar_g.width;
+		td->under_text_g.height = under_width;
+		td->under_text_g.x = 0;
+		td->under_text_g.y = under_offset;
+	}
+	else
+	{
+		td->under_text_g.height = td->bar_g.height;
+		td->under_text_g.width = under_width;
+		td->under_text_g.x = under_offset;
+		td->under_text_g.y = 0;
+	}
+
+	/* width & height */
+	if (td->has_vt)
+	{
+		/* left */
+		td->full_left_main_g.width = td->bar_g.width;
+		td->full_left_main_g.height =
+			before_space + td->left_buttons_g.height;
+		td->left_main_g.width = td->bar_g.width;
+		td->left_main_g.height = before_space;
+		/* right */
+		td->full_right_main_g.width = td->bar_g.width;
+		td->full_right_main_g.height = after_space +
+			td->right_buttons_g.height;
+		td->right_main_g.width = td->bar_g.width;
+		td->right_main_g.height = after_space;
+	}
+	else
+	{
+		/* left */
+		td->full_left_main_g.height = td->bar_g.height;
+		td->full_left_main_g.width =
+			before_space + td->left_buttons_g.width;
+		td->left_main_g.height = td->bar_g.height;
+		td->left_main_g.width = before_space;
+		/* right */
+		td->full_right_main_g.height = td->bar_g.height;
+		td->full_right_main_g.width = after_space +
+			td->right_buttons_g.width;
+		td->right_main_g.height = td->bar_g.height;
+		td->right_main_g.width = after_space;
+	}
+
+	/* position */
+	if (td->has_an_upsidedown_rotation)
+	{
+		td->full_right_main_g.x = td->bar_g.x;
+		td->full_right_main_g.y = td->bar_g.y;
+		td->right_main_g.x = 0;
+		td->right_main_g.y = 0;
+	}
+	else
+	{
+		td->full_left_main_g.x = td->bar_g.x;
+		td->full_left_main_g.y = td->bar_g.y;
+		td->left_main_g.x = 0;
+		td->left_main_g.y = 0;
+	}
+
+	if (td->has_vt)
+	{
+		if (td->has_an_upsidedown_rotation)
+		{
+			td->full_left_main_g.x = td->bar_g.x;
+			td->full_left_main_g.y =
+				td->full_right_main_g.height + td->bar_g.y +
+				td->under_text_g.height;
+			td->left_main_g.y =
+				td->under_text_g.y + td->under_text_g.height;
+			td->left_main_g.x = 0;
+		}
+		else
+		{
+			td->full_right_main_g.x = td->bar_g.x;
+			td->full_right_main_g.y =
+				td->full_left_main_g.height + td->bar_g.y +
+				td->under_text_g.height;
+			td->right_main_g.y =
+				td->under_text_g.y + td->under_text_g.height;
+			td->right_main_g.x = 0;
+		}
+	}
+	else
+	{
+		if (td->has_an_upsidedown_rotation)
+		{
+			td->full_left_main_g.x =
+				td->full_right_main_g.width + td->bar_g.x +
+				td->under_text_g.width;
+			td->full_left_main_g.y = td->bar_g.y;
+			td->left_main_g.x =
+				td->under_text_g.x + td->under_text_g.width;
+			td->left_main_g.y = 0;
+		}
+		else
+		{
+			td->full_right_main_g.x =
+				td->full_left_main_g.width + td->bar_g.x +
+				td->under_text_g.width;
+			td->full_right_main_g.y = td->bar_g.y;
+			td->right_main_g.x =
+				td->under_text_g.x + td->under_text_g.width;
+			td->right_main_g.y = 0;
+		}
+	}
+}
+
+/* the returned geometries are relative to the titlebar (not the frame) */
+static void border_mp_get_extreme_geometry(
+	titlebar_descr *td, FvwmPicture **pm, FvwmAcs *acs, unsigned short sf,
+	rectangle *left_of_text_g, rectangle *right_of_text_g,
+	rectangle *left_end_g, rectangle *right_end_g)
+{
+	int left_of_text = 0;
+	int right_of_text = 0;
+	int left_end = 0;
+	int right_end = 0;
+
+	left_of_text = border_mp_get_length(
+		td, pm, acs, sf, TBMP_LEFT_OF_TEXT);
+	left_end = border_mp_get_length(
+		td, pm, acs, sf, TBMP_LEFT_END);
+	right_of_text = border_mp_get_length(
+		td, pm, acs, sf, TBMP_RIGHT_OF_TEXT);
+	right_end = border_mp_get_length(
+			td, pm, acs, sf, TBMP_RIGHT_END);
+
+	if (left_of_text > 0 && left_of_text <= td->left_of_text_length)
+	{
+		if (td->has_vt)
+		{
+			left_of_text_g->y = td->under_text_g.y - left_of_text;
+			left_of_text_g->x = 0;
+			left_of_text_g->height = left_of_text;
+			left_of_text_g->width = td->bar_g.width;
+		}
+		else
+		{
+			left_of_text_g->x = td->under_text_g.x - left_of_text;
+			left_of_text_g->y = 0;
+			left_of_text_g->width = left_of_text;
+			left_of_text_g->height = td->bar_g.height;
+		}
+	}
+	else
+	{
+		left_of_text_g->x = 0;
+		left_of_text_g->y = 0;
+		left_of_text_g->width = 0;
+		left_of_text_g->height = 0;
+	}
+
+	if (right_of_text > 0 && right_of_text <= td->right_of_text_length)
+	{
+		if (td->has_vt)
+		{
+			right_of_text_g->y =
+				td->under_text_g.y + td->under_text_g.height;
+			right_of_text_g->x = 0;
+			right_of_text_g->height = right_of_text;
+			right_of_text_g->width = td->bar_g.width;
+		}
+		else
+		{
+			right_of_text_g->x =
+				td->under_text_g.x + td->under_text_g.width;
+			right_of_text_g->y = 0;
+			right_of_text_g->width = right_of_text;
+			right_of_text_g->height = td->bar_g.height;
+		}
+	}
+	else
+	{
+		right_of_text_g->x = 0;
+		right_of_text_g->y = 0;
+		right_of_text_g->width = 0;
+		right_of_text_g->height = 0;
+	}
+
+	if (left_end > 0 && left_end <= td->left_end_length)
+	{
+		if (td->has_vt)
+		{
+			left_end_g->y = 0;
+			left_end_g->x = 0;
+			left_end_g->height = left_end;
+			left_end_g->width = td->bar_g.width;
+		}
+		else
+		{
+			left_end_g->x = 0;
+			left_end_g->y = 0;
+			left_end_g->width = left_end;
+			left_end_g->height = td->bar_g.height;
+		}
+	}
+	else
+	{
+		left_end_g->x = 0;
+		left_end_g->y = 0;
+		left_end_g->width = 0;
+		left_end_g->height = 0;
+	}
+
+	if (right_end > 0 && right_end <= td->right_end_length)
+	{
+		if (td->has_vt)
+		{
+			right_end_g->y =
+				td->layout.title_g.height - right_end;
+			right_end_g->x = 0;
+			right_end_g->height = right_end;
+			right_end_g->width = td->bar_g.width;
+		}
+		else
+		{
+			right_end_g->x =
+				td->layout.title_g.width - right_end;
+			right_end_g->y = 0;
+			right_end_g->width = right_end;
+			right_end_g->height = td->bar_g.height;
+		}
+	}
+	else
+	{
+		right_end_g->x = 0;
+		right_end_g->y = 0;
+		right_end_g->width = 0;
+		right_end_g->height = 0;
+	}
+
+	return;
+}
+
+static Bool border_mp_get_use_title_style_parts_and_geometry(
+	titlebar_descr *td, FvwmPicture **pm, FvwmAcs *acs,
+	unsigned short sf, int is_left, rectangle *g, int *part)
+{
+	rectangle *tmp_g = NULL;
+	Bool g_ok = True;
+
+	if (is_left && TBMP_HAS_PART(TBMP_LEFT_BUTTONS, pm, acs, sf))
+	{
+		*part = TBMP_LEFT_BUTTONS;
+		tmp_g = &td->left_buttons_g;
+	}
+	else if (!is_left && TBMP_HAS_PART(TBMP_RIGHT_BUTTONS, pm, acs, sf))
+	{
+		*part = TBMP_RIGHT_BUTTONS;
+		tmp_g = &td->right_buttons_g;
+	}
+	else if (is_left && TBMP_HAS_PART(TBMP_LEFT_MAIN, pm, acs, sf))
+	{
+		*part = TBMP_LEFT_MAIN;
+		tmp_g = &td->full_left_main_g;
+	}
+	else if (!is_left && TBMP_HAS_PART(TBMP_RIGHT_MAIN, pm, acs, sf))
+	{
+		*part = TBMP_RIGHT_MAIN;
+		tmp_g = &td->full_right_main_g;
+	}
+	else if (TBMP_HAS_PART(TBMP_MAIN, pm, acs, sf))
+	{
+		*part = TBMP_MAIN;
+		tmp_g = &(td->bar_g);
+	}
+	else
+	{
+		*part = TBMP_NONE;
+	}
+	if (g && tmp_g)
+	{
+		g->x = tmp_g->x;
+		g->y = tmp_g->y;
+		g->width = tmp_g->width;
+		g->height = tmp_g->height;
+		g_ok = True;
+	}
+
+	return g_ok;
+}
+
+/*  Redraws multi-pixmap titlebar (tril@igs.net) */
+static void border_mp_draw_mp_titlebar(
+	FvwmWindow *fw, titlebar_descr *td, DecorFace *df, Pixmap dest_pix,
+	Window w)
+{
+	FvwmPicture **pm;
+	FvwmAcs *acs;
+	Pixel *pixels;
+	unsigned short solid_flags;
+	unsigned short stretch_flags;
+	rectangle tmp_g, left_of_text_g,left_end_g,right_of_text_g,right_end_g;
+	dynamic_common_decorations *dcd;
+	ButtonState bs;
+
+	dcd = &(td->cd->dynamic_cd);
+	bs = td->tbstate.tstate;
+	pm = df->u.mp.pixmaps;
+	acs = df->u.mp.acs;
+	pixels = df->u.mp.pixels;
+	stretch_flags = df->u.mp.stretch_flags;
+	solid_flags = df->u.mp.solid_flags;
+	tmp_g.x = 0;
+	tmp_g.y = 0;
+	tmp_g.width = td->layout.title_g.width;
+	tmp_g.height = td->layout.title_g.height;
+
+	if (TBMP_HAS_PART(TBMP_MAIN, pm, acs, solid_flags))
+	{
+		border_mp_render_into_pixmap(
+			td, td->cd, pm, acs, pixels, solid_flags, stretch_flags,
+			TBMP_MAIN, dest_pix, w, &td->bar_g, &td->layout.title_g,
+			bs, &tmp_g);
+	}
+	else if (td->length <= 0)
+	{
+		border_mp_render_into_pixmap(
+			td, td->cd, pm, acs, pixels, solid_flags, stretch_flags,
+			TBMP_LEFT_MAIN, dest_pix, w, NULL, &td->layout.title_g,
+			bs, &tmp_g);
+	}
+
+	border_mp_get_extreme_geometry(
+		td, pm, acs, solid_flags, &left_of_text_g, &right_of_text_g,
+		&left_end_g, &right_end_g);
+
+	if (td->length > 0)
+	{
+		if (TBMP_HAS_PART(TBMP_LEFT_MAIN, pm, acs, solid_flags) &&
+		    td->left_main_g.width > 0 && td->left_main_g.height > 0)
+		{
+			border_mp_render_into_pixmap(
+				td, td->cd, pm, acs, pixels, solid_flags,
+				stretch_flags, TBMP_LEFT_MAIN, dest_pix, w,
+				&td->full_left_main_g, &td->layout.title_g, bs,
+				&td->left_main_g);
+		}
+		if (TBMP_HAS_PART(TBMP_RIGHT_MAIN, pm, acs, solid_flags) &&
+		    td->right_main_g.width > 0 && td->right_main_g.height > 0)
+		{
+			border_mp_render_into_pixmap(
+				td, td->cd, pm, acs, pixels, solid_flags,
+				stretch_flags, TBMP_RIGHT_MAIN, dest_pix, w,
+				&td->full_right_main_g, &td->layout.title_g, bs,
+				&td->right_main_g);
+		}
+		if (TBMP_HAS_PART(TBMP_UNDER_TEXT, pm, acs, solid_flags)  &&
+		    td->under_text_g.width > 0 && td->under_text_g.height > 0)
+		{
+			border_mp_render_into_pixmap(
+				td, td->cd, pm, acs, pixels, solid_flags,
+				stretch_flags, TBMP_UNDER_TEXT, dest_pix, w,
+				NULL, &td->layout.title_g, bs,
+				&td->under_text_g);
+		}
+		if (left_of_text_g.width > 0 && left_of_text_g.height > 0)
+		{
+			border_mp_render_into_pixmap(
+				td, td->cd, pm, acs, pixels, solid_flags,
+				stretch_flags, TBMP_LEFT_OF_TEXT, dest_pix, w,
+				NULL, &td->layout.title_g, bs, &left_of_text_g);
+		}
+		if (right_of_text_g.width > 0 && right_of_text_g.height > 0)
+		{
+			border_mp_render_into_pixmap(
+				td, td->cd, pm, acs, pixels, solid_flags,
+				stretch_flags, TBMP_RIGHT_OF_TEXT, dest_pix, w,
+				NULL, &td->layout.title_g, bs, &right_of_text_g);
+		}
+	}
+	if (left_end_g.width > 0 && left_end_g.height > 0)
+	{
+		border_mp_render_into_pixmap(
+			td, td->cd, pm, acs, pixels, solid_flags, stretch_flags,
+			TBMP_LEFT_END, dest_pix, w, NULL, &td->layout.title_g,
+			bs, &left_end_g);
+	}
+	if (right_end_g.width > 0 && right_end_g.height > 0)
+	{
+		border_mp_render_into_pixmap(
+			td, td->cd, pm, acs, pixels, solid_flags, stretch_flags,
+			TBMP_RIGHT_END, dest_pix, w, NULL, &td->layout.title_g,
+			bs, &right_end_g);
+	}
+
+	return;
+}
+
+/*
+ *
+ *  draw title bar and buttons
+ *
+ */
+static void border_draw_decor_to_pixmap(
+	FvwmWindow *fw, Pixmap dest_pix, Window w,
+	pixmap_background_type *solid_bg, rectangle *w_g,
+	DecorFace *df, titlebar_descr *td, ButtonState bs,
+	int use_title_style, int is_toggled, int left1right0)
+{
+	register DecorFaceType type = DFS_FACE_TYPE(df->style);
+	pixmap_background_type bg;
+	rectangle dest_g;
+	FvwmPicture *p;
+	int width,height;
+	int border;
+	int lr_just, tb_just;
+	common_decorations_type *cd;
+
+	cd = td->cd;
+	/* setup some default */
+	bg.pixmap.fra.mask = 0;
+	bg.pixmap.flags.is_stretched = 0;
+	bg.pixmap.flags.is_tiled = 0;
+	bg.flags.use_pixmap = 0;
+	bg.pixmap.g.x = 0;
+	bg.pixmap.g.y = 0;
+
+	if (DFS_BUTTON_RELIEF(df->style) == DFS_BUTTON_IS_FLAT)
+	{
+		border = 0;
+	}
+	else
+	{
+		border = HAS_MWM_BORDER(fw) ? 1 : 2;
+	}
+	dest_g.width = w_g->width;
+	dest_g.height = w_g->height;
+	dest_g.x = border;
+	dest_g.y = border;
+
+	switch (type)
+	{
+	case SimpleButton:
+		/* do nothing */
+		break;
+	case SolidButton:
+		/* overwrite with the default background */
+		dest_g.x = 0;
+		dest_g.y = 0;
+		border_fill_pixmap_background(dest_pix, &dest_g, solid_bg, cd);
+		break;
+	case VectorButton:
+	case DefaultVectorButton:
+		border_draw_vector_to_pixmap(
+			dest_pix, cd, is_toggled, &df->u.vector, w_g);
+		break;
+	case MiniIconButton:
+	case PixmapButton:
+	case ShrunkPixmapButton:
+	case StretchedPixmapButton:
+		if (w_g->width - 2*border <= 0 || w_g->height - 2*border <= 0)
+		{
+			break;
+		}
+		if (FMiniIconsSupported && type == MiniIconButton)
+		{
+			if (!fw->mini_icon)
+			{
+				break;
+			}
+			p = fw->mini_icon;
+			if (cd->cs >= 0)
+			{
+				bg.pixmap.fra.mask |= FRAM_HAVE_ICON_CSET;
+				bg.pixmap.fra.colorset = &Colorset[cd->cs];
+			}
+		}
+		else
+		{
+			p = df->u.p;
+		}
+		width = p->width;
+		height = p->height;
+		if ((type == ShrunkPixmapButton || type == MiniIconButton) &&
+		    (p->width > w_g->width - 2*border ||
+		     p->height > w_g->height - 2*border))
+		{
+			/* do so that the picture fit into the destination */
+			bg.pixmap.stretch_w = width =
+				min(w_g->width - 2*border, p->width);
+			bg.pixmap.stretch_h = height =
+				min(w_g->height - 2*border, p->height);
+			bg.pixmap.flags.is_stretched = 1;
+		}
+		else if (type == StretchedPixmapButton &&
+			 (p->width < w_g->width - 2*border ||
+			  p->height < w_g->height - 2*border))
+		{
+			/* do so that the picture fit into the destination */
+			bg.pixmap.stretch_w = width =
+				max(w_g->width - 2*border, p->width);
+			bg.pixmap.stretch_h = height =
+				max(w_g->height - 2*border, p->height);
+			bg.pixmap.flags.is_stretched = 1;
+		}
+		lr_just = DFS_H_JUSTIFICATION(df->style);
+		tb_just = DFS_V_JUSTIFICATION(df->style);
+		if (!td->td_is_rotated && fw->title_text_rotation != ROTATION_0)
+		{
+			if (fw->title_text_rotation == ROTATION_180)
+			{
+				switch (lr_just)
+				{
+				case JUST_LEFT:
+					lr_just = JUST_RIGHT;
+					break;
+				case JUST_RIGHT:
+					lr_just = JUST_LEFT;
+					break;
+				case JUST_CENTER:
+				default:
+					break;
+				}
+				switch (tb_just)
+				{
+				case JUST_TOP:
+					tb_just = JUST_BOTTOM;
+					break;
+				case JUST_BOTTOM:
+					tb_just = JUST_TOP;
+					break;
+				case JUST_CENTER:
+				default:
+					break;
+				}
+			}
+			else if (fw->title_text_rotation == ROTATION_90)
+			{
+				switch (lr_just)
+				{
+				case JUST_LEFT:
+					tb_just = JUST_TOP;
+					break;
+				case JUST_RIGHT:
+					tb_just = JUST_BOTTOM;
+					break;
+				case JUST_CENTER:
+				default:
+					tb_just = JUST_CENTER;
+					break;
+				}
+				switch (DFS_V_JUSTIFICATION(df->style))
+				{
+				case JUST_TOP:
+					lr_just = JUST_RIGHT;
+					break;
+				case JUST_BOTTOM:
+					lr_just = JUST_LEFT;
+					break;
+				case JUST_CENTER:
+				default:
+					lr_just = JUST_CENTER;
+					break;
+				}
+			}
+			else if (fw->title_text_rotation == ROTATION_270)
+			{
+				switch (lr_just)
+				{
+				case JUST_LEFT:
+					tb_just = JUST_BOTTOM;
+					break;
+				case JUST_RIGHT:
+					tb_just = JUST_TOP;
+					break;
+				case JUST_CENTER:
+				default:
+					tb_just = JUST_CENTER;
+					break;
+				}
+				switch (DFS_V_JUSTIFICATION(df->style))
+				{
+				case JUST_TOP:
+					lr_just = JUST_LEFT;
+					break;
+				case JUST_BOTTOM:
+					lr_just = JUST_RIGHT;
+					break;
+				case JUST_CENTER:
+				default:
+					lr_just = JUST_CENTER;
+					break;
+				}
+			}
+		}
+		switch (lr_just)
+		{
+		case JUST_LEFT:
+			dest_g.x = border;
+			break;
+		case JUST_RIGHT:
+			dest_g.x = (int)(w_g->width - width - border);
+			break;
+		case JUST_CENTER:
+		default:
+			/* round down */
+			dest_g.x = (int)(w_g->width - width) / 2;
+			break;
+		}
+		switch (tb_just)
+		{
+		case JUST_TOP:
+			dest_g.y = border;
+			break;
+		case JUST_BOTTOM:
+			dest_g.y = (int)(w_g->height - height - border);
+			break;
+		case JUST_CENTER:
+		default:
+			/* round down */
+			dest_g.y = (int)(w_g->height - height) / 2;
+			break;
+		}
+		if (dest_g.x < border)
+		{
+			dest_g.x = border;
+		}
+		if (dest_g.y < border)
+		{
+			dest_g.y = border;
+		}
+		bg.flags.use_pixmap = 1;
+		bg.pixmap.p = p->picture;
+		bg.pixmap.shape = p->mask;
+		bg.pixmap.alpha = p->alpha;
+		bg.pixmap.depth = p->depth;
+		bg.pixmap.g.width = p->width;
+		bg.pixmap.g.height = p->height;
+		border_fill_pixmap_background(dest_pix, &dest_g, &bg, cd);
+		break;
+	case TiledPixmapButton:
+	case AdjustedPixmapButton:
+		if (w_g->width - 2*border <= 0 || w_g->height - 2*border <= 0)
+		{
+			break;
+		}
+		p = df->u.p;
+		if (type == TiledPixmapButton)
+		{
+			bg.pixmap.flags.is_tiled = 1;
+		}
+		else
+		{
+			bg.pixmap.stretch_w = width = w_g->width - 2*dest_g.x;
+			bg.pixmap.stretch_h = height = w_g->height - 2*dest_g.y;
+			bg.pixmap.flags.is_stretched = 1;
+		}
+		bg.flags.use_pixmap = 1;
+		bg.pixmap.p = p->picture;
+		bg.pixmap.shape = p->mask;
+		bg.pixmap.alpha = p->alpha;
+		bg.pixmap.depth = p->depth;
+		bg.pixmap.g.width = p->width;
+		bg.pixmap.g.height = p->height;
+		border_fill_pixmap_background(dest_pix, &dest_g, &bg, cd);
+		break;
+	case MultiPixmap: /* for UseTitleStyle only */
+	{
+		int is_left = left1right0;
+		int part = TBMP_NONE;
+		int ap, cs;
+		unsigned int stretch;
+		Pixmap tmp = None;
+		FvwmPicture *full_pic = NULL;
+		rectangle g;
+		dynamic_common_decorations *dcd = &(cd->dynamic_cd);
+		FvwmPicture **pm;
+		FvwmAcs *acs;
+		Pixel *pixels;
+		unsigned short sf;
+
+		pm = df->u.mp.pixmaps;
+		acs = df->u.mp.acs;
+		pixels = df->u.mp.pixels;
+		sf = df->u.mp.solid_flags;
+		if (!border_mp_get_use_title_style_parts_and_geometry(
+			td, pm, acs, sf, is_left, &g, &part))
+		{
+			g.width = 0;
+			g.height = 0;
+			g.x = 0;
+			g.y = 0;
+		}
+
+		if (part == TBMP_NONE)
+		{
+			break;
+		}
+
+		if (sf & (1 << part))
+		{
+			bg.flags.use_pixmap = 0;
+			bg.pixel = pixels[part];
+			border_fill_pixmap_background(
+				dest_pix, &dest_g, &bg, cd);
+			break;
+		}
+		cs = acs[part].cs;
+		ap =  acs[part].alpha_percent;
+		if (CSET_IS_TRANSPARENT_PR(cs))
+		{
+			break;
+		}
+		if (cs >= 0)
+		{
+			bg.pixmap.fra.mask = FRAM_HAVE_ADDED_ALPHA;
+			bg.pixmap.fra.added_alpha_percent = ap;
+		}
+		stretch = !!(df->u.mp.stretch_flags & (1 << part));
+		bg.flags.use_pixmap = 1;
+		dest_g.x = 0;
+		dest_g.y = 0;
+
+		if (cs >= 0 && use_title_style && g.width > 0 && g.height > 0 &&
+		    !CSET_IS_TRANSPARENT_ROOT(cs) &&
+		    (bg.pixmap.p = border_get_bar_pixmaps(
+			    dcd, &g, bs, cs, NULL, part, stretch, NULL)) != None)
+		{
+			bg.pixmap.g.width = g.width;
+			bg.pixmap.g.height = g.height;
+			bg.pixmap.flags.is_tiled = 1;
+			bg.pixmap.g.x = w_g->x - g.x;
+			bg.pixmap.g.y = w_g->y - g.y;
+			bg.pixmap.shape = None;
+			bg.pixmap.alpha = None;
+			bg.pixmap.depth = Pdepth;
+		}
+		else if (CSET_IS_TRANSPARENT_ROOT(cs))
+		{
+			tmp = border_create_root_transparent_pixmap(
+				td, w, w_g->width, w_g->height, cs);
+			bg.pixmap.p = tmp;
+			bg.pixmap.g.width = w_g->width;
+			bg.pixmap.g.height = w_g->height;
+			bg.pixmap.shape = None;
+			bg.pixmap.alpha = None;
+			bg.pixmap.depth = Pdepth;
+		}
+		else if (cs >= 0)
+		{
+			int bg_w, bg_h;
+
+			tmp = CreateBackgroundPixmap(
+				dpy, w, w_g->width,
+				w_g->height, &Colorset[cs],
+				Pdepth, Scr.BordersGC, False);
+			bg.pixmap.p = tmp;
+			GetWindowBackgroundPixmapSize(
+				&Colorset[cs], w_g->width,
+				w_g->height, &bg_w, &bg_h);
+			bg.pixmap.g.width = bg_w;
+			bg.pixmap.g.height = bg_h;
+			bg.pixmap.shape = None;
+			bg.pixmap.alpha = None;
+			bg.pixmap.depth = Pdepth;
+			bg.pixmap.flags.is_tiled = 1;
+		}
+		else if (pm[part] && g.width > 0 && g.height > 0 &&
+			 border_get_bar_pixmaps(
+				 dcd, &g, bs, -1, pm[part], part, stretch,
+				 &full_pic) != None && full_pic)
+		{
+			bg.pixmap.p = full_pic->picture;
+			bg.pixmap.shape = full_pic->mask;
+			bg.pixmap.alpha = full_pic->alpha;
+			bg.pixmap.depth = full_pic->depth;
+			bg.pixmap.g.width = full_pic->width;
+			bg.pixmap.g.height = full_pic->height;
+			bg.pixmap.g.x = w_g->x - g.x;
+			bg.pixmap.g.y = w_g->y - g.y;
+		}
+		else if (pm[part])
+		{
+			p = pm[part];
+			if (df->u.mp.stretch_flags & (1 << part))
+			{
+				bg.pixmap.flags.is_stretched = 1;
+			}
+			else
+			{
+				bg.pixmap.flags.is_tiled = 1;
+			}
+			bg.pixmap.p = p->picture;
+			bg.pixmap.shape = p->mask;
+			bg.pixmap.alpha = p->alpha;
+			bg.pixmap.depth = p->depth;
+			bg.pixmap.g.width = p->width;
+			bg.pixmap.g.height = p->height;
+			bg.pixmap.stretch_w = dest_g.width - dest_g.x;
+			bg.pixmap.stretch_h = dest_g.height - dest_g.y;
+		}
+		else
+		{
+			/* should not happen */
+			return;
+		}
+		if (bg.pixmap.p != None)
+		{
+			border_fill_pixmap_background(
+				dest_pix, &dest_g, &bg, cd);
+		}
+		if (tmp != None)
+		{
+			XFreePixmap(dpy, tmp);
+		}
+		break;
+	}
+	case ColorsetButton:
+	{
+		colorset_t *cs_t = &Colorset[df->u.acs.cs];
+		int cs = df->u.acs.cs;
+		Pixmap tmp = None;
+		int bg_w, bg_h;
+
+		if (CSET_IS_TRANSPARENT_PR(cs))
+		{
+			break;
+		}
+		dest_g.x = 0;
+		dest_g.y = 0;
+		if (use_title_style &&
+		    !CSET_IS_TRANSPARENT_ROOT(cs) &&
+		    (bg.pixmap.p = border_get_bar_pixmaps(
+			    &(cd->dynamic_cd), &(td->bar_g), bs, cs, NULL,
+			    TBMP_NONE, 0, NULL))
+		    != None)
+		{
+			bg.pixmap.g.width = td->bar_g.width;
+			bg.pixmap.g.height = td->bar_g.height;
+			bg.pixmap.g.x = w_g->x - td->bar_g.x;
+			bg.pixmap.g.y = w_g->y - td->bar_g.y;
+		}
+		else if (CSET_IS_TRANSPARENT_ROOT(cs))
+		{
+			tmp = border_create_root_transparent_pixmap(
+				td, w, w_g->width, w_g->height, cs);
+			if (tmp == None)
+			{
+				break;
+			}
+			bg.pixmap.p = tmp;
+			bg.pixmap.g.width = w_g->width;
+			bg.pixmap.g.height = w_g->height;
+			bg.pixmap.shape = None;
+			bg.pixmap.alpha = None;
+			bg.pixmap.depth = Pdepth;
+		}
+		else
+		{
+			tmp = CreateBackgroundPixmap(
+				dpy, w, w_g->width, w_g->height,
+				cs_t, Pdepth, Scr.BordersGC, False);
+			if (tmp == None)
+			{
+				break;
+			}
+			bg.pixmap.p = tmp;
+			GetWindowBackgroundPixmapSize(
+				cs_t, w_g->width, w_g->height,
+				&bg_w, &bg_h);
+			bg.pixmap.g.width = bg_w;
+			bg.pixmap.g.height = bg_h;
+			bg.pixmap.g.x = 0;
+			bg.pixmap.g.y = 0;
+		}
+		bg.flags.use_pixmap = 1;
+		bg.pixmap.shape = None;
+		bg.pixmap.alpha = None;
+		bg.pixmap.depth = Pdepth;
+		bg.pixmap.flags.is_tiled = 1;
+		bg.pixmap.fra.mask = FRAM_HAVE_ADDED_ALPHA;
+		bg.pixmap.fra.added_alpha_percent = df->u.acs.alpha_percent;
+		border_fill_pixmap_background(dest_pix, &dest_g, &bg, cd);
+		if (tmp)
+		{
+			XFreePixmap(dpy, tmp);
+		}
+		break;
+	}
+	case GradientButton:
+		/* draw the gradient into the pixmap */
+		CreateGradientPixmap(
+			dpy, dest_pix, Scr.TransMaskGC,
+			df->u.grad.gradient_type, 0, 0, df->u.grad.npixels,
+			df->u.grad.xcs, df->u.grad.do_dither,
+			&df->u.grad.d_pixels, &df->u.grad.d_npixels,
+			dest_pix, 0, 0, w_g->width, w_g->height, NULL);
+
+		break;
+
+	default:
+		fvwm_msg(ERR, "DrawButton", "unknown button type: %i", type);
+		break;
+	}
+
+	return;
+}
+
+static void border_set_button_pixmap(
+	FvwmWindow *fw, titlebar_descr *td, int button, Pixmap *dest_pix,
+	Window w)
+{
+	pixmap_background_type bg;
+	unsigned int mask;
+	int is_left_button;
+	int do_reverse_relief;
+	ButtonState bs;
+	DecorFace *df;
+	rectangle *button_g;
+	GC rgc;
+	GC sgc;
+	Bool free_bg_pixmap = False;
+	rectangle pix_g;
+
+	/* prepare variables */
+	mask = (1 << button);
+	if (td->has_an_upsidedown_rotation)
+	{
+		is_left_button = (button & 1);
+	}
+	else
+	{
+		is_left_button = !(button & 1);
+	}
+	button_g = &td->layout.button_g[button];
+	bs = td->tbstate.bstate[button];
+	df = &TB_STATE(GetDecor(fw, buttons[button]))[bs];
+	rgc = td->cd->relief_gc;
+	sgc = td->cd->shadow_gc;
+	/* prepare background, either from the window colour or from the
+	 * border style */
+	if (!DFS_USE_BORDER_STYLE(df->style))
+	{
+		/* fill with the button background colour */
+		bg.flags.use_pixmap = 0;
+		bg.pixel = td->cd->back_color;
+		pix_g.x = 0;
+		pix_g.y = 0;
+		pix_g.width = button_g->width;
+		pix_g.height = button_g->height;
+		border_fill_pixmap_background(*dest_pix, &pix_g, &bg, td->cd);
+	}
+	else
+	{
+		/* draw pixmap background inherited from border style */
+		rectangle relative_g;
+
+		relative_g.width = td->frame_g.width;
+		relative_g.height = td->frame_g.height;
+		relative_g.x = button_g->x;
+		relative_g.y = button_g->y;
+		border_get_border_background(
+			&bg, td->cd, button_g, &relative_g, &free_bg_pixmap, w);
+		bg.pixmap.g.x = 0;
+		bg.pixmap.g.y = 0;
+		/* set the geometry for drawing the Tiled pixmap;
+		 * FIXME: maybe add the relief as offset? */
+		pix_g.x = 0;
+		pix_g.y = 0;
+		pix_g.width = button_g->width;
+		pix_g.height = button_g->height;
+		border_fill_pixmap_background(*dest_pix, &pix_g, &bg, td->cd);
+		if (free_bg_pixmap && bg.pixmap.p)
+		{
+			XFreePixmap(dpy, bg.pixmap.p);
+		}
+	}
+
+	/* handle title style */
+	if (DFS_USE_TITLE_STYLE(df->style))
+	{
+		/* draw background inherited from title style */
+		DecorFace *tsdf;
+		Pixmap tmp;
+
+		if (td->draw_rotation != ROTATION_0)
+		{
+			tmp = CreateRotatedPixmap(
+				dpy, *dest_pix,
+				td->layout.button_g[button].width,
+				td->layout.button_g[button].height,
+				Pdepth, Scr.BordersGC, td->restore_rotation);
+			XFreePixmap(dpy, *dest_pix);
+			*dest_pix = tmp;
+			border_rotate_titlebar_descr(fw, td);
+			button_g = &td->layout.button_g[button];
+			is_left_button = !(button & 1);
+		}
+		for (tsdf = &TB_STATE(GetDecor(fw, titlebar))[bs]; tsdf != NULL;
+		     tsdf = tsdf->next)
+		{
+			bg.pixel = tsdf->u.back;
+			border_draw_decor_to_pixmap(
+				fw, *dest_pix, w, &bg, button_g, tsdf, td,
+				bs, True, (td->tbstate.toggled_bmask & mask),
+				is_left_button);
+		}
+		if (td->draw_rotation != ROTATION_0)
+		{
+			tmp = CreateRotatedPixmap(
+				dpy, *dest_pix,
+				td->layout.button_g[button].width,
+				td->layout.button_g[button].height,
+				Pdepth, Scr.BordersGC, td->draw_rotation);
+			XFreePixmap(dpy, *dest_pix);
+			*dest_pix = tmp;
+			border_rotate_titlebar_descr(fw, td);
+			button_g = &td->layout.button_g[button];
+			if (td->has_an_upsidedown_rotation)
+			{
+				is_left_button = (button & 1);
+			}
+			else
+			{
+				is_left_button = !(button & 1);
+			}
+		}
+	}
+	/* handle button style */
+	for ( ; df; df = df->next)
+	{
+		/* draw background from button style */
+		bg.pixel = df->u.back;
+		border_draw_decor_to_pixmap(
+			fw, *dest_pix, w, &bg, button_g, df, td, bs, False,
+			(td->tbstate.toggled_bmask & mask), is_left_button);
+	}
+	/* draw the button relief */
+	do_reverse_relief = !!(td->tbstate.pressed_bmask & mask);
+	switch (DFS_BUTTON_RELIEF(
+			TB_STATE(GetDecor(fw, buttons[button]))[bs].style))
+	{
+	case DFS_BUTTON_IS_SUNK:
+		do_reverse_relief ^= 1;
+		/* fall through*/
+	case DFS_BUTTON_IS_UP:
+		do_relieve_rectangle(
+			dpy, *dest_pix, 0, 0, button_g->width - 1,
+			button_g->height - 1,
+			(do_reverse_relief) ? sgc : rgc,
+			(do_reverse_relief) ? rgc : sgc,
+			td->cd->relief_width, True);
+		break;
+	default:
+		/* flat */
+		break;
+	}
+
+	return;
+}
+
+static void border_draw_one_button(
+	FvwmWindow *fw, titlebar_descr *td, int button)
+{
+	Pixmap p;
+
+	/* make a pixmap */
+	if (td->layout.button_g[button].x < 0 ||
+	    td->layout.button_g[button].y < 0)
+	{
+		return;
+	}
+
+	p = border_create_decor_pixmap(td->cd, &(td->layout.button_g[button]));
+	/* set the background tile */
+	border_set_button_pixmap(fw, td, button, &p, FW_W_BUTTON(fw, button));
+	/* apply the pixmap and destroy it */
+	border_set_part_background(FW_W_BUTTON(fw, button), p);
+	XFreePixmap(dpy, p);
+	if ((td->tbstate.clear_bmask & (1 << button)) != 0)
+	{
+		XClearWindow(dpy, FW_W_BUTTON(fw, button));
+	}
+
+	return;
+}
+
+static void border_draw_title_stick_lines(
+	FvwmWindow *fw, titlebar_descr *td, title_draw_descr *tdd,
+	Pixmap dest_pix)
+{
+	int i;
+	int num;
+	int min;
+	int max;
+	int left_x;
+	int left_w;
+	int right_x;
+	int right_w;
+	int under_text_length = 0;
+	int under_text_offset = 0;
+	int right_length = 0;
+	int left_length = 0;
+	rotation_t rotation;
+
+	if (!( (HAS_STICKY_STIPPLED_TITLE(fw) &&
+		(IS_STICKY_ACROSS_PAGES(fw) || IS_STICKY_ACROSS_DESKS(fw)))
+	       || HAS_STIPPLED_TITLE(fw)))
+	{
+		return;
+	}
+	if (td->td_is_rotated)
+	{
+		rotation = td->restore_rotation;
+	}
+	else
+	{
+		rotation = ROTATION_0;
+	}
+	if (td->has_vt && td->under_text_g.height > 0)
+	{
+		under_text_length = td->under_text_g.height;
+		under_text_offset = td->under_text_g.y;
+		left_length = td->left_main_g.height - td->left_of_text_length
+			- td->left_end_length;
+		right_length = td->right_main_g.height -
+			td->right_of_text_length - td->right_end_length;
+
+	}
+	else if (!td->has_vt && td->under_text_g.width > 0)
+	{
+		under_text_length = td->under_text_g.width;
+		under_text_offset = td->under_text_g.x;
+		left_length = td->left_main_g.width - td->left_of_text_length
+			- td->left_end_length;
+		right_length = td->right_main_g.width -
+			td->right_of_text_length - td->right_end_length;
+	}
+
+	/* If the window is sticky either across pages or
+	 * desks and it has a stippled title, but nothing for
+	 * sticky_stippled_title, then don't bother drawing them, just
+	 * return immediately. -- Thomas Adam
+	 */
+	if ( (IS_STICKY_ACROSS_PAGES(fw) || IS_STICKY_ACROSS_DESKS(fw)) &&
+	    (!HAS_STICKY_STIPPLED_TITLE(fw) && HAS_STIPPLED_TITLE(fw)) )
+	{
+		return;
+	}
+
+	num = (int)(fw->title_thickness / WINDOW_TITLE_STICK_VERT_DIST / 2) *
+		2 - 1;
+	min = fw->title_thickness / 2 - num * 2 + 1;
+	max = fw->title_thickness / 2 + num * 2 -
+		WINDOW_TITLE_STICK_VERT_DIST + 1;
+	left_x = WINDOW_TITLE_STICK_OFFSET + td->left_end_length;
+	left_w = ((under_text_length == 0)? td->offset:under_text_offset)
+		- left_x - WINDOW_TITLE_TO_STICK_GAP - td->left_of_text_length;
+	right_x = ((under_text_length == 0)?
+		   td->offset + td->length :
+		   under_text_offset + under_text_length)
+		+ td->right_of_text_length + WINDOW_TITLE_TO_STICK_GAP - 1;
+	right_w = fw->title_length - right_x - WINDOW_TITLE_STICK_OFFSET
+		- td->right_end_length;
+	/* an odd number of lines every WINDOW_TITLE_STICK_VERT_DIST pixels */
+	if (left_w < WINDOW_TITLE_STICK_MIN_WIDTH)
+	{
+		left_x = td->left_end_length +
+			((left_length > WINDOW_TITLE_STICK_MIN_WIDTH)?
+			 (left_length - WINDOW_TITLE_STICK_MIN_WIDTH)/2 : 0);
+		left_w = WINDOW_TITLE_STICK_MIN_WIDTH;
+	}
+	if (right_w < WINDOW_TITLE_STICK_MIN_WIDTH)
+	{
+		right_w = WINDOW_TITLE_STICK_MIN_WIDTH;
+		right_x = fw->title_length - WINDOW_TITLE_STICK_MIN_WIDTH - 1
+			- td->right_end_length -
+			((right_length > WINDOW_TITLE_STICK_MIN_WIDTH)?
+			 (right_length -
+			  WINDOW_TITLE_STICK_MIN_WIDTH)/2 : 0);
+	}
+	for (i = min; i <= max; i += WINDOW_TITLE_STICK_VERT_DIST)
+	{
+		if (left_w > 0)
+		{
+			do_relieve_rectangle_with_rotation(
+				dpy, dest_pix,
+				SWAP_ARGS(td->has_vt, left_x, i),
+				SWAP_ARGS(td->has_vt, left_w, 1),
+				tdd->sgc, tdd->rgc, 1, False, rotation);
+		}
+		if (right_w > 0)
+		{
+			do_relieve_rectangle_with_rotation(
+				dpy, dest_pix,
+				SWAP_ARGS(td->has_vt, right_x, i),
+				SWAP_ARGS(td->has_vt, right_w, 1),
+				tdd->sgc, tdd->rgc, 1, False, rotation);
+		}
+	}
+
+	return;
+}
+
+static void border_draw_title_mono(
+	FvwmWindow *fw, titlebar_descr *td, title_draw_descr *tdd,
+	FlocaleWinString *fstr, Pixmap dest_pix)
+{
+	int has_vt;
+
+	has_vt = HAS_VERTICAL_TITLE(fw);
+	XFillRectangle(
+		dpy, dest_pix, td->cd->relief_gc,
+		td->offset - 2, 0, td->length+4, fw->title_thickness);
+	if (fw->visible_name != (char *)NULL)
+	{
+		FlocaleDrawString(dpy, fw->title_font, fstr, 0);
+	}
+	/* for mono, we clear an area in the title bar where the window
+	 * title goes, so that its more legible. For color, no need */
+	do_relieve_rectangle(
+		dpy, dest_pix, 0, 0,
+		SWAP_ARGS(has_vt, td->offset - 3,
+			  fw->title_thickness - 1),
+		tdd->rgc, tdd->sgc, td->cd->relief_width, False);
+	do_relieve_rectangle(
+		dpy, dest_pix,
+		SWAP_ARGS(has_vt, td->offset + td->length + 2, 0),
+		SWAP_ARGS(has_vt, fw->title_length - td->length -
+			  td->offset - 3, fw->title_thickness - 1),
+		tdd->rgc, tdd->sgc, td->cd->relief_width, False);
+	XDrawLine(
+		dpy, dest_pix, tdd->sgc,
+		SWAP_ARGS(has_vt, 0, td->offset + td->length + 1),
+		SWAP_ARGS(has_vt, td->offset + td->length + 1,
+			  fw->title_thickness));
+
+	return;
+}
+
+static void border_draw_title_relief(
+	FvwmWindow *fw, titlebar_descr *td, title_draw_descr *tdd,
+	Pixmap dest_pix)
+{
+	int reverse = 0;
+	rotation_t rotation;
+
+	if (td->td_is_rotated)
+	{
+		rotation = td->restore_rotation;
+	}
+	else
+	{
+		rotation = ROTATION_0;
+	}
+	/* draw title relief */
+	switch (DFS_BUTTON_RELIEF(*tdd->tstyle))
+	{
+	case DFS_BUTTON_IS_SUNK:
+		reverse = 1;
+	case DFS_BUTTON_IS_UP:
+		do_relieve_rectangle_with_rotation(
+			dpy, dest_pix, 0, 0,
+			SWAP_ARGS(
+				td->has_vt, fw->title_length - 1,
+				fw->title_thickness - 1),
+			(reverse) ? tdd->sgc : tdd->rgc,
+			(reverse) ? tdd->rgc : tdd->sgc, td->cd->relief_width,
+			True, rotation);
+		break;
+	default:
+		/* flat */
+		break;
+	}
+
+	return;
+}
+
+static void border_draw_title_deep(
+	FvwmWindow *fw, titlebar_descr *td, title_draw_descr *tdd,
+	FlocaleWinString *fstr, Pixmap dest_pix, Window w)
+{
+	DecorFace *df;
+	pixmap_background_type bg;
+
+	bg.flags.use_pixmap = 0;
+	for (df = tdd->df; df != NULL; df = df->next)
+	{
+		if (df->style.face_type == MultiPixmap)
+		{
+			border_mp_draw_mp_titlebar(
+				fw, td, df, dest_pix, w);
+		}
+		else
+		{
+			bg.pixel = df->u.back;
+			border_draw_decor_to_pixmap(
+				fw, dest_pix, w, &bg, &td->layout.title_g, df,
+				td, td->tbstate.tstate, True, tdd->is_toggled,
+				1);
+		}
+	}
+	FlocaleDrawString(dpy, fw->title_font, &tdd->fstr, 0);
+
+	return;
+}
+
+static void border_get_titlebar_draw_descr(
+	FvwmWindow *fw, titlebar_descr *td, title_draw_descr *tdd,
+	Pixmap dest_pix)
+{
+	rectangle *title_g;
+
+	memset(tdd, 0, sizeof(*tdd));
+	/* prepare the gcs and variables */
+	if (td->tbstate.is_title_pressed)
+	{
+		tdd->rgc = td->cd->shadow_gc;
+		tdd->sgc = td->cd->relief_gc;
+	}
+	else
+	{
+		tdd->rgc = td->cd->relief_gc;
+		tdd->sgc = td->cd->shadow_gc;
+	}
+	NewFontAndColor(fw->title_font, td->cd->fore_color, td->cd->back_color);
+	title_g = &td->layout.title_g;
+	tdd->tstyle = &TB_STATE(
+		GetDecor(fw, titlebar))[td->tbstate.tstate].style;
+	tdd->df = &TB_STATE(GetDecor(fw, titlebar))[td->tbstate.tstate];
+
+	/* fetch the title string */
+	tdd->fstr.str = fw->visible_name;
+	tdd->fstr.win = dest_pix;
+	if (td->td_is_rotated)
+	{
+		tdd->fstr.flags.text_rotation = ROTATION_0;
+	}
+	else
+	{
+		tdd->fstr.flags.text_rotation = fw->title_text_rotation;
+	}
+	if (td->has_vt)
+	{
+		tdd->fstr.y = td->offset;
+		tdd->fstr.x = fw->title_text_offset + 1;
+	}
+	else
+	{
+		tdd->fstr.x = td->offset;
+		tdd->fstr.y = fw->title_text_offset + 1;
+	}
+	if (td->cd->cs >= 0)
+	{
+		tdd->fstr.colorset = &Colorset[td->cd->cs];
+		tdd->fstr.flags.has_colorset = 1;
+	}
+	tdd->fstr.gc = Scr.TitleGC;
+
+	return;
+}
+
+static void border_set_title_pixmap(
+	FvwmWindow *fw, titlebar_descr *td, Pixmap *dest_pix, Window w)
+{
+	pixmap_background_type bg;
+	title_draw_descr tdd;
+	FlocaleWinString fstr;
+	Bool free_bg_pixmap = False;
+	rectangle pix_g;
+
+	border_get_titlebar_draw_descr(fw, td, &tdd, *dest_pix);
+	/* prepare background, either from the window colour or from the
+	 * border style */
+	if (!DFS_USE_BORDER_STYLE(*tdd.tstyle))
+	{
+		/* fill with the button background colour */
+		bg.flags.use_pixmap = 0;
+		bg.pixel = td->cd->back_color;
+		pix_g.x = 0;
+		pix_g.y = 0;
+		pix_g.width = td->layout.title_g.width;
+		pix_g.height = td->layout.title_g.height;
+		border_fill_pixmap_background(
+			*dest_pix, &pix_g, &bg, td->cd);
+	}
+	else
+	{
+		/* draw pixmap background inherited from border style */
+		rectangle relative_g;
+		Pixmap tmp;
+
+		if (td->draw_rotation != ROTATION_0)
+		{
+			tmp = CreateRotatedPixmap(
+				dpy, *dest_pix,
+				td->layout.title_g.width,
+				td->layout.title_g.height,
+				Pdepth, Scr.BordersGC, td->restore_rotation);
+			XFreePixmap(dpy, *dest_pix);
+			*dest_pix = tmp;
+			border_rotate_titlebar_descr(fw, td);
+		}
+		relative_g.width = td->frame_g.width;
+		relative_g.height = td->frame_g.height;
+		relative_g.x = td->layout.title_g.x;
+		relative_g.y = td->layout.title_g.y;
+		border_get_border_background(
+			&bg, td->cd, &td->layout.title_g, &relative_g,
+			&free_bg_pixmap, w);
+		bg.pixmap.g.x = 0;
+		bg.pixmap.g.y = 0;
+		/* set the geometry for drawing the Tiled pixmap;
+		 * FIXME: maybe add the relief as offset? */
+		pix_g.x = 0;
+		pix_g.y = 0;
+		pix_g.width = td->layout.title_g.width;
+		pix_g.height = td->layout.title_g.height;
+		border_fill_pixmap_background(
+			*dest_pix, &pix_g, &bg, td->cd);
+		if (free_bg_pixmap && bg.pixmap.p)
+		{
+			XFreePixmap(dpy, bg.pixmap.p);
+		}
+		if (td->draw_rotation != ROTATION_0)
+		{
+			tmp = CreateRotatedPixmap(
+				dpy, *dest_pix,
+				td->layout.title_g.width,
+				td->layout.title_g.height,
+				Pdepth, Scr.BordersGC, td->draw_rotation);
+			XFreePixmap(dpy, *dest_pix);
+			*dest_pix = tmp;
+			border_rotate_titlebar_descr(fw, td);
+		}
+	}
+
+	if (Pdepth < 2)
+	{
+		border_draw_title_mono(fw, td, &tdd, &fstr, *dest_pix);
+	}
+	else
+	{
+		border_draw_title_deep(fw, td, &tdd, &fstr, *dest_pix, w);
+	}
+	border_draw_title_relief(fw, td, &tdd, *dest_pix);
+	border_draw_title_stick_lines(fw, td, &tdd, *dest_pix);
+
+	return;
+}
+
+static void border_draw_title(
+	FvwmWindow *fw, titlebar_descr *td)
+{
+	Pixmap p;
+
+	if (td->layout.title_g.x < 0 || td->layout.title_g.y < 0)
+	{
+		return;
+	}
+	if (td->draw_rotation != ROTATION_0)
+	{
+		border_rotate_titlebar_descr(fw, td);
+	}
+	/* make a pixmap */
+	p = border_create_decor_pixmap(td->cd, &(td->layout.title_g));
+	/* set the background tile */
+#if 0
+	fprintf(stderr,"drawing title\n");
+#endif
+	border_set_title_pixmap(fw, td, &p, FW_W_TITLE(fw));
+	if (td->draw_rotation != ROTATION_0)
+	{
+		Pixmap tmp;
+
+		tmp = CreateRotatedPixmap(
+			dpy, p, td->layout.title_g.width,
+			td->layout.title_g.height, Pdepth, Scr.BordersGC,
+			td->draw_rotation);
+		XFreePixmap(dpy, p);
+		p = tmp;
+		border_rotate_titlebar_descr(fw, td);
+	}
+	/* apply the pixmap and destroy it */
+	border_set_part_background(FW_W_TITLE(fw), p);
+	XFreePixmap(dpy, p);
+	if (td->tbstate.do_clear_title)
+	{
+		XClearWindow(dpy, FW_W_TITLE(fw));
+	}
+
+	return;
+}
+
+static void border_draw_buttons(
+	FvwmWindow *fw, titlebar_descr *td)
+{
+	int i;
+
+	/* draw everything in a big loop */
+#if 0
+	fprintf(stderr, "drawing buttons 0x%04x\n", td->tbstate.draw_bmask);
+#endif
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		unsigned int mask = (1 << i);
+
+		if ((td->tbstate.draw_bmask & mask) != 0)
+		{
+			border_draw_one_button(fw, td, i);
+		}
+	}
+	/* update the button states */
+	fw->decor_state.buttons_drawn |= td->tbstate.draw_bmask;
+	fw->decor_state.buttons_inverted = td->tbstate.pressed_bmask;
+	fw->decor_state.buttons_lit = td->tbstate.lit_bmask;
+	fw->decor_state.buttons_toggled = td->tbstate.toggled_bmask;
+
+	return;
+}
+
+static void border_setup_use_title_style(
+	FvwmWindow *fw, titlebar_descr *td)
+{
+	int i;
+	DecorFace *df, *tsdf;
+	ButtonState bs, tsbs;
+
+	/* use a full bar pixmap (for Colorset) or non window size pixmaps
+	 * (for MultiPixmap) under certain condition:
+	 * - for the buttons which use title style
+	 * - for title which have a button with UseTitle style
+	 */
+	tsbs = td->tbstate.tstate;
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		bs = td->tbstate.bstate[i];
+		df = &TB_STATE(GetDecor(fw, buttons[i]))[bs];
+		tsdf = &TB_STATE(GetDecor(fw, buttons[i]))[tsbs];
+		if (FW_W_BUTTON(fw, i) != None)
+		{
+			if (DFS_USE_TITLE_STYLE(df->style))
+			{
+				border_setup_bar_pixmaps(
+					td, &(td->cd->dynamic_cd),
+					&TB_STATE(GetDecor(fw, titlebar))[bs],
+					bs);
+			}
+			if (DFS_USE_TITLE_STYLE(tsdf->style))
+			{
+				border_setup_bar_pixmaps(
+					td, &(td->cd->dynamic_cd),
+					&TB_STATE(GetDecor(fw, titlebar))[tsbs],
+					tsbs);
+			}
+		}
+	}
+	return;
+}
+
+static void border_rotate_titlebar_descr(
+	FvwmWindow *fw, titlebar_descr *td)
+{
+	rotation_t rotation;
+	int i, tmpi;
+	static titlebar_descr saved_td;
+
+	if (td->draw_rotation == ROTATION_0)
+	{
+		return;
+	}
+	if (!td->has_been_saved)
+	{
+		td->has_been_saved = True;
+		memcpy(&saved_td, td, sizeof(titlebar_descr));
+	}
+	if (!td->td_is_rotated)
+	{
+		/* make the bar horizontal */
+		switch(td->draw_rotation)
+		{
+		case ROTATION_90: /* cw */
+			rotation = ROTATION_270;
+			break;
+		case ROTATION_270: /* ccw */
+			rotation = ROTATION_90;
+			break;
+		case ROTATION_180:
+			rotation = ROTATION_180;
+			break;
+		default:
+			return;
+		}
+		td->has_vt = 0;
+		td->has_an_upsidedown_rotation = 0;
+		td->td_is_rotated = 1;
+	}
+	else
+	{
+		/* restore */
+		memcpy(td, &saved_td, sizeof(titlebar_descr));
+		td->td_is_rotated = 0;
+		return;
+	}
+
+#define ROTATE_RECTANGLE(rot, r, vs_frame, vs_titlebar, vs_title) \
+	{ \
+		rectangle tr; \
+		tr.x = r->x; \
+		tr.y = r->y; \
+		tr.width = r->width; \
+		tr.height = r->height; \
+		switch(rot) \
+		{ \
+		case ROTATION_270: /* ccw */ \
+			tr.x = r->y; \
+			if (vs_frame) \
+			{ \
+				tr.y = td->frame_g.width - (r->x+r->width); \
+			} \
+			else if (vs_titlebar) \
+			{ \
+				tr.y = td->bar_g.width - \
+					(r->x+r->width); \
+			} \
+			else if (vs_title) \
+			{ \
+				tr.y = td->layout.title_g.width - \
+					(r->x+r->width); \
+			} \
+			else \
+			{ \
+				tr.y = r->x; \
+			} \
+			tr.width = r->height; \
+			tr.height = r->width; \
+			break; \
+		case ROTATION_90: /* cw */ \
+			if (vs_frame) \
+			{ \
+				tr.x = td->frame_g.height - (r->y+r->height); \
+			} \
+			else if (vs_titlebar) \
+			{ \
+				tr.x = td->bar_g.height - \
+					(r->y+r->height); \
+			} \
+			else if (vs_title) \
+			{ \
+				tr.x = td->layout.title_g.height - \
+					(r->y+r->height); \
+			} \
+			else \
+			{ \
+				tr.x = r->y; \
+			} \
+			tr.y = r->x; \
+			tr.width = r->height; \
+			tr.height = r->width; \
+			break; \
+		case ROTATION_180: \
+			if (vs_frame) \
+			{ \
+				tr.x = td->frame_g.width - (r->x+r->width); \
+			} \
+			else if (vs_titlebar) \
+			{ \
+				tr.x = td->bar_g.width - \
+					(r->x + r->width); \
+			} \
+			else if (vs_title) \
+			{ \
+				tr.x = td->layout.title_g.width - \
+					(r->x + r->width); \
+			} \
+			else \
+			{ \
+				tr.x = r->x; \
+			} \
+			break; \
+		case ROTATION_0: \
+			break; \
+		} \
+		r->x = tr.x; \
+		r->y = tr.y; \
+		r->width = tr.width; \
+		r->height = tr.height; \
+	}
+
+	switch(rotation)
+	{
+	case ROTATION_90:
+		td->offset =
+			td->layout.title_g.height - td->offset - td->length;
+		tmpi = td->left_end_length;
+		td->left_end_length = td->right_end_length;
+		td->right_end_length = tmpi;
+		tmpi = td->left_of_text_length;
+		td->left_of_text_length = td->right_of_text_length;
+		td->right_of_text_length = tmpi;
+		break;
+	case ROTATION_270:
+		break;
+	case ROTATION_180:
+		td->offset = td->layout.title_g.width - td->offset - td->length;
+		tmpi = td->left_end_length;
+		td->left_end_length = td->right_end_length;
+		td->right_end_length = tmpi;
+		tmpi = td->left_of_text_length;
+		td->left_of_text_length = td->right_of_text_length;
+		td->right_of_text_length = tmpi;
+		break;
+	case ROTATION_0:
+		break;
+	}
+
+	ROTATE_RECTANGLE(rotation, (&td->left_buttons_g), True, False, False)
+	ROTATE_RECTANGLE(rotation, (&td->right_buttons_g), True, False, False)
+	for (i=0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		ROTATE_RECTANGLE(
+			rotation, (&td->layout.button_g[i]), True, False, False)
+	}
+	ROTATE_RECTANGLE(rotation, (&td->under_text_g), False, False, True)
+	ROTATE_RECTANGLE(rotation, (&td->left_main_g), False, False, True)
+	ROTATE_RECTANGLE(rotation, (&td->right_main_g), False, False, True)
+	ROTATE_RECTANGLE(rotation, (&td->full_left_main_g), True, False, False)
+	ROTATE_RECTANGLE(rotation, (&td->full_right_main_g), True, False, False)
+	ROTATE_RECTANGLE(rotation, (&td->layout.title_g), True, False, False)
+	ROTATE_RECTANGLE(rotation, (&td->bar_g), True, False, False)
+	ROTATE_RECTANGLE(rotation, (&td->frame_g), False, False, False);
+
+#undef ROTATE_RECTANGLE
+}
+
+static void border_get_titlebar_descr_state(
+	FvwmWindow *fw, window_parts pressed_parts, int pressed_button,
+	clear_window_parts clear_parts, Bool do_hilight,
+	border_titlebar_state *tbstate)
+{
+	int i;
+
+	if ((pressed_parts & PART_BUTTONS) != PART_NONE && pressed_button >= 0)
+	{
+		tbstate->pressed_bmask = (1 << pressed_button);
+	}
+	else
+	{
+		tbstate->pressed_bmask = 0;
+	}
+	if ((clear_parts & CLEAR_BUTTONS) != CLEAR_NONE)
+	{
+		tbstate->clear_bmask = ~0;
+	}
+	else
+	{
+		tbstate->clear_bmask = 0;
+	}
+	tbstate->lit_bmask = (do_hilight == True) ? ~0 : 0;
+	if ((pressed_parts & PART_TITLE) != PART_NONE)
+	{
+		tbstate->is_title_pressed = 1;
+	}
+	else
+	{
+		tbstate->is_title_pressed = 0;
+	}
+	if ((clear_parts & CLEAR_TITLE) != CLEAR_NONE)
+	{
+		tbstate->do_clear_title = 1;
+	}
+	else
+	{
+		tbstate->do_clear_title = 0;
+	}
+	tbstate->is_title_lit = (do_hilight == True) ? 1 : 0;
+	tbstate->toggled_bmask = 0;
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		unsigned int mask = (1 << i);
+
+		if (is_button_toggled(fw, i))
+		{
+			tbstate->toggled_bmask |= mask;
+		}
+		tbstate->bstate[i] = border_flags_to_button_state(
+			tbstate->pressed_bmask & mask,
+			tbstate->lit_bmask & mask,
+			tbstate->toggled_bmask & mask);
+	}
+	tbstate->tstate = border_flags_to_button_state(
+		tbstate->is_title_pressed, tbstate->is_title_lit, 0);
+}
+
+static window_parts border_get_titlebar_descr(
+	common_decorations_type *cd, FvwmWindow *fw,
+	window_parts pressed_parts, int pressed_button,
+	window_parts force_draw_parts, clear_window_parts clear_parts,
+	rectangle *old_g, rectangle *new_g, Bool do_hilight,
+	titlebar_descr *ret_td)
+{
+	window_parts draw_parts;
+	int i;
+	DecorFace *df;
+	int is_start = 0;
+	JustificationType just;
+	int lbl = 0;
+	int rbl = 0;
+
+	ret_td->cd = cd;
+	ret_td->frame_g = *new_g;
+	if (old_g == NULL)
+	{
+		old_g = &fw->g.frame;
+	}
+	frame_get_titlebar_dimensions(fw, old_g, NULL, &ret_td->old_layout);
+	frame_get_titlebar_dimensions(fw, new_g, NULL, &ret_td->layout);
+
+	ret_td->has_vt = HAS_VERTICAL_TITLE(fw);
+	if (USE_TITLE_DECOR_ROTATION(fw))
+	{
+		ret_td->draw_rotation = fw->title_text_rotation;
+		switch(ret_td->draw_rotation)
+		{
+		case ROTATION_90:
+			ret_td->restore_rotation = ROTATION_270;
+			break;
+		case ROTATION_270: /* ccw */
+			ret_td->restore_rotation = ROTATION_90;
+			break;
+		case ROTATION_180:
+			ret_td->restore_rotation = ROTATION_180;
+			break;
+		default:
+			break;
+		}
+	}
+	if (fw->title_text_rotation == ROTATION_270 ||
+	    fw->title_text_rotation == ROTATION_180)
+	{
+		ret_td->has_an_upsidedown_rotation = True;
+	}
+	/* geometry of the title bar title + buttons */
+	if (!ret_td->has_vt)
+	{
+		ret_td->bar_g.width = new_g->width - 2 * fw->boundary_width;
+		ret_td->bar_g.height = ret_td->layout.title_g.height;
+		ret_td->bar_g.x = fw->boundary_width;
+		ret_td->bar_g.y = ret_td->layout.title_g.y;
+	}
+	else
+	{
+		ret_td->bar_g.width = ret_td->layout.title_g.width;
+		ret_td->bar_g.height = new_g->height - 2 * fw->boundary_width;
+		ret_td->bar_g.y = fw->boundary_width;
+		ret_td->bar_g.x = ret_td->layout.title_g.x;
+	}
+
+	/* buttons geometries */
+	if (ret_td->has_vt)
+	{
+		ret_td->left_buttons_g.width = ret_td->bar_g.width;
+		ret_td->right_buttons_g.width = ret_td->bar_g.width;
+	}
+	else
+	{
+		ret_td->left_buttons_g.height = ret_td->bar_g.height;
+		ret_td->right_buttons_g.height = ret_td->bar_g.width;
+	}
+
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		if (FW_W_BUTTON(fw, i) == None)
+		{
+			continue;
+		}
+		if (ret_td->has_vt)
+		{
+			if (i & 1)
+			{
+				rbl += ret_td->layout.button_g[i].height;
+			}
+			else
+			{
+				lbl += ret_td->layout.button_g[i].height;
+			}
+		}
+		else
+		{
+			if (i & 1)
+			{
+				rbl += ret_td->layout.button_g[i].width;
+			}
+			else
+			{
+				lbl += ret_td->layout.button_g[i].width;
+			}
+		}
+	}
+
+	if (ret_td->has_an_upsidedown_rotation)
+	{
+		if (ret_td->has_vt)
+		{
+			ret_td->left_buttons_g.height = rbl;
+			ret_td->right_buttons_g.height = lbl;
+			ret_td->right_buttons_g.y = fw->boundary_width;
+			ret_td->right_buttons_g.x = ret_td->bar_g.x;
+			ret_td->left_buttons_g.y = ret_td->layout.title_g.y +
+				ret_td->layout.title_g.height;
+			ret_td->left_buttons_g.x = ret_td->bar_g.x;
+		}
+		else
+		{
+			ret_td->left_buttons_g.width = rbl;
+			ret_td->right_buttons_g.width = lbl;
+			ret_td->right_buttons_g.x = fw->boundary_width;
+			ret_td->right_buttons_g.y = ret_td->bar_g.y;
+			ret_td->left_buttons_g.x = ret_td->layout.title_g.x +
+				ret_td->layout.title_g.width;
+			ret_td->left_buttons_g.y = ret_td->bar_g.y;
+		}
+	}
+	else
+	{
+		if (ret_td->has_vt)
+		{
+			ret_td->left_buttons_g.height = lbl;
+			ret_td->right_buttons_g.height = rbl;
+			ret_td->left_buttons_g.y = fw->boundary_width;
+			ret_td->left_buttons_g.x = ret_td->bar_g.x;
+			ret_td->right_buttons_g.y = ret_td->layout.title_g.y +
+				ret_td->layout.title_g.height;
+			ret_td->right_buttons_g.x = ret_td->bar_g.x;
+		}
+		else
+		{
+			ret_td->left_buttons_g.width = lbl;
+			ret_td->right_buttons_g.width = rbl;
+			ret_td->left_buttons_g.x = fw->boundary_width;
+			ret_td->left_buttons_g.y = ret_td->bar_g.y;
+			ret_td->right_buttons_g.x = ret_td->layout.title_g.x +
+				ret_td->layout.title_g.width;
+			ret_td->right_buttons_g.y = ret_td->bar_g.y;
+		}
+	}
+
+	/* initialise flags */
+	border_get_titlebar_descr_state(
+		fw, pressed_parts, pressed_button, clear_parts, do_hilight,
+		&(ret_td->tbstate));
+
+	/* get the title string length and position
+	 * This is not in "tdd" (titlebar_draw_descr), because these are needed
+	 * to draw the buttons with UseTitleStyle */
+	just = TB_JUSTIFICATION(GetDecor(fw, titlebar));
+	if (fw->visible_name != (char *)NULL)
+	{
+		ret_td->length = FlocaleTextWidth(
+			fw->title_font, fw->visible_name,
+			(ret_td->has_vt) ? -strlen(fw->visible_name) :
+			strlen(fw->visible_name));
+		if (ret_td->length > fw->title_length -
+		    2*MIN_WINDOW_TITLE_TEXT_OFFSET)
+		{
+			ret_td->length = fw->title_length -
+				2*MIN_WINDOW_TITLE_TEXT_OFFSET;
+			just = JUST_CENTER;
+		}
+		if (ret_td->length < 0)
+		{
+			ret_td->length = 0;
+		}
+	}
+	else
+	{
+		ret_td->length = 0;
+	}
+	if (ret_td->length == 0)
+	{
+		just = JUST_CENTER;
+	}
+	df = &TB_STATE(GetDecor(fw, titlebar))[ret_td->tbstate.tstate];
+	switch (just)
+	{
+	case JUST_LEFT:
+		is_start = 1;
+		/* fall through */
+	case JUST_RIGHT:
+		if (ret_td->has_an_upsidedown_rotation)
+		{
+			is_start = !is_start;
+		}
+		if (is_start)
+		{
+			if (WINDOW_TITLE_TEXT_OFFSET + ret_td->length <=
+			    fw->title_length)
+			{
+				ret_td->offset = WINDOW_TITLE_TEXT_OFFSET;
+			}
+			else
+			{
+				ret_td->offset =
+					fw->title_length - ret_td->length;
+			}
+		}
+		else
+		{
+			ret_td->offset = fw->title_length - ret_td->length -
+				WINDOW_TITLE_TEXT_OFFSET;
+		}
+		break;
+	case JUST_CENTER:
+	default:
+		ret_td->offset = (fw->title_length - ret_td->length) / 2;
+		break;
+	}
+
+	if (ret_td->offset < MIN_WINDOW_TITLE_TEXT_OFFSET)
+	{
+		ret_td->offset = MIN_WINDOW_TITLE_TEXT_OFFSET;
+	}
+
+	/* setup MultiPixmap */
+	border_mp_get_titlebar_descr(fw, ret_td, df);
+
+	/* determine the parts to draw */
+	draw_parts = border_get_tb_parts_to_draw(
+		fw, ret_td, old_g, new_g, force_draw_parts);
+
+	return draw_parts;
+}
+
+
+static void border_draw_titlebar(
+	common_decorations_type *cd, FvwmWindow *fw,
+	window_parts pressed_parts, int pressed_button,
+	window_parts force_draw_parts, clear_window_parts clear_parts,
+	rectangle *old_g, rectangle *new_g, Bool do_hilight)
+{
+	window_parts draw_parts;
+	titlebar_descr td;
+
+	if (!HAS_TITLE(fw))
+	{
+		/* just reset border states */
+		fw->decor_state.parts_drawn &= ~(PART_TITLE);
+		fw->decor_state.parts_lit &= ~(PART_TITLE);
+		fw->decor_state.parts_inverted &= ~(PART_TITLE);
+		fw->decor_state.buttons_drawn = 0;
+		fw->decor_state.buttons_lit = 0;
+		fw->decor_state.buttons_inverted = 0;
+		fw->decor_state.buttons_toggled = 0;
+		return;
+	}
+	memset(&td, 0, sizeof(td));
+	draw_parts = border_get_titlebar_descr(
+		cd, fw, pressed_parts, pressed_button, force_draw_parts,
+		clear_parts, old_g, new_g, do_hilight, &td);
+	if ((draw_parts & PART_TITLE) != PART_NONE ||
+	    (draw_parts & PART_BUTTONS) != PART_NONE)
+	{
+		/* set up UseTitleStyle Colorset */
+		border_setup_use_title_style(fw, &td);
+	}
+	if ((draw_parts & PART_TITLE) != PART_NONE)
+	{
+		border_draw_title(fw, &td);
+	}
+	if ((draw_parts & PART_BUTTONS) != PART_NONE)
+	{
+		border_draw_buttons(fw, &td);
+	}
+	border_free_bar_pixmaps(&(td.cd->dynamic_cd));
+
+	/* update the decor states */
+	fw->decor_state.parts_drawn |= draw_parts;
+	if (do_hilight)
+	{
+		fw->decor_state.parts_lit |= draw_parts;
+	}
+	else
+	{
+		fw->decor_state.parts_lit &= ~draw_parts;
+	}
+	fw->decor_state.parts_inverted &= ~draw_parts;
+	fw->decor_state.parts_inverted |= (draw_parts & pressed_parts);
+	if (draw_parts & PART_BUTTONS)
+	{
+		fw->decor_state.buttons_drawn |= td.tbstate.draw_bmask;
+		fw->decor_state.parts_lit = (do_hilight) ? ~0 : 0;
+		if (td.tbstate.pressed_bmask)
+		{
+			fw->decor_state.buttons_inverted =
+				td.tbstate.pressed_bmask;
+		}
+		else
+		{
+			fw->decor_state.buttons_inverted &=
+				~td.tbstate.draw_bmask;
+		}
+		fw->decor_state.buttons_toggled =
+			(fw->decor_state.buttons_toggled &
+			 ~td.tbstate.max_bmask) | td.tbstate.toggled_bmask;
+	}
+
+	return;
+}
+
+/*
+ *
+ * Redraws the windows borders
+ *
+ */
+static void border_draw_border_parts(
+	common_decorations_type *cd, FvwmWindow *fw,
+	window_parts pressed_parts, window_parts force_draw_parts,
+	clear_window_parts clear_parts, rectangle *old_g, rectangle *new_g,
+	Bool do_hilight)
+{
+	border_relief_descr br;
+	window_parts draw_parts;
+	Bool do_clear;
+
+	if (HAS_NO_BORDER(fw))
+	{
+		/* just reset border states */
+		fw->decor_state.parts_drawn &= ~(PART_FRAME | PART_HANDLES);
+		fw->decor_state.parts_lit &= ~(PART_FRAME | PART_HANDLES);
+		fw->decor_state.parts_inverted &= ~(PART_FRAME | PART_HANDLES);
+		return;
+	}
+	do_clear = (clear_parts & CLEAR_FRAME) ? True : False;
+	/* determine the parts to draw and the position to place them */
+	if (HAS_DEPRESSABLE_BORDER(fw))
+	{
+		pressed_parts &= PART_FRAME;
+	}
+	else
+	{
+		pressed_parts = PART_NONE;
+	}
+	force_draw_parts &= PART_FRAME;
+	memset(&br, 0, sizeof(br));
+	draw_parts = border_get_parts_and_pos_to_draw(
+		cd, fw, pressed_parts, force_draw_parts, old_g, new_g,
+		do_hilight, &br);
+	if ((draw_parts & PART_FRAME) != PART_NONE)
+	{
+		border_draw_all_border_parts(
+			cd, fw, &br, new_g, draw_parts, pressed_parts,
+			do_hilight, do_clear);
+	}
+	/* update the decor states */
+	fw->decor_state.parts_drawn |= draw_parts;
+	if (do_hilight)
+	{
+		fw->decor_state.parts_lit |= draw_parts;
+	}
+	else
+	{
+		fw->decor_state.parts_lit &= ~draw_parts;
+	}
+	fw->decor_state.parts_inverted &= ~draw_parts;
+	fw->decor_state.parts_inverted |= (draw_parts & pressed_parts);
+
+	return;
+}
+
+/* ---------------------------- interface functions ------------------------ */
+
+DecorFace *border_get_border_style(
+	FvwmWindow *fw, Bool has_focus)
+{
+	DecorFace *df;
+
+	if (has_focus == True)
+	{
+		df = &(GetDecor(fw, BorderStyle.active));
+	}
+	else
+	{
+		df = &(GetDecor(fw, BorderStyle.inactive));
+	}
+
+	return df;
+}
+
+int border_is_using_border_style(
+	FvwmWindow *fw, Bool has_focus)
+{
+	ButtonState bs;
+	int is_pressed;
+	int is_toggled;
+	int i;
+
+	/* title */
+	is_pressed = (FW_W_TITLE(fw) == PressedW);
+	bs = border_flags_to_button_state(is_pressed, has_focus, 0);
+	if (DFS_USE_BORDER_STYLE(TB_STATE(GetDecor(fw, titlebar))[bs].style))
+	{
+		return 1;
+	}
+	for (i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		if (FW_W_BUTTON(fw, i) == None)
+		{
+			continue;
+		}
+		is_pressed = (FW_W_BUTTON(fw, i) == PressedW);
+		is_toggled = (is_button_toggled(fw, i) == True);
+		bs = border_flags_to_button_state(
+			is_pressed, (has_focus == True), is_toggled);
+		if (DFS_USE_BORDER_STYLE(
+			    TB_STATE(GetDecor(fw, buttons[i]))[bs].style))
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int border_context_to_parts(
+	int context)
+{
+	if (context == C_FRAME || context == C_SIDEBAR ||
+	    context == (C_FRAME | C_SIDEBAR))
+	{
+		return PART_FRAME;
+	}
+	else if (context == C_F_TOPLEFT)
+	{
+		return PART_BORDER_NW;
+	}
+	else if (context == C_F_TOPRIGHT)
+	{
+		return PART_BORDER_NE;
+	}
+	else if (context == C_F_BOTTOMLEFT)
+	{
+		return PART_BORDER_SW;
+	}
+	else if (context == C_F_BOTTOMRIGHT)
+	{
+		return PART_BORDER_SE;
+	}
+	else if (context == C_SB_LEFT)
+	{
+		return PART_BORDER_W;
+	}
+	else if (context == C_SB_RIGHT)
+	{
+		return PART_BORDER_E;
+	}
+	else if (context == C_SB_TOP)
+	{
+		return PART_BORDER_N;
+	}
+	else if (context == C_SB_BOTTOM)
+	{
+		return PART_BORDER_S;
+	}
+	else if (context == C_TITLE)
+	{
+		return PART_TITLE;
+	}
+	else if (context & (C_LALL | C_RALL))
+	{
+		return PART_BUTTONS;
+	}
+
+	return PART_NONE;
+}
+
+void border_get_part_geometry(
+	FvwmWindow *fw, window_parts part, rectangle *sidebar_g,
+	rectangle *ret_g, Window *ret_w)
+{
+	int bw;
+
+	bw = fw->boundary_width;
+	/* ret_g->x and ret->y is just an offset relatively to the w,
+	 * maybe we can take the relief in account? */
+	switch (part)
+	{
+	case PART_BORDER_N:
+		ret_g->x = sidebar_g->x;
+		ret_g->y = 0;
+		*ret_w = FW_W_SIDE(fw, 0);
+		break;
+	case PART_BORDER_E:
+		ret_g->x = 2 * sidebar_g->x + sidebar_g->width - bw;
+		ret_g->y = sidebar_g->y;
+		*ret_w = FW_W_SIDE(fw, 1);
+		break;
+	case PART_BORDER_S:
+		ret_g->x = sidebar_g->x;
+		ret_g->y = 2 * sidebar_g->y + sidebar_g->height - bw;
+		*ret_w = FW_W_SIDE(fw, 2);
+		break;
+	case PART_BORDER_W:
+		ret_g->x = 0;
+		ret_g->y = sidebar_g->y;
+		*ret_w = FW_W_SIDE(fw, 3);
+		break;
+	case PART_BORDER_NW:
+		ret_g->x = 0;
+		ret_g->y = 0;
+		*ret_w = FW_W_CORNER(fw, 0);
+		break;
+	case PART_BORDER_NE:
+		ret_g->x = sidebar_g->x + sidebar_g->width;
+		ret_g->y = 0;
+		*ret_w = FW_W_CORNER(fw, 1);
+		break;
+	case PART_BORDER_SW:
+		ret_g->x = 0;
+		ret_g->y = sidebar_g->y + sidebar_g->height;
+		*ret_w = FW_W_CORNER(fw, 2);
+		break;
+	case PART_BORDER_SE:
+		ret_g->x = sidebar_g->x + sidebar_g->width;
+		ret_g->y = sidebar_g->y + sidebar_g->height;
+		*ret_w = FW_W_CORNER(fw, 3);
+		break;
+	default:
+		break;
+	}
+
+	switch (part)
+	{
+	case PART_BORDER_N:
+	case PART_BORDER_S:
+		ret_g->width = sidebar_g->width;
+		ret_g->height = bw;
+		break;
+	case PART_BORDER_E:
+	case PART_BORDER_W:
+		ret_g->width = bw;
+		ret_g->height = sidebar_g->height;
+		break;
+	case PART_BORDER_NW:
+	case PART_BORDER_NE:
+	case PART_BORDER_SW:
+	case PART_BORDER_SE:
+		ret_g->width = sidebar_g->x;
+		ret_g->height = sidebar_g->y;
+		break;
+	default:
+		return;
+	}
+
+	return;
+}
+
+int get_button_number(int context)
+{
+	int i;
+
+	for (i = 0; (C_L1 << i) & (C_LALL | C_RALL); i++)
+	{
+		if (context & (C_L1 << i))
+		{
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+void border_draw_decorations(
+	FvwmWindow *fw, window_parts draw_parts, Bool has_focus, Bool do_force,
+	clear_window_parts clear_parts, rectangle *old_g, rectangle *new_g)
+{
+	common_decorations_type cd;
+	Bool do_redraw_titlebar = False;
+	window_parts pressed_parts;
+	window_parts force_parts;
+	int context;
+	int item;
+
+	if (fw == NULL)
+	{
+		return;
+	}
+	if (WAS_NEVER_DRAWN(fw))
+	{
+		/* force drawing everything */
+		do_force = True;
+		draw_parts = PART_ALL;
+		SET_WAS_NEVER_DRAWN(fw, 0);
+	}
+	memset(&cd, 0, sizeof(cd));
+
+	/* can't compare with True here, old code calls this with value "2" */
+	if (do_force != False)
+	{
+		force_parts = draw_parts;
+	}
+	else
+	{
+		force_parts = PART_NONE;
+	}
+	if (has_focus)
+	{
+		/* don't re-draw just for kicks */
+		if (Scr.Hilite != fw && Scr.Hilite != NULL)
+		{
+			FvwmWindow *t = Scr.Hilite;
+
+			Scr.Hilite = NULL;
+			/* make sure that the previously highlighted
+			 * window got unhighlighted */
+			border_draw_decorations(
+				t, PART_ALL, False, True, CLEAR_ALL, NULL,
+				NULL);
+		}
+		Scr.Hilite = fw;
+	}
+	else if (fw == Scr.Hilite)
+	{
+		Scr.Hilite = NULL;
+	}
+	if (fw->Desk != Scr.CurrentDesk)
+	{
+		return;
+	}
+	if (IS_ICONIFIED(fw))
+	{
+		DrawIconWindow(fw, True, True, True, False, NULL);
+		return;
+	}
+	/* calculate some values and flags */
+	if ((draw_parts & PART_TITLEBAR) && HAS_TITLE(fw))
+	{
+		do_redraw_titlebar = True;
+	}
+	get_common_decorations(
+		&cd, fw, draw_parts, has_focus, False, do_redraw_titlebar);
+	/* redraw */
+	context = frame_window_id_to_context(fw, PressedW, &item);
+	if ((context & (C_LALL | C_RALL)) == 0)
+	{
+		item = -1;
+	}
+	pressed_parts = border_context_to_parts(context);
+	if (new_g == NULL)
+	{
+		new_g = &fw->g.frame;
+	}
+	if (do_redraw_titlebar)
+	{
+		border_draw_titlebar(
+			&cd, fw, pressed_parts & PART_TITLEBAR, item,
+			force_parts & PART_TITLEBAR,
+			clear_parts, old_g, new_g, has_focus);
+	}
+	if (draw_parts & PART_FRAME)
+	{
+		Pixmap save_pix = cd.dynamic_cd.frame_pixmap;
+
+		memset(&cd, 0, sizeof(cd));
+		get_common_decorations(
+			&cd, fw, draw_parts, has_focus, True, True);
+		cd.dynamic_cd.frame_pixmap = save_pix;
+		border_draw_border_parts(
+			&cd, fw,
+			(pressed_parts & (PART_FRAME | PART_HANDLES)),
+			(force_parts & (PART_FRAME | PART_HANDLES)),
+			clear_parts, old_g, new_g, has_focus);
+	}
+	if (cd.dynamic_cd.frame_pixmap != None)
+	{
+		XFreePixmap(dpy, cd.dynamic_cd.frame_pixmap);
+	}
+	return;
+}
+
+void border_undraw_decorations(
+	FvwmWindow *fw)
+{
+	memset(&fw->decor_state, 0, sizeof(fw->decor_state));
+
+	return;
+}
+
+/*
+ *
+ *  redraw the decoration when style change
+ *
+ */
+void border_redraw_decorations(
+	FvwmWindow *fw)
+{
+	FvwmWindow *u = Scr.Hilite;
+
+	/* domivogt (6-Jun-2000): Don't check if the window is visible here.
+	 * If we do, some updates are not applied and when the window becomes
+	 * visible again, the X Server may not redraw the window. */
+	border_draw_decorations(
+		fw, PART_ALL, (Scr.Hilite == fw), True, CLEAR_ALL, NULL, NULL);
+	Scr.Hilite = u;
+
+	return;
+}
+
+/*
+ *
+ *  get the the root transparent parts of the decoration
+ *
+ */
+unsigned int border_get_transparent_decorations_part(FvwmWindow *fw)
+{
+	DecorFace *df,*tdf;
+	unsigned int draw_parts = PART_NONE;
+	int i;
+	window_parts pressed_parts;
+	int context;
+	int item;
+	border_titlebar_state tbstate;
+	Bool title_use_borderstyle = False;
+	Bool buttons_use_borderstyle = False;
+	Bool buttons_use_titlestyle = False;
+
+	context = frame_window_id_to_context(fw, PressedW, &item);
+	if ((context & (C_LALL | C_RALL)) == 0)
+	{
+		item = -1;
+	}
+	pressed_parts = border_context_to_parts(context);
+
+	memset(&tbstate, 0, sizeof(tbstate));
+	border_get_titlebar_descr_state(
+		fw, pressed_parts & PART_TITLEBAR, item,
+		CLEAR_ALL, (Scr.Hilite == fw), &tbstate);
+
+	for(i = 0; i < NUMBER_OF_TITLE_BUTTONS; i++)
+	{
+		df = &TB_STATE(GetDecor(fw, buttons[i]))[tbstate.bstate[i]];
+
+		if (DFS_USE_TITLE_STYLE(df->style))
+		{
+			buttons_use_titlestyle = True;
+		}
+		if (DFS_USE_BORDER_STYLE(df->style))
+		{
+			buttons_use_borderstyle = True;
+		}
+		for(tdf = df; tdf != NULL; tdf = tdf->next)
+		{
+			if (DFS_FACE_TYPE(tdf->style) == ColorsetButton &&
+			    CSET_IS_TRANSPARENT_ROOT(tdf->u.acs.cs))
+			{
+				draw_parts |= PART_BUTTONS;
+				break;
+			}
+		}
+	}
+
+	df = &TB_STATE(GetDecor(fw, titlebar))[tbstate.tstate];
+	if (DFS_USE_BORDER_STYLE(df->style))
+	{
+		title_use_borderstyle = True;
+	}
+	for(tdf = df; tdf != NULL; tdf = tdf->next)
+	{
+		if (DFS_FACE_TYPE(tdf->style) == ColorsetButton &&
+		    CSET_IS_TRANSPARENT_ROOT(tdf->u.acs.cs))
+		{
+			draw_parts |= PART_TITLE;
+			break;
+		}
+		else if (DFS_FACE_TYPE(tdf->style) == MultiPixmap)
+		{
+			int i;
+
+			for (i = 0; i < TBMP_NUM_PIXMAPS; i++)
+			{
+				if (CSET_IS_TRANSPARENT_ROOT(
+					tdf->u.mp.acs[i].cs))
+				{
+					draw_parts |= PART_TITLE;
+					break;
+				}
+			}
+		}
+	}
+
+	df = border_get_border_style(fw, (Scr.Hilite == fw));
+	if (DFS_FACE_TYPE(df->style) == ColorsetButton &&
+	    CSET_IS_TRANSPARENT_ROOT(df->u.acs.cs))
+	{
+		draw_parts |= PART_FRAME|PART_HANDLES;
+	}
+	if (draw_parts & PART_FRAME)
+	{
+		if (title_use_borderstyle)
+		{
+			draw_parts |= PART_TITLE;
+		}
+		if (buttons_use_borderstyle)
+		{
+			draw_parts |= PART_BUTTONS;
+		}
+	}
+	if ((draw_parts & PART_TITLE) && buttons_use_titlestyle)
+	{
+		draw_parts |= PART_BUTTONS;
+	}
+#if 0
+	fprintf(stderr,"Transparant Part: %u\n", draw_parts);
+#endif
+	return draw_parts;
+}
+
+/* ---------------------------- builtin commands --------------------------- */
+
+/*
+ *
+ *  Sets the allowed button states
+ *
+ */
+void CMD_ButtonState(F_CMD_ARGS)
+{
+	char *token;
+
+	while ((token = PeekToken(action, &action)))
+	{
+		static char first = True;
+		if (!token && first)
+		{
+			Scr.gs.use_active_down_buttons =
+				DEFAULT_USE_ACTIVE_DOWN_BUTTONS;
+			Scr.gs.use_inactive_buttons =
+				DEFAULT_USE_INACTIVE_BUTTONS;
+			Scr.gs.use_inactive_down_buttons =
+				DEFAULT_USE_INACTIVE_DOWN_BUTTONS;
+			return;
+		}
+		first = False;
+		if (StrEquals("activedown", token))
+		{
+			Scr.gs.use_active_down_buttons = ParseToggleArgument(
+				action, &action,
+				DEFAULT_USE_ACTIVE_DOWN_BUTTONS, True);
+		}
+		else if (StrEquals("inactive", token))
+		{
+			Scr.gs.use_inactive_buttons = ParseToggleArgument(
+				action, &action,
+				DEFAULT_USE_INACTIVE_BUTTONS, True);
+		}
+		else if (StrEquals("inactivedown", token))
+		{
+			Scr.gs.use_inactive_down_buttons = ParseToggleArgument(
+				action, &action,
+				DEFAULT_USE_INACTIVE_DOWN_BUTTONS, True);
+		}
+		else
+		{
+			Scr.gs.use_active_down_buttons =
+				DEFAULT_USE_ACTIVE_DOWN_BUTTONS;
+			Scr.gs.use_inactive_buttons =
+				DEFAULT_USE_INACTIVE_BUTTONS;
+			Scr.gs.use_inactive_down_buttons =
+				DEFAULT_USE_INACTIVE_DOWN_BUTTONS;
+			fvwm_msg(ERR, "cmd_button_state",
+				 "Unknown button state %s", token);
+			return;
+		}
+	}
+
+	return;
+}
+
+/*
+ *
+ *  Sets the border style (veliaa@rpi.edu)
+ *
+ */
+void CMD_BorderStyle(F_CMD_ARGS)
+{
+	char *parm;
+	char *prev;
+#ifdef USEDECOR
+	FvwmDecor *decor = Scr.cur_decor ? Scr.cur_decor : &Scr.DefaultDecor;
+#else
+	FvwmDecor *decor = &Scr.DefaultDecor;
+#endif
+
+	Scr.flags.do_need_window_update = 1;
+	decor->flags.has_changed = 1;
+	for (prev = action; (parm = PeekToken(action, &action)); prev = action)
+	{
+		if (StrEquals(parm, "active") || StrEquals(parm, "inactive"))
+		{
+			int len;
+			char *end, *tmp;
+			DecorFace tmpdf, *df;
+
+			memset(&tmpdf.style, 0, sizeof(tmpdf.style));
+			DFS_FACE_TYPE(tmpdf.style) = SimpleButton;
+			tmpdf.next = NULL;
+			if (FMiniIconsSupported)
+			{
+				tmpdf.u.p = NULL;
+			}
+			if (StrEquals(parm,"active"))
+			{
+				df = &decor->BorderStyle.active;
+			}
+			else
+			{
+				df = &decor->BorderStyle.inactive;
+			}
+			df->flags.has_changed = 1;
+			while (isspace(*action))
+			{
+				++action;
+			}
+			if (*action != '(')
+			{
+				if (!*action)
+				{
+					fvwm_msg(
+						ERR, "SetBorderStyle",
+						"error in %s border"
+						" specification", parm);
+					return;
+				}
+				while (isspace(*action))
+				{
+					++action;
+				}
+				if (ReadDecorFace(action, &tmpdf,-1,True))
+				{
+					FreeDecorFace(dpy, df);
+					*df = tmpdf;
+				}
+				break;
+			}
+			end = strchr(++action, ')');
+			if (!end)
+			{
+				fvwm_msg(
+					ERR, "SetBorderStyle",
+					"error in %s border specification",
+					parm);
+				return;
+			}
+			len = end - action + 1;
+			tmp = safemalloc(len);
+			strncpy(tmp, action, len - 1);
+			tmp[len - 1] = 0;
+			ReadDecorFace(tmp, df,-1,True);
+			free(tmp);
+			action = end + 1;
+		}
+		else if (strcmp(parm,"--")==0)
+		{
+			if (ReadDecorFace(
+				    prev, &decor->BorderStyle.active,-1,True))
+			{
+				ReadDecorFace(
+					prev, &decor->BorderStyle.inactive, -1,
+					False);
+			}
+			decor->BorderStyle.active.flags.has_changed = 1;
+			decor->BorderStyle.inactive.flags.has_changed = 1;
+			break;
+		}
+		else
+		{
+			DecorFace tmpdf;
+			memset(&tmpdf.style, 0, sizeof(tmpdf.style));
+			DFS_FACE_TYPE(tmpdf.style) = SimpleButton;
+			tmpdf.next = NULL;
+			if (FMiniIconsSupported)
+			{
+				tmpdf.u.p = NULL;
+			}
+			if (ReadDecorFace(prev, &tmpdf,-1,True))
+			{
+				FreeDecorFace(dpy,&decor->BorderStyle.active);
+				decor->BorderStyle.active = tmpdf;
+				ReadDecorFace(
+					prev, &decor->BorderStyle.inactive, -1,
+					False);
+				decor->BorderStyle.active.flags.has_changed = 1;
+				decor->BorderStyle.inactive.flags.has_changed =
+					1;
+			}
+			break;
+		}
+	}
+
+	return;
+}
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/borders.h fvwm-2.5.21-05/fvwm/borders.h
--- fvwm-2.5.21-04/fvwm/borders.h	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/borders.h	2007-03-03 13:18:49.000000000 +0100
@@ -29,21 +29,26 @@ typedef enum
 	PART_TITLE     = 0x100,
 	PART_BUTTONS   = 0x200,
 	PART_X_HANDLES = 0x400,
 	PART_Y_HANDLES = 0x800,
 	/* combinations of the above values */
 	PART_SIDES     = 0x0f,
 	PART_CORNERS   = 0xf0,
 	PART_FRAME     = 0xff,
 	PART_TITLEBAR  = 0x300,
 	PART_HANDLES   = 0xc00,
-	PART_ALL       = 0xfff
+	PART_ALL       = 0xfff,
+
+	PART_TOP       = 0x31,
+	PART_BOTTOM    = 0xc2,
+	PART_LEFT      = 0x58,
+	PART_RIGHT     = 0xa4
 } window_parts;
 
 typedef enum
 {
 	CLEAR_NONE     = 0x0,
 	CLEAR_FRAME    = 0x1,
 	CLEAR_TITLE    = 0x2,
 	CLEAR_BUTTONS  = 0x4,
 	CLEAR_ALL      = 0x7
 } clear_window_parts;
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/fvwm.h fvwm-2.5.21-05/fvwm/fvwm.h
--- fvwm-2.5.21-04/fvwm/fvwm.h	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/fvwm.h	2007-03-03 13:18:49.000000000 +0100
@@ -262,20 +262,21 @@ typedef struct
 		unsigned is_top_title_rotated : 1;
 		unsigned use_icon_position_hint : 1;
 		unsigned use_indexed_window_name : 1;
 		unsigned use_indexed_icon_name : 1;
 #define WINDOWSHADE_LAZY          0
 #define WINDOWSHADE_ALWAYS_LAZY   1
 #define WINDOWSHADE_BUSY          2
 #define WINDOWSHADE_LAZY_MASK   0x3
 		unsigned windowshade_laziness : 2;
 		unsigned use_title_decor_rotation : 1;
+		unsigned has_border_under_title : 1;
 		focus_policy_t focus_policy;
 	} s;
 } common_flags_t;
 
 typedef struct
 {
 	common_flags_t common;
 #define CR_MOTION_METHOD_AUTO        0
 #define CR_MOTION_METHOD_USE_GRAV    1
 #define CR_MOTION_METHOD_STATIC_GRAV 2
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/fvwm.h~ fvwm-2.5.21-05/fvwm/fvwm.h~
--- fvwm-2.5.21-04/fvwm/fvwm.h~	1970-01-01 01:00:00.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/fvwm.h~	2007-03-03 13:18:42.000000000 +0100
@@ -0,0 +1,909 @@
+/* -*-c-*- */
+/* This module is based on Twm, but has been siginificantly modified
+ * by Rob Nation */
+/*
+ *       Copyright 1988 by Evans & Sutherland Computer Corporation,
+ *                          Salt Lake City, Utah
+ *  Portions Copyright 1989 by the Massachusetts Institute of Technology
+ *                        Cambridge, Massachusetts
+ *
+ *                           All Rights Reserved
+ *
+ *    Permission to use, copy, modify, and distribute this software and
+ *    its documentation  for  any  purpose  and  without  fee is hereby
+ *    granted, provided that the above copyright notice appear  in  all
+ *    copies and that both  that  copyright  notice  and  this  permis-
+ *    sion  notice appear in supporting  documentation,  and  that  the
+ *    names of Evans & Sutherland and M.I.T. not be used in advertising
+ *    in publicity pertaining to distribution of the  software  without
+ *    specific, written prior permission.
+ *
+ *    EVANS & SUTHERLAND AND M.I.T. DISCLAIM ALL WARRANTIES WITH REGARD
+ *    TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  OF  MERCHANT-
+ *    ABILITY  AND  FITNESS,  IN  NO  EVENT SHALL EVANS & SUTHERLAND OR
+ *    M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL  DAM-
+ *    AGES OR  ANY DAMAGES WHATSOEVER  RESULTING FROM LOSS OF USE, DATA
+ *    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ *    TORTIOUS ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE
+ *    OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef FVWM_H
+#define FVWM_H
+
+/* ---------------------------- included header files ---------------------- */
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include <X11/Intrinsic.h>
+#include "libs/PictureBase.h"
+#include "libs/Flocale.h"
+#include "window_flags.h"
+#include "condrc.h"
+
+/* ---------------------------- global definitions ------------------------- */
+
+#ifndef WithdrawnState
+#define WithdrawnState 0
+#endif
+
+/* ---------------------------- global macros ------------------------------ */
+
+/*
+ * Fvwm trivia: There were 97 commands in the fvwm command table
+ * when the F_CMD_ARGS macro was written.
+ * dje 12/19/98.
+ */
+
+/* Macro for args passed to fvwm commands... */
+#define F_CMD_ARGS \
+	cond_rc_t *cond_rc, const exec_context_t *exc, char *action
+#define F_PASS_ARGS cond_rc, exc, action
+#define FUNC_FLAGS_TYPE unsigned char
+
+/* access macros */
+#define FW_W_FRAME(fw)        ((fw)->wins.frame)
+#define FW_W_PARENT(fw)       ((fw)->wins.parent)
+#define FW_W_CLIENT(fw)       ((fw)->wins.client)
+#define FW_W(fw)              FW_W_CLIENT(fw)
+#define FW_W_TITLE(fw)        ((fw)->wins.title)
+#define FW_W_BUTTON(fw,i)     ((fw)->wins.button_w[(i)])
+#define FW_W_SIDE(fw,i)       ((fw)->wins.sides[(i)])
+#define FW_W_CORNER(fw,i)     ((fw)->wins.corners[(i)])
+#define FW_W_ICON_TITLE(fw)   ((fw)->wins.icon_title_w)
+#define FW_W_ICON_PIXMAP(fw)  ((fw)->wins.icon_pixmap_w)
+#define FW_W_TRANSIENTFOR(fw) ((fw)->wins.transientfor)
+
+/* ---------------------------- forward declarations ----------------------- */
+
+struct exec_context_t;
+
+#ifdef USEDECOR
+/* definition in screen.h */
+struct FvwmDecor;
+#endif
+
+/* ---------------------------- type definitions --------------------------- */
+
+/* This structure carries information about the initial window state and
+ * placement.  This information is gathered at various places: the (re)capture
+ * code, AddToWindow(), HandleMapRequestRaised(), ewmh_events.c and others.
+ *
+ * initial_state
+ *   The initial window state.  By default it carries the value DontCareState.
+ *   Other states can be set if
+ *    - an icon is recaptured or restarted with session management
+ *    - the StartIconic style is set
+ *    - GNOME, EWMH, foobar hints demand that the icon starts iconic
+ *   The final value is calculated in HandleMapRequestRaised().
+ *
+ * do_override_ppos
+ *   This flag is used in PlaceWindow().  If it is set, the position requested
+ *   by the program is ignored unconditionally.  This is used during the
+ *   initial capture and later recapture operations.
+ *
+ * is_iconified_by_parent
+ *   Preserves the information if the window is a transient window that was
+ *   iconified along with its transientfor window.  Set when the window is
+ *   recaptured and used in HandleMapRequestRaised() to set the according
+ *   window state flag.  Deleted afterwards.
+ *
+ * is_menu
+ *   Set in menus.c or in the recapture code if the new window is a tear off
+ *   menu.  Such windows get special treatment in AddWindow() and events.c.
+ *
+ * is_recapture
+ *   Set for the initial capture and later recaptures.
+ *
+ * default_icon_x/y
+ *   The icon position that was requested by the application in the icon
+ *   position hint.  May be overridden by a style (0/0 then).  Set in
+ *   HandleMapRequestRaised() and used in the icon placement code.
+ *
+ * initial_icon_x/y
+ *   The icon position that is forced during a restart with SM.  If set it
+ *   overrides all other methods of icon placement.  Set by session.c and used
+ *   in the icon placement code.
+ *
+ * use_initial_icon_xy
+ *   If set, the initial_icon_x/y values are used.  Other wise they are
+ *   ignored.
+ */
+typedef struct
+{
+	long initial_state;
+	struct
+	{
+		unsigned do_override_ppos : 1;
+		unsigned is_iconified_by_parent : 1;
+		unsigned is_menu : 1;
+		unsigned is_recapture : 1;
+		unsigned use_initial_icon_xy : 1;
+	} flags;
+	int initial_icon_x;
+	int initial_icon_y;
+	int default_icon_x;
+	int default_icon_y;
+} initial_window_options_t;
+
+/*
+  For 1 style statement, there can be any number of IconBoxes.
+  The name list points at the first one in the chain.
+*/
+typedef struct icon_boxes_struct
+{
+	struct icon_boxes_struct *next;       /* next icon_boxes or zero */
+	unsigned int use_count;
+	int IconBox[4];                       /* x/y x/y for iconbox */
+	int IconScreen;                       /* Xinerama screen */
+	short IconGrid[2];                    /* x incr, y incr */
+	char IconSign[4];                     /* because of -0, need to save */
+	unsigned is_orphan : 1;
+	unsigned IconFlags : 3;               /* some bits */
+	/* IconFill only takes 3 bits.  Defaults are top, left, vert co-ord
+	 * first eg: t l = 0,0,0; l t = 0,0,1; b r = 1,1,0 */
+#define ICONFILLBOT (1<<0)
+#define ICONFILLRGT (1<<1)
+#define ICONFILLHRZ (1<<2)
+} icon_boxes;
+
+typedef struct
+{
+	Pixel fore;
+	Pixel back;
+} ColorPair;
+
+typedef struct
+{
+	Pixel fore;
+	Pixel back;
+	Pixel hilight;
+	Pixel shadow;
+} color_quad;
+
+typedef struct
+{
+	int left;
+	int right;
+	int top;
+	int bottom;
+} ewmh_strut;
+
+typedef struct
+{
+	/* common flags (former flags in bits 0-12) */
+	unsigned is_sticky_across_pages : 1;
+	unsigned is_sticky_across_desks : 1;
+	unsigned has_icon_font : 1;
+	unsigned has_no_border : 1;
+	unsigned has_window_font : 1;
+	unsigned title_dir : 2;
+	unsigned user_states : 32;
+	/* static flags that do not change dynamically after the window has
+	 * been created */
+	struct
+	{
+		unsigned do_circulate_skip : 1;
+		unsigned do_circulate_skip_icon : 1;
+		unsigned do_circulate_skip_shaded : 1;
+		unsigned do_ewmh_donate_icon : 1;
+		unsigned do_ewmh_donate_mini_icon : 1;
+		unsigned do_ewmh_ignore_state_hints : 1;
+		unsigned do_ewmh_ignore_strut_hints : 1;
+		unsigned do_ewmh_mini_icon_override : 1;
+		unsigned do_ewmh_use_stacking_hints : 1;
+		unsigned do_ewmh_ignore_window_type : 1;
+		unsigned do_iconify_window_groups : 1;
+		unsigned do_ignore_gnome_hints : 1;
+		unsigned do_ignore_icon_boxes : 1;
+		unsigned do_ignore_restack : 1;
+		unsigned do_use_window_group_hint : 1;
+		unsigned do_lower_transient : 1;
+		unsigned do_not_show_on_map : 1;
+		unsigned do_raise_transient : 1;
+		unsigned do_resize_opaque : 1;
+		unsigned do_resize_outline_thin : 1;
+		unsigned do_shrink_windowshade : 1;
+		unsigned do_stack_transient_parent : 1;
+		unsigned do_window_list_skip : 1;
+		unsigned ewmh_maximize_mode : 2; /* see ewmh.h */
+		unsigned has_depressable_border : 1;
+		unsigned has_mwm_border : 1;
+		unsigned has_mwm_buttons : 1;
+		unsigned has_mwm_override : 1;
+		unsigned has_no_icon_title : 1;
+		unsigned has_override_size : 1;
+		unsigned has_stippled_title : 1;
+		unsigned has_stippled_icon_title : 1;
+		/* default has to be 0, therefore no_, not in macros */
+		unsigned has_no_sticky_stippled_title : 1;
+		unsigned has_no_sticky_stippled_icon_title : 1;
+		unsigned icon_override : 2;
+#define NO_ACTIVE_ICON_OVERRIDE 0
+#define ICON_OVERRIDE           1
+#define NO_ICON_OVERRIDE        2
+#define ICON_OVERRIDE_MASK    0x3
+		unsigned is_bottom_title_rotated : 1;
+		unsigned is_fixed : 1;
+		unsigned is_fixed_ppos : 1;
+		unsigned is_uniconifiable : 1;
+		unsigned is_unmaximizable : 1;
+		unsigned is_unclosable : 1;
+		unsigned is_maximize_fixed_size_disallowed : 1;
+		unsigned is_icon_sticky_across_pages : 1;
+		unsigned is_icon_sticky_across_desks : 1;
+		unsigned is_icon_suppressed : 1;
+		unsigned is_left_title_rotated_cw : 1; /* cw = clock wise */
+		unsigned is_lenient : 1;
+		unsigned is_size_fixed : 1;
+		unsigned is_psize_fixed : 1;
+		unsigned is_right_title_rotated_cw : 1;
+		unsigned is_top_title_rotated : 1;
+		unsigned use_icon_position_hint : 1;
+		unsigned use_indexed_window_name : 1;
+		unsigned use_indexed_icon_name : 1;
+#define WINDOWSHADE_LAZY          0
+#define WINDOWSHADE_ALWAYS_LAZY   1
+#define WINDOWSHADE_BUSY          2
+#define WINDOWSHADE_LAZY_MASK   0x3
+		unsigned windowshade_laziness : 2;
+		unsigned use_title_decor_rotation : 1;
+		focus_policy_t focus_policy;
+	} s;
+} common_flags_t;
+
+typedef struct
+{
+	common_flags_t common;
+#define CR_MOTION_METHOD_AUTO        0
+#define CR_MOTION_METHOD_USE_GRAV    1
+#define CR_MOTION_METHOD_STATIC_GRAV 2
+#define CR_MOTION_METHOD_MASK      0x3
+	unsigned cr_motion_method : 2;
+	unsigned was_cr_motion_method_detected : 1;
+	unsigned does_wm_delete_window : 1;
+	unsigned does_wm_take_focus : 1;
+	unsigned do_force_next_cr : 1;
+	unsigned do_force_next_pn : 1;
+	unsigned do_iconify_after_map : 1;
+	unsigned do_disable_constrain_size_fullscreen : 1;
+	/* Reuse this struct, don't free it, when destroying/recapturing
+	 * window. */
+	unsigned do_reuse_destroyed : 1;
+	/* Does it have resize handles? */
+	unsigned has_handles : 1;
+	/* Icon change is pending */
+	unsigned has_icon_changed : 1;
+	/* Is this decorated with title */
+	unsigned has_title : 1;
+	/* wm_normal_hints update is pending? */
+	unsigned has_new_wm_normal_hints : 1;
+	/* ChangeDecor was used for window */
+	unsigned is_decor_changed : 1;
+	/* Sent an XUnmapWindow for iconifying, but didn't receive an
+	 * UnmapNotify yet.*/
+	unsigned is_iconify_pending : 1;
+	/* window had the focus when the desk was switched. set if the window
+	 * was mapped and got focused but the focus change was not announced
+	 * to the modules yet. */
+	unsigned is_focused_on_other_desk : 1;
+	unsigned is_focus_change_broadcast_pending : 1;
+	/* is the window fully visible */
+	unsigned is_fully_visible : 1;
+	/* is it an icon now? */
+	unsigned is_iconified : 1;
+	/* To prevent iconified transients in a parent icon from counting for
+	 * Next */
+	unsigned is_iconified_by_parent : 1;
+	/* is the pointer over the icon? */
+	unsigned is_icon_entered : 1;
+	unsigned is_icon_font_loaded : 1;
+	/* has the icon been moved by the user? */
+	unsigned is_icon_moved : 1;
+	/* is the icon window supplied by the app? */
+	unsigned is_icon_ours : 1;
+	/* is the icon shaped? */
+	unsigned is_icon_shaped : 1;
+	/* was the icon unmapped, even though the window is still iconified
+	 * (Transients) */
+	unsigned is_icon_unmapped : 1;
+	/* temporary flag used in stack.c */
+	unsigned is_in_transient_subtree : 1;
+	/* is it mapped? */
+	unsigned is_mapped : 1;
+	/* Sent an XMapWindow, but didn't receive a MapNotify yet.*/
+	unsigned is_map_pending : 1;
+	/* is the window maximized? */
+	unsigned is_maximized : 1;
+	/* Set if the client changes its WM_NAME. The source of twm contains
+	 * an explanation why we need this information. */
+	unsigned is_name_changed : 1;
+	/* is the window partially visible */
+	unsigned is_partially_visible : 1;
+	/* is the icon pixmap ours to free? */
+	unsigned is_pixmap_ours : 1;
+	/* fvwm places the window itself */
+	unsigned is_placed_by_fvwm : 1;
+	/* mark window to be destroyed after last complex func has finished. */
+	unsigned is_scheduled_for_destroy : 1;
+	/* mark window to be raised after function execution. */
+	unsigned is_scheduled_for_raise : 1;
+	unsigned is_size_inc_set : 1;
+	unsigned is_style_deleted : 1;
+	/* the window is a torn out fvwm menu */
+	unsigned is_tear_off_menu : 1;
+	/* is it a transient window? */
+	unsigned is_transient : 1;
+	unsigned is_window_drawn_once : 1;
+	/* To prevent double move in MoveViewport.*/
+	unsigned is_viewport_moved : 1;
+	unsigned is_window_being_moved_opaque : 1;
+	unsigned is_window_font_loaded : 1;
+	unsigned is_window_shaded : 1;
+	unsigned used_title_dir_for_shading : 1;
+	unsigned shaded_dir : 3;
+	unsigned using_default_icon_font : 1;
+	unsigned using_default_window_font : 1;
+#define ICON_HINT_NEVER    0
+#define ICON_HINT_ONCE     1
+#define ICON_HINT_MULTIPLE 2
+	unsigned was_icon_hint_provided : 2;
+	unsigned was_icon_name_provided : 1;
+	unsigned was_never_drawn : 1;
+	unsigned has_ewmh_wm_name : 1;
+	unsigned has_ewmh_wm_icon_name : 1;
+#define EWMH_NO_ICON     0 /* the application does not provide an ewmh icon */
+#define EWMH_TRUE_ICON   1 /* the application does provide an ewmh icon */
+#define EWMH_FVWM_ICON   2 /* the ewmh icon has been set by fvwm */
+	unsigned has_ewmh_wm_icon_hint : 2;
+	/* says if the app have an ewmh icon of acceptable size for a mini
+	 * icon in its list of icons */
+	unsigned has_ewmh_mini_icon : 1;
+	unsigned has_ewmh_wm_pid : 1;
+	/* the ewmh icon is used as icon pixmap */
+	unsigned use_ewmh_icon : 1;
+	unsigned is_ewmh_modal : 1;
+	unsigned is_ewmh_fullscreen : 1;
+#define EWMH_STATE_UNDEFINED_HINT 0
+#define EWMH_STATE_NO_HINT        1
+#define EWMH_STATE_HAS_HINT       2
+	unsigned has_ewmh_init_fullscreen_state : 2;
+	unsigned has_ewmh_init_hidden_state : 2;
+	unsigned has_ewmh_init_maxhoriz_state : 2;
+	unsigned has_ewmh_init_maxvert_state : 2;
+	unsigned has_ewmh_init_modal_state : 2;
+	unsigned has_ewmh_init_shaded_state : 2;
+	unsigned has_ewmh_init_skip_pager_state : 2;
+	unsigned has_ewmh_init_skip_taskbar_state : 2;
+	unsigned has_ewmh_init_sticky_state : 2;
+	unsigned has_ewmh_init_wm_desktop : 2;
+} window_flags;
+
+
+/* Actions allowed by modules. */
+typedef struct action_flags
+{
+	unsigned is_movable : 1;
+	unsigned is_deletable : 1;
+	unsigned is_destroyable : 1;
+	unsigned is_closable : 1;
+	unsigned is_maximizable : 1;
+	unsigned is_resizable : 1;
+	unsigned is_iconifiable : 1;
+} action_flags;
+
+
+/* Window name data structure for window conditions: a list of lists
+   of names to match, the boolean operation on the matches being an
+   AND of ORs. */
+struct namelist			/* matches to names in this list are ORed */
+{
+	char *name;
+	struct namelist *next;
+};
+
+struct name_condition		/* matches to namelists in this list are
+				   ANDed, after possibly inverting each */
+{
+	Bool invert;
+	struct namelist *namelist;
+	struct name_condition *next;
+};
+
+/* Window mask for Circulate and Direction functions */
+typedef struct WindowConditionMask
+{
+	struct
+	{
+		unsigned do_accept_focus : 1;
+		unsigned do_check_desk : 1;
+		unsigned do_check_desk_and_global_page : 1;
+		unsigned do_check_desk_and_page : 1;
+		unsigned do_check_global_page : 1;
+		unsigned do_check_overlapped : 1;
+		unsigned do_check_page : 1;
+		unsigned do_not_check_screen : 1;
+		unsigned needs_current_desk : 1;
+		unsigned needs_current_desk_and_global_page : 1;
+		unsigned needs_current_desk_and_page : 1;
+		unsigned needs_current_global_page : 1;
+		unsigned needs_current_page : 1;
+#define NEEDS_ANY   0
+#define NEEDS_TRUE  1
+#define NEEDS_FALSE 2
+		unsigned needs_focus : 2;
+		unsigned needs_overlapped : 2;
+		unsigned needs_pointer : 2;
+		unsigned needs_same_layer : 1;
+		unsigned use_circulate_hit : 1;
+		unsigned use_circulate_hit_icon : 1;
+		unsigned use_circulate_hit_shaded : 1;
+		unsigned use_do_accept_focus : 1;
+	} my_flags;
+	window_flags flags;
+	window_flags flag_mask;
+	struct name_condition *name_condition;
+	int layer;
+	int placed_by_button_mask;
+	int placed_by_button_set_mask;
+} WindowConditionMask;
+
+/* only style.c and add_window.c are allowed to access this struct! */
+typedef struct
+{
+	common_flags_t common;
+	unsigned do_decorate_transient : 1;
+	/* old placement flags */
+#define PLACE_DUMB            0x0
+#define PLACE_SMART           0x1
+#define PLACE_CLEVER          0x2
+#define PLACE_CLEVERNESS_MASK 0x3
+#define PLACE_RANDOM          0x4
+	/* new placements value, try to get a minimal backward compatibility
+	 * with the old flags:
+	 * Dumb+Active = Manual,
+	 * Dumb+Random = Cascade,
+	 * Smart+Random = TileCascade,
+	 * Smart+Active = TileManual,
+	 * Random+Smart+Clever = MINOVERLAP which is the original Clever
+	 * placement code,
+	 * Active+Smart+Clever = MINOVERLAPPERCENT which is the "new" Clever
+	 * placement code and was the original Clever placement code. Now the
+	 * original placement code said:
+	 * Active/Random+Dumb+Clever = Active/Random+Dumb (with Dumb Clever is
+	 * ignored); These represent the not use value: 0x2=Active+Dumb+Clever,
+	 * 0x6=Random+Dumb+Clever */
+#define PLACE_MANUAL            0x0
+#define PLACE_TILEMANUAL        0x1
+#define PLACE_MANUAL_B          0x2
+#define PLACE_MINOVERLAPPERCENT 0x3
+#define PLACE_CASCADE           0x4
+#define PLACE_TILECASCADE       0x5
+#define PLACE_CASCADE_B         0x6
+#define PLACE_MINOVERLAP        0x7
+#define PLACE_CENTER            0x8
+#define PLACE_UNDERMOUSE        0x9
+#define PLACE_MASK              0xF
+	unsigned placement_mode : 4;
+	unsigned ewmh_placement_mode : 2; /* see ewmh.h */
+#define WS_CR_MOTION_METHOD_AUTO CR_MOTION_METHOD_AUTO
+#define WS_CR_MOTION_METHOD_USE_GRAV CR_MOTION_METHOD_USE_GRAV
+#define WS_CR_MOTION_METHOD_STATIC_GRAV CR_MOTION_METHOD_STATIC_GRAV
+#define WS_CR_MOTION_METHOD_MASK CR_MOTION_METHOD_MASK
+	unsigned ws_cr_motion_method : 2;
+	unsigned do_save_under : 1;
+	unsigned do_start_iconic : 1;
+	unsigned do_start_lowered : 1;
+	unsigned has_border_width : 1;
+	unsigned has_color_back : 1;
+	unsigned has_color_fore : 1;
+	unsigned has_color_back_hi : 1;
+	unsigned has_color_fore_hi : 1;
+	unsigned has_decor : 1;
+	unsigned has_handle_width : 1;
+	unsigned has_icon : 1;
+	unsigned has_icon_boxes : 1;
+	unsigned has_icon_size_limits : 1;
+	unsigned has_max_window_size : 1;
+	unsigned has_icon_background_padding : 1;
+	unsigned has_icon_background_relief : 1;
+	unsigned has_icon_title_relief : 1;
+	unsigned has_window_shade_steps : 1;
+	unsigned has_mini_icon : 1;
+	unsigned has_mwm_decor : 1;
+	unsigned has_mwm_functions : 1;
+	unsigned has_no_handles : 1;
+	unsigned has_no_title : 1;
+	unsigned has_ol_decor : 1;
+#if 0
+	unsigned has_condition_mask : 1;
+#endif
+	unsigned is_button_disabled : NUMBER_OF_TITLE_BUTTONS;
+	unsigned is_unmanaged : 1;
+#define BACKINGSTORE_DEFAULT 0
+#define BACKINGSTORE_ON      1
+#define BACKINGSTORE_OFF     2
+#define BACKINGSTORE_MASK  0x3
+	unsigned use_backing_store : 2;
+	unsigned use_parent_relative : 1;
+	unsigned use_colorset : 1;
+	unsigned use_colorset_hi : 1;
+	unsigned use_border_colorset : 1;
+	unsigned use_border_colorset_hi : 1;
+	unsigned use_icon_title_colorset : 1;
+	unsigned use_icon_title_colorset_hi : 1;
+	unsigned use_icon_background_colorset : 1;
+	unsigned use_layer : 1;
+	unsigned use_no_pposition : 1;
+	unsigned use_no_usposition : 1;
+	unsigned use_no_transient_pposition : 1;
+	unsigned use_no_transient_usposition : 1;
+	unsigned use_start_on_desk : 1;
+	unsigned use_start_on_page_for_transient : 1;
+	unsigned use_start_on_screen : 1;
+	unsigned manual_placement_honors_starts_on_page : 1;
+	unsigned capture_honors_starts_on_page : 1;
+	unsigned recapture_honors_starts_on_page : 1;
+	unsigned has_placement_penalty : 1;
+	unsigned has_placement_percentage_penalty : 1;
+} style_flags;
+
+typedef struct
+{
+	char *name;
+	XID window_id;
+	struct
+	{
+		unsigned has_name:1;
+		unsigned has_window_id:1;
+	} flags;
+} style_id_t;
+
+
+/* only style.c and add_window.c are allowed to access this struct! */
+typedef struct window_style
+{
+	struct window_style *next;
+	struct window_style *prev;
+	style_id_t id;
+#if 0
+	WindowConditionMask *condition_mask;
+#endif
+	char *icon_name;
+	char *mini_icon_name;
+#ifdef USEDECOR
+	char *decor_name;
+#endif
+	unsigned char min_icon_width;
+	unsigned char max_icon_width;
+	unsigned char min_icon_height;
+	unsigned char max_icon_height;
+#define ICON_RESIZE_TYPE_NONE      0x0
+#define ICON_RESIZE_TYPE_STRETCHED 0x1
+#define ICON_RESIZE_TYPE_ADJUSTED  0x2
+#define ICON_RESIZE_TYPE_SHRUNK    0x3
+#define ICON_RESIZE_TYPE_MASK      0x3
+	unsigned icon_resize_type : 2;
+	unsigned char icon_background_padding;
+	signed char icon_background_relief;
+	signed char icon_title_relief;
+	char *icon_font;
+	char *window_font;
+	char *fore_color_name;
+	char *back_color_name;
+	char *fore_color_name_hi;
+	char *back_color_name_hi;
+	int colorset;
+	int colorset_hi;
+	int border_colorset;
+	int border_colorset_hi;
+	int icon_title_colorset;
+	int icon_title_colorset_hi;
+	int icon_background_colorset;
+	short border_width;
+	/* resize handle width */
+	short handle_width;
+	int layer;
+	int start_desk;
+	int start_page_x;
+	int start_page_y;
+	int start_screen;
+	int max_window_width;
+	int max_window_height;
+	int shade_anim_steps;
+	icon_boxes *icon_boxes;
+	float norm_placement_penalty;
+	float placement_penalty[6];
+	int placement_percentage_penalty[4];
+	style_flags flags;
+	style_flags flag_default;
+	style_flags flag_mask;
+	style_flags change_mask;
+	unsigned has_style_changed : 1;
+} window_style;
+
+typedef struct window_g
+{
+	rectangle frame;
+	/* absolute geometry when not maximized */
+	rectangle normal;
+	/* maximized window geometry */
+	rectangle max;
+	/* defect between maximized geometry before and after
+	 * constraining size. */
+	size_rect max_defect;
+	/* original delta between normalized and maximized window,
+	 * used to keep unmaximized window at same screen position */
+	position max_offset;
+} window_g;
+
+/* for each window that is on the display, one of these structures
+ * is allocated and linked into a list
+ */
+typedef struct FvwmWindow
+{
+	/* name of the window */
+	FlocaleNameString name;
+	/* name of the icon */
+	FlocaleNameString icon_name;
+	char *visible_name;
+	char *visible_icon_name;
+	/* if non-null: Use this instead of any other names for matching
+	   styles */
+	char *style_name;
+	int name_count;
+	int icon_name_count;
+	/* next fvwm window */
+	struct FvwmWindow *next;
+	/* prev fvwm window */
+	struct FvwmWindow *prev;
+	/* next (lower) fvwm window in stacking order*/
+	struct FvwmWindow *stack_next;
+	/* prev (higher) fvwm window in stacking order */
+	struct FvwmWindow *stack_prev;
+	/* border width before reparenting */
+	struct
+	{
+		/* the frame window */
+		Window frame;
+		/* It looks like you HAVE to reparent the app window into a
+		 * window whose size = app window, or else you can't keep xv
+		 * and matlab happy at the same time! */
+		Window parent;
+		/* the child window */
+		Window client;
+		/* the title bar window and button windows */
+		Window title;
+		Window button_w[NUMBER_OF_TITLE_BUTTONS];
+		/* sides of the border */
+		Window sides[4];
+		/* corner pieces */
+		Window corners[4];
+		/* icon title window */
+		Window icon_title_w;
+		/* icon picture window */
+		Window icon_pixmap_w;
+		Window transientfor;
+	} wins;
+	window_flags flags;
+	struct
+	{
+		unsigned buttons_drawn : NUMBER_OF_TITLE_BUTTONS;
+		unsigned buttons_lit : NUMBER_OF_TITLE_BUTTONS;
+		unsigned buttons_inverted : NUMBER_OF_TITLE_BUTTONS;
+		unsigned buttons_toggled : NUMBER_OF_TITLE_BUTTONS;
+		unsigned parts_drawn : 12;
+		unsigned parts_lit : 12;
+		unsigned parts_inverted : 12;
+	} decor_state;
+	int nr_left_buttons;
+	int nr_right_buttons;
+#define BUTTON_INDEX(b) \
+	(((b) == 0) ? (NUMBER_OF_TITLE_BUTTONS - 1) : ((b) - 1))
+#ifdef USEDECOR
+	struct FvwmDecor *decor;
+#endif
+	/* is this a shaped window */
+	int wShaped;
+	Pixmap title_background_pixmap;
+
+	/* Note: if the type of this variable is changed, do update the
+	 * CONFIGARGSNEW macro in module_interface.c, libs/vpacket.h too! */
+	short boundary_width;
+	short unshaped_boundary_width;
+	short corner_width;
+	short visual_corner_width;
+
+	/* title font */
+	FlocaleFont *title_font;
+	/* /Y coordinate to draw the title name */
+	short title_text_offset;
+	short title_length;
+	/* Note: if the type of this variable is changed, do update the
+	 * CONFIGARGSNEW macro in module_interface.c, libs/vpacket.h and too!
+	 */
+	short title_thickness;
+	rotation_t title_text_rotation;
+	struct
+	{
+		/* geometry of the icon picture window */
+		rectangle picture_w_g;
+		/* geometry of the icon title window */
+		rectangle title_w_g;
+		/* width of the text in the icon title */
+		int title_text_width;
+	} icon_g;
+	short icon_border_width;
+
+	/* Drawable depth for the icon */
+	int iconDepth;
+	/* pixmap for the icon */
+	Pixmap iconPixmap;
+	/* pixmap for the icon mask */
+	Pixmap icon_maskPixmap;
+	Pixmap icon_alphaPixmap;
+	int icon_nalloc_pixels;
+	Pixel *icon_alloc_pixels;
+	int icon_no_limit;
+	FlocaleFont *icon_font;
+
+	/* some parts of the window attributes */
+	struct
+	{
+		int backing_store;
+		int border_width;
+		int depth;
+		int bit_gravity;
+		unsigned is_bit_gravity_stored : 1;
+		Visual *visual;
+		Colormap colormap;
+	} attr_backup;
+	/* normal hints */
+	XSizeHints hints;
+	struct
+	{
+		int width_inc;
+		int height_inc;
+	} orig_hints;
+	/* WM hints */
+	XWMHints *wmhints;
+	XClassHint class;
+	/* Tells which desktop this window is on */
+	/* Note: if the type of this variable is changed, do update the
+	 * CONFIGARGSNEW macro in module_interface.c, libs/vpacket.h and too!
+	 */
+	int Desk;
+	/* Where (if at all) was it focused */
+	int FocusDesk;
+	/* Desk to deiconify to, for StubbornIcons */
+	int DeIconifyDesk;
+
+	char *mini_pixmap_file;
+	FvwmPicture *mini_icon;
+	char *icon_bitmap_file;
+
+	struct window_g g;
+	long *mwm_hints;
+	int ol_hints;
+	int functions;
+	/* Colormap windows property */
+	Window *cmap_windows;
+	/* Should generally be 0 */
+	int number_cmap_windows;
+	color_quad colors;
+	color_quad hicolors;
+	color_quad border_colors;
+	color_quad border_hicolors;
+
+	int cs;
+	int cs_hi;
+	int border_cs;
+	int border_cs_hi;
+	int icon_title_cs;
+	int icon_title_cs_hi;
+	int icon_background_cs;
+
+	unsigned long buttons;
+	/* zero or more iconboxes */
+	icon_boxes *IconBoxes;
+
+	int default_layer;
+	/* Note: if the type of this variable is changed, do update the
+	 * CONFIGARGSNEW macro in module_interface.c, libs/vpacket.h and too!
+	 */
+	int layer;
+
+	unsigned char min_icon_width;
+	unsigned char max_icon_width;
+	unsigned char min_icon_height;
+	unsigned char max_icon_height;
+	unsigned short icon_resize_type;
+
+	unsigned char icon_background_padding;
+	char icon_background_relief;
+	char icon_title_relief;
+
+	int max_window_width;
+	int max_window_height;
+	int shade_anim_steps;
+	unsigned char grabbed_buttons;
+
+#define FM_NO_INPUT        0
+#define FM_PASSIVE         1
+#define FM_LOCALLY_ACTIVE  2
+#define FM_GLOBALLY_ACTIVE 3
+	unsigned char focus_model;
+
+	float placement_penalty[6];
+	int placement_percentage_penalty[4];
+
+	unsigned char placed_by_button;
+
+#define EWMH_WINDOW_TYPE_NONE_ID      0
+#define EWMH_WINDOW_TYPE_DESKTOP_ID   1
+#define EWMH_WINDOW_TYPE_DIALOG_ID    2
+#define EWMH_WINDOW_TYPE_DOCK_ID      3
+#define EWMH_WINDOW_TYPE_MENU_ID      4
+#define EWMH_WINDOW_TYPE_NORMAL_ID    5
+#define EWMH_WINDOW_TYPE_TOOLBAR_ID   6
+	/* Note: if the type of this variable is changed, do update the
+	 * CONFIGARGSNEW macro in module_interface.c, libs/vpacket.h and too!
+	 */
+	int ewmh_window_type;
+	/* icon geometry */
+	rectangle ewmh_icon_geometry;
+	/* for computing the working area */
+	ewmh_strut strut;
+	/* for the dynamic working area */
+	ewmh_strut dyn_strut;
+	/* memories for the icons we set on the */
+	int ewmh_icon_height;
+	/* _NET_WM_ICON */
+	int ewmh_icon_width;
+	int ewmh_mini_icon_height;
+	int ewmh_mini_icon_width;
+	/* memory for the initial _NET_WM_STATE */
+	/* Note: if the type of this variable is changed, do update the
+	 * CONFIGARGSNEW macro in module_interface.c, libs/vpacket.h and too!
+	 */
+	int ewmh_hint_layer;
+	int ewmh_normal_layer; /* for restoring non ewmh layer */
+	/* memory for the initial _NET_WM_STATE */
+	unsigned long ewmh_hint_desktop;
+
+	/* multi purpose scratch structure */
+	struct
+	{
+		void *p;
+		int i;
+	} scratch;
+} FvwmWindow;
+
+/* ---------------------------- exported variables (globals) --------------- */
+
+/* ---------------------------- interface functions ------------------------ */
+
+void SetMWM_INFO(Window window);
+
+#endif /* FVWM_H */
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/geometry.c fvwm-2.5.21-05/fvwm/geometry.c
--- fvwm-2.5.21-04/fvwm/geometry.c	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/geometry.c	2007-03-03 13:18:49.000000000 +0100
@@ -39,20 +39,23 @@
 /* ---------------------------- local macros ------------------------------- */
 
 /* ---------------------------- imports ------------------------------------ */
 
 /* ---------------------------- included code files ------------------------ */
 
 /* ---------------------------- local types -------------------------------- */
 
 /* ---------------------------- forward declarations ----------------------- */
 
+static void __get_window_borders(
+	const FvwmWindow *fw, size_borders *borders, Bool is_shaded);
+
 /* ---------------------------- local variables ---------------------------- */
 
 /* ---------------------------- exported variables (globals) --------------- */
 
 /* ---------------------------- local functions ---------------------------- */
 
 /* ---------------------------- interface functions ------------------------ */
 
 /* Removes decorations from the source rectangle and moves it according to the
  * gravity specification. */
@@ -336,21 +339,22 @@ void get_icon_corner(
 void get_shaded_geometry(
 	FvwmWindow *fw, rectangle *small_g, rectangle *big_g)
 {
 	size_borders b;
 	/* this variable is necessary so the function can be called with
 	 * small_g == big_g */
 	int big_width = big_g->width;
 	int big_height = big_g->height;
 	int d;
 
-	get_window_borders(fw, &b);
+	__get_window_borders(fw, &b, 1);
+	
 	*small_g = *big_g;
 	d = 0;
 	switch (SHADED_DIR(fw))
 	{
 	case DIR_S:
 	case DIR_SW:
 	case DIR_SE:
 		small_g->y = big_g->y + big_height - b.total_size.height;
 		d = 1;
 		/* fall through */
@@ -462,37 +466,52 @@ void get_shaded_client_window_pos(
 		break;
 	}
 
 	return;
 }
 
 /* returns the dimensions of the borders */
 void get_window_borders(
 	const FvwmWindow *fw, size_borders *borders)
 {
+	__get_window_borders(fw, borders, 0);
+}
+
+static void __get_window_borders(
+	const FvwmWindow *fw, size_borders *borders, Bool is_shaded)
+{
+	int title_thickness;
+	
 	borders->top_left.width = fw->boundary_width;
 	borders->bottom_right.width = fw->boundary_width;
 	borders->top_left.height = fw->boundary_width;
 	borders->bottom_right.height = fw->boundary_width;
+
+	title_thickness = fw->title_thickness;
+	if (HAS_TITLE(fw) && HAS_BORDER_UNDER_TITLE(fw) && !is_shaded)
+	{
+		title_thickness += fw->boundary_width;
+	}
+	
 	switch (GET_TITLE_DIR(fw))
 	{
 	case DIR_N:
-		borders->top_left.height += fw->title_thickness;
+		borders->top_left.height += title_thickness;
 		break;
 	case DIR_S:
-		borders->bottom_right.height += fw->title_thickness;
+		borders->bottom_right.height += title_thickness;
 		break;
 	case DIR_W:
-		borders->top_left.width += fw->title_thickness;
+		borders->top_left.width += title_thickness;
 		break;
 	case DIR_E:
-		borders->bottom_right.width += fw->title_thickness;
+		borders->bottom_right.width += title_thickness;
 		break;
 	}
 	borders->total_size.width =
 		borders->top_left.width + borders->bottom_right.width;
 	borders->total_size.height =
 		borders->top_left.height + borders->bottom_right.height;
 
 	return;
 }
 
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/geometry.c~ fvwm-2.5.21-05/fvwm/geometry.c~
--- fvwm-2.5.21-04/fvwm/geometry.c~	1970-01-01 01:00:00.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/geometry.c~	2007-03-03 13:18:42.000000000 +0100
@@ -0,0 +1,1383 @@
+/* -*-c-*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ---------------------------- included header files ---------------------- */
+
+#include "config.h"
+
+#include <stdio.h>
+
+#include "libs/fvwmlib.h"
+#include "libs/charmap.h"
+#include "libs/wcontext.h"
+#include "fvwm.h"
+#include "externs.h"
+#include "execcontext.h"
+#include "misc.h"
+#include "screen.h"
+#include "geometry.h"
+#include "module_interface.h"
+#include "borders.h"
+#include "icons.h"
+#include "add_window.h"
+
+/* ---------------------------- local definitions -------------------------- */
+
+/* ---------------------------- local macros ------------------------------- */
+
+/* ---------------------------- imports ------------------------------------ */
+
+/* ---------------------------- included code files ------------------------ */
+
+/* ---------------------------- local types -------------------------------- */
+
+/* ---------------------------- forward declarations ----------------------- */
+
+/* ---------------------------- local variables ---------------------------- */
+
+/* ---------------------------- exported variables (globals) --------------- */
+
+/* ---------------------------- local functions ---------------------------- */
+
+/* ---------------------------- interface functions ------------------------ */
+
+/* Removes decorations from the source rectangle and moves it according to the
+ * gravity specification. */
+void gravity_get_naked_geometry(
+	int gravity, FvwmWindow *t, rectangle *dest_g, rectangle *orig_g)
+{
+	int xoff;
+	int yoff;
+	size_borders b;
+
+	get_window_borders(t, &b);
+	gravity_get_offsets(gravity, &xoff, &yoff);
+	dest_g->x = orig_g->x + ((xoff + 1) * (orig_g->width - 1)) / 2;
+	dest_g->y = orig_g->y + ((yoff + 1) * (orig_g->height - 1)) / 2;
+	dest_g->width = orig_g->width - b.total_size.width;
+	dest_g->height = orig_g->height - b.total_size.height;
+
+	return;
+}
+
+/* Decorate the rectangle.  Resize and shift it according to gravity. */
+void gravity_add_decoration(
+	int gravity, FvwmWindow *t, rectangle *dest_g, rectangle *orig_g)
+{
+	size_borders b;
+
+	get_window_borders(t, &b);
+	*dest_g = *orig_g;
+	gravity_resize(
+		gravity, dest_g, b.total_size.width, b.total_size.height);
+
+	return;
+}
+
+void get_relative_geometry(rectangle *rel_g, rectangle *abs_g)
+{
+	rel_g->x = abs_g->x - Scr.Vx;
+	rel_g->y = abs_g->y - Scr.Vy;
+	rel_g->width = abs_g->width;
+	rel_g->height = abs_g->height;
+
+	return;
+}
+
+void get_absolute_geometry(rectangle *abs_g, rectangle *rel_g)
+{
+	abs_g->x = rel_g->x + Scr.Vx;
+	abs_g->y = rel_g->y + Scr.Vy;
+	abs_g->width = rel_g->width;
+	abs_g->height = rel_g->height;
+
+	return;
+}
+
+void gravity_translate_to_northwest_geometry(
+	int gravity, FvwmWindow *t, rectangle *dest_g, rectangle *orig_g)
+{
+	int xoff;
+	int yoff;
+
+	gravity_get_offsets(gravity, &xoff, &yoff);
+	dest_g->x = orig_g->x -
+		((xoff + 1) * (orig_g->width - 1 +
+			       2 * t->attr_backup.border_width)) / 2;
+	dest_g->y = orig_g->y -
+		((yoff + 1) * (orig_g->height - 1 +
+			       2 * t->attr_backup.border_width)) / 2;
+	dest_g->width = orig_g->width;
+	dest_g->height = orig_g->height;
+
+	return;
+}
+
+void gravity_translate_to_northwest_geometry_no_bw(
+	int gravity, FvwmWindow *t, rectangle *dest_g, rectangle *orig_g)
+{
+	int bw = t->attr_backup.border_width;
+
+	t->attr_backup.border_width = 0;
+	gravity_translate_to_northwest_geometry(gravity, t, dest_g, orig_g);
+	t->attr_backup.border_width = bw;
+
+	return;
+}
+
+void get_title_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	size_borders b;
+	size_borders nt;
+	int w;
+	int h;
+
+	get_window_borders(fw, &b);
+	get_window_borders_no_title(fw, &nt);
+	w = (ret_g->width > 0) ? ret_g->width : fw->g.frame.width;
+	h = (ret_g->height > 0) ? ret_g->height : fw->g.frame.height;
+	ret_g->x = nt.top_left.width;
+	ret_g->y = nt.top_left.height;
+	switch (GET_TITLE_DIR(fw))
+	{
+	case DIR_S:
+		ret_g->y = h - b.bottom_right.height;
+		/* fall through */
+	case DIR_N:
+		ret_g->width = w - b.total_size.width;
+		ret_g->height = fw->title_thickness;
+		break;
+	case DIR_E:
+		ret_g->x = w - b.bottom_right.width;
+		/* fall through */
+	case DIR_W:
+		ret_g->width = fw->title_thickness;
+		ret_g->height = h - b.total_size.height;
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+void get_title_gravity_factors(
+	FvwmWindow *fw, int *ret_fx, int *ret_fy)
+{
+	switch (GET_TITLE_DIR(fw))
+	{
+	case DIR_N:
+		*ret_fx = 0;
+		*ret_fy = 1;
+		break;
+	case DIR_S:
+		*ret_fx = 0;
+		*ret_fy = -1;
+		break;
+	case DIR_W:
+		*ret_fx = 1;
+		*ret_fy = 0;
+		break;
+	case DIR_E:
+		*ret_fx = -1;
+		*ret_fy = 0;
+		break;
+	}
+
+	return;
+}
+
+Bool get_title_button_geometry(
+	FvwmWindow *fw, rectangle *ret_g, int context)
+{
+	int bnum;
+
+	if (context & C_TITLE)
+	{
+		ret_g->width = 0;
+		ret_g->height = 0;
+		get_title_geometry(fw, ret_g);
+		ret_g->x += fw->g.frame.x;
+		ret_g->y += fw->g.frame.y;
+
+		return True;
+
+	}
+	bnum = get_button_number(context);
+	if (bnum < 0 || FW_W_BUTTON(fw, bnum) == None)
+	{
+		return False;
+	}
+	if (XGetGeometry(
+		dpy, FW_W_BUTTON(fw, bnum), &JunkRoot, &ret_g->x, &ret_g->y,
+		(unsigned int*)&ret_g->width, (unsigned int*)&ret_g->height,
+		(unsigned int*)&JunkBW, (unsigned int*)&JunkDepth) == 0)
+	{
+		return False;
+	}
+	XTranslateCoordinates(
+		dpy, FW_W_FRAME(fw), Scr.Root, ret_g->x, ret_g->y, &ret_g->x,
+		&ret_g->y, &JunkChild);
+
+	return True;
+}
+
+void get_title_font_size_and_offset(
+	FvwmWindow *fw, direction_t title_dir,
+	Bool is_left_title_rotated_cw, Bool is_right_title_rotated_cw,
+	Bool is_top_title_rotated, Bool is_bottom_title_rotated,
+	int *size, int *offset)
+{
+	int decor_size;
+	int extra_size;
+	int font_size;
+	int min_offset;
+	Bool is_rotated_cw, is_rotated;
+	rotation_t draw_rotation;
+
+	/* adjust font offset according to height specified in title style */
+	decor_size = fw->decor->title_height;
+	font_size = fw->title_font->height + EXTRA_TITLE_FONT_HEIGHT;
+	switch (title_dir)
+	{
+	case DIR_W:
+	case DIR_E:
+		is_rotated_cw = (title_dir == DIR_W) ?
+			is_left_title_rotated_cw : is_right_title_rotated_cw;
+		if (is_rotated_cw)
+		{
+			fw->title_text_rotation = ROTATION_90;
+		}
+		else
+		{
+			fw->title_text_rotation = ROTATION_270;
+		}
+		break;
+	case DIR_N:
+	case DIR_S:
+	default:
+		is_rotated = (title_dir == DIR_N) ?
+			is_top_title_rotated : is_bottom_title_rotated;
+		if (is_rotated)
+		{
+			fw->title_text_rotation = ROTATION_180;
+		}
+		else
+		{
+			fw->title_text_rotation = ROTATION_0;
+		}
+		break;
+	}
+	if (USE_TITLE_DECOR_ROTATION(fw))
+	{
+		draw_rotation = ROTATION_0;
+	}
+	else
+	{
+		draw_rotation = fw->title_text_rotation;
+	}
+	min_offset =  FlocaleGetMinOffset(
+		fw->title_font, draw_rotation);
+	extra_size = (decor_size > 0) ? decor_size - font_size : 0;
+	*offset = min_offset;
+	if (fw->decor->min_title_height > 0 &&
+	    font_size + extra_size < fw->decor->min_title_height)
+	{
+		extra_size = fw->decor->min_title_height - font_size;
+	}
+	if (extra_size > 0)
+	{
+		*offset += extra_size / 2;
+	}
+	*size = font_size + extra_size;
+
+	return;
+}
+
+void get_icon_corner(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	switch (GET_TITLE_DIR(fw))
+	{
+	case DIR_N:
+	case DIR_W:
+		ret_g->x = fw->g.frame.x;
+		ret_g->y = fw->g.frame.y;
+		break;
+	case DIR_S:
+		ret_g->x = fw->g.frame.x;
+		ret_g->y = fw->g.frame.y + fw->g.frame.height -
+			ret_g->height;
+		break;
+	case DIR_E:
+		ret_g->x = fw->g.frame.x + fw->g.frame.width -
+			ret_g->width;
+		ret_g->y = fw->g.frame.y;
+		break;
+	}
+
+	return;
+}
+
+void get_shaded_geometry(
+	FvwmWindow *fw, rectangle *small_g, rectangle *big_g)
+{
+	size_borders b;
+	/* this variable is necessary so the function can be called with
+	 * small_g == big_g */
+	int big_width = big_g->width;
+	int big_height = big_g->height;
+	int d;
+
+	get_window_borders(fw, &b);
+	*small_g = *big_g;
+	d = 0;
+	switch (SHADED_DIR(fw))
+	{
+	case DIR_S:
+	case DIR_SW:
+	case DIR_SE:
+		small_g->y = big_g->y + big_height - b.total_size.height;
+		d = 1;
+		/* fall through */
+	case DIR_N:
+	case DIR_NW:
+	case DIR_NE:
+		small_g->height = b.total_size.height;
+		if (small_g->height == 0)
+		{
+			small_g->height = 1;
+			small_g->y -= d;
+		}
+		break;
+	default:
+		break;
+	}
+	d = 0;
+	switch (SHADED_DIR(fw))
+	{
+	case DIR_E:
+	case DIR_NE:
+	case DIR_SE:
+		small_g->x = big_g->x + big_width - b.total_size.width;
+		d = 1;
+		/* fall through */
+	case DIR_W:
+	case DIR_NW:
+	case DIR_SW:
+		small_g->width = b.total_size.width;
+		if (small_g->width == 0)
+		{
+			small_g->width = 1;
+			small_g->x -= d;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+void get_shaded_geometry_with_dir(
+	FvwmWindow *fw, rectangle *small_g, rectangle *big_g,
+	direction_t shade_dir)
+{
+	direction_t old_shade_dir;
+
+	old_shade_dir = SHADED_DIR(fw);
+	SET_SHADED_DIR(fw, shade_dir);
+	get_shaded_geometry(fw, small_g, big_g);
+	SET_SHADED_DIR(fw, old_shade_dir);
+
+	return;
+}
+
+void get_unshaded_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (IS_SHADED(fw))
+	{
+		if (IS_MAXIMIZED(fw))
+		{
+			*ret_g = fw->g.max;
+		}
+		else
+		{
+			*ret_g = fw->g.normal;
+		}
+		get_relative_geometry(ret_g, ret_g);
+	}
+	else
+	{
+		*ret_g = fw->g.frame;
+	}
+
+	return;
+}
+
+void get_shaded_client_window_pos(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	rectangle big_g;
+	size_borders b;
+
+	get_window_borders(fw, &b);
+	big_g = (IS_MAXIMIZED(fw)) ? fw->g.max : fw->g.normal;
+	get_relative_geometry(&big_g, &big_g);
+	switch (SHADED_DIR(fw))
+	{
+	case DIR_S:
+	case DIR_SW:
+	case DIR_SE:
+		ret_g->y = 1 - big_g.height + b.total_size.height;
+		break;
+	default:
+		ret_g->y = 0;
+		break;
+	}
+	switch (SHADED_DIR(fw))
+	{
+	case DIR_E:
+	case DIR_NE:
+	case DIR_SE:
+		ret_g->x = 1 - big_g.width + b.total_size.width;
+		break;
+	default:
+		ret_g->x = 0;
+		break;
+	}
+
+	return;
+}
+
+/* returns the dimensions of the borders */
+void get_window_borders(
+	const FvwmWindow *fw, size_borders *borders)
+{
+	borders->top_left.width = fw->boundary_width;
+	borders->bottom_right.width = fw->boundary_width;
+	borders->top_left.height = fw->boundary_width;
+	borders->bottom_right.height = fw->boundary_width;
+	switch (GET_TITLE_DIR(fw))
+	{
+	case DIR_N:
+		borders->top_left.height += fw->title_thickness;
+		break;
+	case DIR_S:
+		borders->bottom_right.height += fw->title_thickness;
+		break;
+	case DIR_W:
+		borders->top_left.width += fw->title_thickness;
+		break;
+	case DIR_E:
+		borders->bottom_right.width += fw->title_thickness;
+		break;
+	}
+	borders->total_size.width =
+		borders->top_left.width + borders->bottom_right.width;
+	borders->total_size.height =
+		borders->top_left.height + borders->bottom_right.height;
+
+	return;
+}
+
+/* returns the dimensions of the borders without the title */
+void get_window_borders_no_title(
+	const FvwmWindow *fw, size_borders *borders)
+{
+	borders->top_left.width = fw->boundary_width;
+	borders->bottom_right.width = fw->boundary_width;
+	borders->top_left.height = fw->boundary_width;
+	borders->bottom_right.height = fw->boundary_width;
+	borders->total_size.width =
+		borders->top_left.width + borders->bottom_right.width;
+	borders->total_size.height =
+		borders->top_left.height + borders->bottom_right.height;
+
+	return;
+}
+
+void set_window_border_size(
+	FvwmWindow *fw, int used_width)
+{
+	if (used_width <= 0)
+	{
+		fw->boundary_width = 0;
+		fw->unshaped_boundary_width = 0;
+	}
+	else
+	{
+		fw->unshaped_boundary_width = used_width;
+		fw->boundary_width = (fw->wShaped) ? 0 : used_width;
+	}
+
+	return;
+}
+
+/* Returns True if all window borders are only 1 pixel thick (or less). */
+Bool is_window_border_minimal(
+	FvwmWindow *fw)
+{
+	size_borders nt;
+
+	get_window_borders_no_title(fw, &nt);
+	if (nt.top_left.width > 1 || nt.top_left.height > 1 ||
+	    nt.bottom_right.width > 1 || nt.bottom_right.height > 1)
+	{
+		return False;
+	}
+
+	return True;
+}
+
+
+/* This function returns the geometry of the client window.  If the window is
+ * shaded, the unshaded geometry is used instead. */
+void get_client_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	size_borders borders;
+
+	get_unshaded_geometry(fw, ret_g);
+	get_window_borders(fw, &borders);
+	ret_g->x += borders.top_left.width;
+	ret_g->y += borders.top_left.height;
+	ret_g->width -= borders.total_size.width;
+	ret_g->height -= borders.total_size.height;
+
+	return;
+}
+
+/* update the frame_g according to the window's g.normal or g.max and shaded
+ * state */
+void update_relative_geometry(FvwmWindow *fw)
+{
+	get_relative_geometry(
+		&fw->g.frame,
+		(IS_MAXIMIZED(fw)) ? &fw->g.max : &fw->g.normal);
+	if (IS_SHADED(fw))
+	{
+		get_shaded_geometry(
+			fw, &fw->g.frame, &fw->g.frame);
+	}
+
+	return;
+}
+
+/* update the g.normal or g.max according to the window's current position */
+void update_absolute_geometry(FvwmWindow *fw)
+{
+	rectangle *dest_g;
+	rectangle frame_g;
+
+	/* store orig values in absolute coords */
+	dest_g = (IS_MAXIMIZED(fw)) ? &fw->g.max : &fw->g.normal;
+	frame_g = *dest_g;
+	dest_g->x = fw->g.frame.x + Scr.Vx;
+	dest_g->y = fw->g.frame.y + Scr.Vy;
+	dest_g->width = fw->g.frame.width;
+	dest_g->height = fw->g.frame.height;
+	if (IS_SHADED(fw))
+	{
+		switch (SHADED_DIR(fw))
+		{
+		case DIR_SW:
+		case DIR_S:
+		case DIR_SE:
+			dest_g->y += fw->g.frame.height - frame_g.height;
+			/* fall through */
+		case DIR_NW:
+		case DIR_N:
+		case DIR_NE:
+			dest_g->height = frame_g.height;
+			break;
+		}
+		switch (SHADED_DIR(fw))
+		{
+		case DIR_NE:
+		case DIR_E:
+		case DIR_SE:
+			dest_g->x += fw->g.frame.width - frame_g.width;
+			/* fall through */
+		case DIR_NW:
+		case DIR_W:
+		case DIR_SW:
+			dest_g->width = frame_g.width;
+			break;
+		}
+	}
+
+	return;
+}
+
+/* make sure a maximized window and it's normal version are never a page or
+ * more apart. */
+void maximize_adjust_offset(FvwmWindow *fw)
+{
+	int off_x;
+	int off_y;
+	int dh;
+	int dw;
+
+	if (!IS_MAXIMIZED(fw))
+	{
+		/* otherwise we might corrupt the g.normal */
+		return;
+	}
+	off_x = fw->g.normal.x - fw->g.max.x - fw->g.max_offset.x;
+	off_y = fw->g.normal.y - fw->g.max.y - fw->g.max_offset.y;
+	dw = Scr.MyDisplayWidth;
+	dh = Scr.MyDisplayHeight;
+	if (off_x >= dw)
+	{
+		fw->g.normal.x -= (off_x / dw) * dw;
+	}
+	else if (off_x <= -dw)
+	{
+		fw->g.normal.x += (-off_x / dw) * dw;
+	}
+	if (off_y >= dh)
+	{
+		fw->g.normal.y -= (off_y / dh) * dh;
+	}
+	else if (off_y <= -dh)
+	{
+		fw->g.normal.y += (-off_y / dh) * dh;
+	}
+
+	return;
+}
+
+/*
+ *
+ *  Procedure:
+ *      constrain_size - adjust the given width and height to account for the
+ *              constraints imposed by size hints
+ *
+ *      The general algorithm, especially the aspect ratio stuff, is
+ *      borrowed from uwm's CheckConsistency routine.
+ *
+ */
+#define MAKEMULT(a,b) ((b==1) ? (a) : (((int)((a)/(b))) * (b)) )
+void constrain_size(
+	FvwmWindow *fw, const XEvent *e, int *widthp,
+	int *heightp, int xmotion, int ymotion, int flags)
+{
+	int minWidth, minHeight, maxWidth, maxHeight, xinc, yinc, delta;
+	int baseWidth, baseHeight;
+	int dwidth;
+	int dheight;
+	int roundUpX = 0;
+	int roundUpY = 0;
+	int old_w = 0;
+	int old_h = 0;
+	size_borders b;
+
+	if (DO_DISABLE_CONSTRAIN_SIZE_FULLSCREEN(fw) == 1)
+	{
+		return;
+	}
+	if (HAS_NEW_WM_NORMAL_HINTS(fw))
+	{
+		/* get the latest size hints */
+		XSync(dpy, 0);
+		GetWindowSizeHints(fw);
+		SET_HAS_NEW_WM_NORMAL_HINTS(fw, 0);
+	}
+	if (IS_MAXIMIZED(fw) && (flags & CS_UPDATE_MAX_DEFECT))
+	{
+		*widthp += fw->g.max_defect.width;
+		*heightp += fw->g.max_defect.height;
+		old_w = *widthp;
+		old_h = *heightp;
+	}
+	dwidth = *widthp;
+	dheight = *heightp;
+	get_window_borders(fw, &b);
+	dwidth -= b.total_size.width;
+	dheight -= b.total_size.height;
+
+	minWidth = fw->hints.min_width;
+	minHeight = fw->hints.min_height;
+
+	maxWidth = fw->hints.max_width;
+	maxHeight =  fw->hints.max_height;
+
+	if (maxWidth > fw->max_window_width - b.total_size.width)
+	{
+		maxWidth = fw->max_window_width - b.total_size.width;
+	}
+	if (maxHeight > fw->max_window_height - b.total_size.height)
+	{
+		maxHeight =
+			fw->max_window_height - b.total_size.height;
+	}
+
+	baseWidth = fw->hints.base_width;
+	baseHeight = fw->hints.base_height;
+
+	xinc = fw->hints.width_inc;
+	yinc = fw->hints.height_inc;
+
+	/*
+	 * First, clamp to min and max values
+	 */
+	if (dwidth < minWidth)
+	{
+		dwidth = minWidth;
+	}
+	if (dheight < minHeight)
+	{
+		dheight = minHeight;
+	}
+	if (dwidth > maxWidth)
+	{
+		dwidth = maxWidth;
+	}
+	if (dheight > maxHeight)
+	{
+		dheight = maxHeight;
+	}
+
+	/*
+	 * Second, round to base + N * inc (up or down depending on resize type)
+	 * if rounding up store amount
+	 */
+	if (!(flags & CS_ROUND_UP))
+	{
+		dwidth = (((dwidth - baseWidth) / xinc) * xinc) + baseWidth;
+		dheight = (((dheight - baseHeight) / yinc) * yinc) + baseHeight;
+	}
+	else
+	{
+		roundUpX = dwidth;
+		roundUpY = dheight;
+		dwidth = (((dwidth - baseWidth + xinc - 1) / xinc) * xinc) +
+			baseWidth;
+		dheight = (((dheight - baseHeight + yinc - 1) / yinc) * yinc) +
+			baseHeight;
+		roundUpX = dwidth - roundUpX;
+		roundUpY = dheight - roundUpY;
+	}
+
+	/*
+	 * Step 2a: check we didn't move the edge off screen in interactive
+	 * moves
+	 */
+	if ((flags & CS_ROUND_UP) && e != NULL && e->type == MotionNotify)
+	{
+		if (xmotion > 0 && e->xmotion.x_root < roundUpX)
+		{
+			dwidth -= xinc;
+		}
+		else if (xmotion < 0 &&
+			 e->xmotion.x_root >= Scr.MyDisplayWidth - roundUpX)
+		{
+			dwidth -= xinc;
+		}
+		if (ymotion > 0 && e->xmotion.y_root < roundUpY)
+		{
+			dheight -= yinc;
+		}
+		else if (ymotion < 0 &&
+			 e->xmotion.y_root >= Scr.MyDisplayHeight - roundUpY)
+		{
+			dheight -= yinc;
+		}
+	}
+
+	/*
+	 * Step 2b: Check that we didn't violate min and max.
+	 */
+	if (dwidth < minWidth)
+	{
+		dwidth += xinc;
+	}
+	if (dheight < minHeight)
+	{
+		dheight += yinc;
+	}
+	if (dwidth > maxWidth)
+	{
+		dwidth -= xinc;
+	}
+	if (dheight > maxHeight)
+	{
+		dheight -= yinc;
+	}
+
+	/*
+	 * Third, adjust for aspect ratio
+	 */
+#define maxAspectX fw->hints.max_aspect.x
+#define maxAspectY fw->hints.max_aspect.y
+#define minAspectX fw->hints.min_aspect.x
+#define minAspectY fw->hints.min_aspect.y
+	/*
+	 * The math looks like this:
+	 *
+	 * minAspectX    dwidth     maxAspectX
+	 * ---------- <= ------- <= ----------
+	 * minAspectY    dheight    maxAspectY
+	 *
+	 * If that is multiplied out, then the width and height are
+	 * invalid in the following situations:
+	 *
+	 * minAspectX * dheight > minAspectY * dwidth
+	 * maxAspectX * dheight < maxAspectY * dwidth
+	 *
+	 */
+
+	if (fw->hints.flags & PAspect)
+	{
+		double odefect;
+		double defect;
+		double maxratio;
+		double minratio;
+		int ow;
+		int oh;
+
+		if (fw->hints.flags & PBaseSize)
+		{
+			/*
+			 * ICCCM 2 demands that aspect ratio should apply
+			 * to width - base_width. To prevent funny results,
+			 * we reset PBaseSize in GetWindowSizeHints, if
+			 * base is not smaller than min.
+			*/
+			dwidth -= baseWidth;
+			maxWidth -= baseWidth;
+			minWidth -= baseWidth;
+			dheight -= baseHeight;
+			maxHeight -= baseHeight;
+			minHeight -= baseHeight;
+		}
+		minratio = (double)minAspectX / (double)minAspectY;
+		maxratio = (double)maxAspectX / (double)maxAspectY;
+		do
+		{
+			ow = dwidth;
+			oh = dheight;
+			odefect = 0;
+			if (minAspectX * dheight > minAspectY * dwidth)
+			{
+				odefect =
+					minratio -
+					(double)dwidth / (double)dheight;
+			}
+			else if (maxAspectX * dheight < maxAspectY * dwidth)
+			{
+				odefect = (double)dwidth / (double)dheight -
+					maxratio;
+			}
+			if (
+				minAspectX * dheight > minAspectY * dwidth &&
+				xmotion == 0)
+			{
+				/* Change width to match */
+				delta = MAKEMULT(
+					minAspectX * dheight / minAspectY -
+					dwidth, xinc);
+				if (dwidth + delta <= maxWidth)
+				{
+					dwidth += delta;
+				}
+			}
+			if (minAspectX * dheight > minAspectY * dwidth)
+			{
+				delta = MAKEMULT(
+					dheight -
+					dwidth * minAspectY / minAspectX,
+					yinc);
+				if (dheight - delta >= minHeight)
+				{
+					dheight -= delta;
+				}
+				else
+				{
+					delta = MAKEMULT(
+						minAspectX * dheight /
+						minAspectY - dwidth, xinc);
+					if (dwidth + delta <= maxWidth)
+					{
+						dwidth += delta;
+					}
+				}
+			}
+
+			if (
+				maxAspectX * dheight < maxAspectY * dwidth &&
+				ymotion == 0)
+			{
+				delta = MAKEMULT(
+					dwidth * maxAspectY / maxAspectX -
+					dheight, yinc);
+				if (dheight + delta <= maxHeight)
+				{
+					dheight += delta;
+				}
+			}
+			if ((maxAspectX * dheight < maxAspectY * dwidth))
+			{
+				delta = MAKEMULT(
+					dwidth - maxAspectX*dheight/maxAspectY,
+					xinc);
+				if (dwidth - delta >= minWidth)
+				{
+					dwidth -= delta;
+				}
+				else
+				{
+					delta = MAKEMULT(
+						dwidth * maxAspectY /
+						maxAspectX - dheight, yinc);
+					if (dheight + delta <= maxHeight)
+					{
+						dheight += delta;
+					}
+				}
+			}
+			defect = 0;
+			if (minAspectX * dheight > minAspectY * dwidth)
+			{
+				defect =
+					minratio -
+					(double)dwidth / (double)dheight;
+			}
+			else if (maxAspectX * dheight < maxAspectY * dwidth)
+			{
+				defect =
+					(double)dwidth / (double)dheight -
+					maxratio;
+			}
+		} while (odefect > defect);
+		dwidth = ow;
+		dheight = oh;
+		if (fw->hints.flags & PBaseSize)
+		{
+			dwidth += baseWidth;
+			dheight += baseHeight;
+		}
+	}
+
+	/*
+	 * Fourth, account for border width and title height
+	 */
+	*widthp = dwidth + b.total_size.width;
+	*heightp = dheight + b.total_size.height;
+	if (IS_MAXIMIZED(fw) && (flags & CS_UPDATE_MAX_DEFECT))
+	{
+		/* update size defect for maximized window */
+		fw->g.max_defect.width = old_w - *widthp;
+		fw->g.max_defect.height = old_h - *heightp;
+	}
+
+	return;
+}
+
+/* This function does roughly the same as constrain_size, but takes into account
+ * that the window shifts according to gravity if constrain_size actually
+ * changes the width or height. The frame_g of the window is not changed. The
+ * target geometry is expected to be in *rect and will be retured through rect.
+ */
+void gravity_constrain_size(
+	int gravity, FvwmWindow *t, rectangle *rect, int flags)
+{
+	int new_width = rect->width;
+	int new_height = rect->height;
+
+	if (IS_MAXIMIZED(t) && (flags & CS_UPDATE_MAX_DEFECT))
+	{
+		gravity_resize(
+			gravity, rect, t->g.max_defect.width,
+			t->g.max_defect.height);
+		t->g.max_defect.width = 0;
+		t->g.max_defect.height = 0;
+		new_width = rect->width;
+		new_height = rect->height;
+	}
+	constrain_size(
+		t, NULL, &new_width, &new_height, 0, 0, flags);
+	if (rect->width != new_width || rect->height != new_height)
+	{
+		gravity_resize(
+			gravity, rect, new_width - rect->width,
+			new_height - rect->height);
+	}
+
+	return;
+}
+
+/* returns the icon title geometry if it is visible */
+Bool get_visible_icon_title_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (HAS_NO_ICON_TITLE(fw) || IS_ICON_UNMAPPED(fw) ||
+	    !IS_ICONIFIED(fw))
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+		return False;
+	}
+	*ret_g = fw->icon_g.title_w_g;
+
+	return True;
+}
+
+/* returns the icon title geometry if it the icon title window exists */
+Bool get_icon_title_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (HAS_NO_ICON_TITLE(fw))
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+		return False;
+	}
+	*ret_g = fw->icon_g.title_w_g;
+
+	return True;
+}
+
+/* returns the icon picture geometry if it is visible */
+Bool get_visible_icon_picture_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (fw->icon_g.picture_w_g.width == 0 ||
+	    IS_ICON_UNMAPPED(fw) || !IS_ICONIFIED(fw))
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+		return False;
+	}
+	*ret_g = fw->icon_g.picture_w_g;
+
+	return True;
+}
+
+/* returns the icon picture geometry if it is exists */
+Bool get_icon_picture_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (fw->icon_g.picture_w_g.width == 0)
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+		return False;
+	}
+	*ret_g = fw->icon_g.picture_w_g;
+
+	return True;
+}
+
+/* returns the icon geometry (unexpanded title plus pixmap) if it is visible */
+Bool get_visible_icon_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (IS_ICON_UNMAPPED(fw) || !IS_ICONIFIED(fw))
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+		return False;
+	}
+	if (fw->icon_g.picture_w_g.width > 0)
+	{
+		*ret_g = fw->icon_g.picture_w_g;
+		if (!HAS_NO_ICON_TITLE(fw))
+		{
+			ret_g->height += fw->icon_g.title_w_g.height;
+		}
+	}
+	else if (!HAS_NO_ICON_TITLE(fw))
+	{
+		*ret_g = fw->icon_g.title_w_g;
+	}
+	else
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+		return False;
+	}
+
+	return True;
+}
+
+/* returns the icon geometry (unexpanded title plus pixmap) if it exists */
+void get_icon_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	/* valid geometry? */
+	if (fw->icon_g.picture_w_g.width > 0)
+	{
+		*ret_g = fw->icon_g.picture_w_g;
+		if (!HAS_NO_ICON_TITLE(fw))
+		{
+			ret_g->height += fw->icon_g.title_w_g.height;
+		}
+	}
+	else if (fw->icon_g.title_w_g.width > 0)
+	{
+		*ret_g = fw->icon_g.title_w_g;
+	}
+	/* valid position? */
+	else if (fw->icon_g.picture_w_g.x != 0 || fw->icon_g.picture_w_g.y != 0)
+	{
+		*ret_g = fw->icon_g.picture_w_g;
+	}
+	else if (fw->icon_g.title_w_g.x != 0 || fw->icon_g.title_w_g.y != 0)
+	{
+		*ret_g = fw->icon_g.title_w_g;
+	}
+	else
+	{
+		memset(ret_g, 0, sizeof(*ret_g));
+	}
+
+	return;
+}
+
+/* Returns the visible geometry of a window or icon.  This can be used to test
+ * if this region overlaps other windows. */
+Bool get_visible_window_or_icon_geometry(
+	FvwmWindow *fw, rectangle *ret_g)
+{
+	if (IS_ICONIFIED(fw))
+	{
+		return get_visible_icon_geometry(fw, ret_g);
+	}
+	*ret_g = fw->g.frame;
+
+	return True;
+}
+
+void move_icon_to_position(
+	FvwmWindow *fw)
+{
+	Bool draw_picture_w = False;
+	Bool draw_title_w = False;
+
+	if (fw->icon_g.picture_w_g.width > 0)
+	{
+		int cs;
+
+		if (Scr.Hilite == fw)
+		{
+			cs = fw->cs_hi;
+		}
+		else
+		{
+			cs = fw->cs;
+		}
+		XMoveWindow(
+			dpy, FW_W_ICON_PIXMAP(fw),
+			fw->icon_g.picture_w_g.x,
+			fw->icon_g.picture_w_g.y);
+		if (fw->icon_alphaPixmap ||
+		    (cs >= 0 && Colorset[cs].icon_alpha_percent < 100) ||
+		    CSET_IS_TRANSPARENT(fw->icon_background_cs) ||
+		    (!IS_ICON_SHAPED(fw) && fw->icon_background_padding > 0))
+		{
+			draw_picture_w = True;
+		}
+	}
+	if (!HAS_NO_ICON_TITLE(fw))
+	{
+		int cs;
+		rectangle dummy;
+
+		if (Scr.Hilite == fw)
+		{
+			cs = fw->icon_title_cs_hi;
+		}
+		else
+		{
+			cs = fw->icon_title_cs;
+		}
+		XMoveWindow(
+			dpy, FW_W_ICON_TITLE(fw),
+			fw->icon_g.title_w_g.x,
+			fw->icon_g.title_w_g.y);
+		if (CSET_IS_TRANSPARENT(cs) &&
+		    !get_visible_icon_picture_geometry(fw, &dummy) &&
+		    get_visible_icon_title_geometry(fw, &dummy))
+		{
+			draw_title_w = True;
+		}
+	}
+
+	if (draw_title_w || draw_picture_w)
+	{
+		DrawIconWindow(
+			fw, draw_title_w, draw_picture_w, False, draw_picture_w,
+			NULL);
+	}
+
+	return;
+}
+
+void broadcast_icon_geometry(
+	FvwmWindow *fw, Bool do_force)
+{
+	rectangle g;
+	Bool rc;
+
+	rc = get_visible_icon_geometry(fw, &g);
+	if (rc == True && (!IS_ICON_UNMAPPED(fw) || do_force == True))
+	{
+		BroadcastPacket(
+			M_ICON_LOCATION, 7, (long)FW_W(fw),
+			(long)FW_W_FRAME(fw), (unsigned long)fw,
+			(long)g.x, (long)g.y, (long)g.width, (long)g.height);
+	}
+
+	return;
+}
+
+void modify_icon_position(
+	FvwmWindow *fw, int dx, int dy)
+{
+	if (fw->icon_g.picture_w_g.width > 0 || HAS_NO_ICON_TITLE(fw))
+	{
+		/* picture position is also valid if there is neither a picture
+		 * nor a title */
+		fw->icon_g.picture_w_g.x += dx;
+		fw->icon_g.picture_w_g.y += dy;
+	}
+	if (!HAS_NO_ICON_TITLE(fw))
+	{
+		fw->icon_g.title_w_g.x += dx;
+		fw->icon_g.title_w_g.y += dy;
+	}
+
+	return;
+}
+
+/* set the icon position to the specified value. take care of the actual icon
+ * layout */
+void set_icon_position(
+	FvwmWindow *fw, int x, int y)
+{
+	if (fw->icon_g.picture_w_g.width > 0)
+	{
+		fw->icon_g.picture_w_g.x = x;
+		fw->icon_g.picture_w_g.y = y;
+	}
+	else
+	{
+		fw->icon_g.picture_w_g.x = 0;
+		fw->icon_g.picture_w_g.y = 0;
+	}
+	if (!HAS_NO_ICON_TITLE(fw))
+	{
+		fw->icon_g.title_w_g.x = x;
+		fw->icon_g.title_w_g.y = y;
+	}
+	else
+	{
+		fw->icon_g.title_w_g.x = 0;
+		fw->icon_g.title_w_g.y = 0;
+	}
+	if (fw->icon_g.picture_w_g.width > 0 &&
+	    !HAS_NO_ICON_TITLE(fw))
+	{
+		fw->icon_g.title_w_g.x -=
+			(fw->icon_g.title_w_g.width -
+			 fw->icon_g.picture_w_g.width) / 2;
+		fw->icon_g.title_w_g.y +=
+			fw->icon_g.picture_w_g.height;
+	}
+	else if (fw->icon_g.picture_w_g.width <= 0 && HAS_NO_ICON_TITLE(fw))
+	{
+		/* In case there is no icon, fake the icon position so the
+		 * modules know where its window was iconified. */
+		fw->icon_g.picture_w_g.x = x;
+		fw->icon_g.picture_w_g.y = y;
+	}
+
+	return;
+}
+
+void set_icon_picture_size(
+	FvwmWindow *fw, int w, int h)
+{
+	if (fw->icon_g.picture_w_g.width > 0)
+	{
+		fw->icon_g.picture_w_g.width = w;
+		fw->icon_g.picture_w_g.height = h;
+	}
+	else
+	{
+		fw->icon_g.picture_w_g.width = 0;
+		fw->icon_g.picture_w_g.height = 0;
+	}
+
+	return;
+}
+
+void resize_icon_title_height(FvwmWindow *fw, int dh)
+{
+	if (!HAS_NO_ICON_TITLE(fw))
+	{
+		fw->icon_g.title_w_g.height += dh;
+	}
+
+	return;
+}
+
+void get_page_offset_rectangle(
+	int *ret_page_x, int *ret_page_y, rectangle *r)
+{
+	int xoff = Scr.Vx % Scr.MyDisplayWidth;
+	int yoff = Scr.Vy % Scr.MyDisplayHeight;
+
+	/* maximize on the page where the center of the window is */
+	*ret_page_x = truncate_to_multiple(
+		r->x + r->width / 2 + xoff, Scr.MyDisplayWidth) - xoff;
+	*ret_page_y = truncate_to_multiple(
+		r->y + r->height / 2 + yoff, Scr.MyDisplayHeight) - yoff;
+
+	return;
+}
+
+void get_page_offset(
+	int *ret_page_x, int *ret_page_y, FvwmWindow *fw)
+{
+	rectangle r;
+
+	r.x = fw->g.frame.x;
+	r.y = fw->g.frame.y;
+	r.width = fw->g.frame.width;
+	r.height = fw->g.frame.height;
+	get_page_offset_rectangle(ret_page_x, ret_page_y, &r);
+
+	return;
+}
+
+void get_page_offset_check_visible(
+	int *ret_page_x, int *ret_page_y, FvwmWindow *fw)
+{
+	if (IsRectangleOnThisPage(&fw->g.frame, fw->Desk))
+	{
+		/* maximize on visible page if any part of the window is
+		 * visible */
+		*ret_page_x = 0;
+		*ret_page_y = 0;
+	}
+	else
+	{
+		get_page_offset(ret_page_x, ret_page_y, fw);
+	}
+
+	return;
+}
+
+/* ---------------------------- builtin commands --------------------------- */
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/geometry.h fvwm-2.5.21-05/fvwm/geometry.h
--- fvwm-2.5.21-04/fvwm/geometry.h	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/geometry.h	2007-03-03 13:18:49.000000000 +0100
@@ -37,20 +37,22 @@ void get_shaded_geometry_with_dir(
 	FvwmWindow *fw, rectangle *small_g, rectangle *big_g,
 	direction_t shade_dir);
 void get_unshaded_geometry(
 	FvwmWindow *fw, rectangle *ret_g);
 void get_shaded_client_window_pos(
 	FvwmWindow *fw, rectangle *ret_g);
 void get_client_geometry(
 	FvwmWindow *fw, rectangle *ret_g);
 void get_window_borders(
 	const FvwmWindow *fw, size_borders *borders);
+void get_window_borders_shaded(
+	const FvwmWindow *fw, size_borders *borders);
 void get_window_borders_no_title(
 	const FvwmWindow *fw, size_borders *borders);
 void set_window_border_size(
 	FvwmWindow *fw, int used_width);
 Bool is_window_border_minimal(
 	FvwmWindow *fw);
 void update_relative_geometry(FvwmWindow *fw);
 void update_absolute_geometry(FvwmWindow *fw);
 void maximize_adjust_offset(FvwmWindow *fw);
 void constrain_size(
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/style.c fvwm-2.5.21-05/fvwm/style.c
--- fvwm-2.5.21-04/fvwm/style.c	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/style.c	2007-03-03 13:18:49.000000000 +0100
@@ -2044,20 +2044,26 @@ static Bool style_parse_one_style_option
 				fvwm_msg(
 					ERR, "style_parse_on_estyle_option",
 					"Style BackColor requires color"
 					" argument");
 			}
 		}
 		else if (StrEquals(token, "Button"))
 		{
 			rest = style_parse_button_style(ps, rest, on);
 		}
+		else if (StrEquals(token, "BORDERUNDERTITLE"))
+		{
+			S_SET_HAS_BORDER_UNDER_TITLE(SCF(*ps), on);
+			S_SET_HAS_BORDER_UNDER_TITLE(SCM(*ps), 1);
+			S_SET_HAS_BORDER_UNDER_TITLE(SCC(*ps), 1);
+		}
 		else if (StrEquals(token, "BorderWidth"))
 		{
 			if (GetIntegerArguments(rest, &rest, val, 1))
 			{
 				SSET_BORDER_WIDTH(*ps, (short)*val);
 				ps->flags.has_border_width = 1;
 				ps->flag_mask.has_border_width = 1;
 				ps->change_mask.has_border_width = 1;
 			}
 			else
@@ -4413,20 +4419,25 @@ void check_window_style_change(
 	if (S_TITLE_DIR(SCC(*ret_style)))
 	{
 		flags->do_update_title_dir = 1;
 	}
 
 	/* use_title_decor_rotation */
 	if (S_USE_TITLE_DECOR_ROTATION(SCC(*ret_style)))
 	{
 		flags->do_update_rotated_title = 1;
 	}
+	
+	if (S_HAS_BORDER_UNDER_TITLE(SCC(*ret_style)))
+	{
+		flags->do_redecorate = True;
+	}
 
 	/* has_mwm_border
 	 * has_mwm_buttons */
 	if (S_HAS_MWM_BORDER(SCC(*ret_style)) ||
 	    S_HAS_MWM_BUTTONS(SCC(*ret_style)))
 	{
 		flags->do_redecorate = 1;
 	}
 
 	/* has_icon_font */
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/style.c~ fvwm-2.5.21-05/fvwm/style.c~
--- fvwm-2.5.21-04/fvwm/style.c~	1970-01-01 01:00:00.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/style.c~	2007-03-03 13:18:42.000000000 +0100
@@ -0,0 +1,5168 @@
+/* -*-c-*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This module was all original code
+ * by Rob Nation
+ * Copyright 1993, Robert Nation
+ *     You may use this code for any purpose, as long as the original
+ *     copyright remains in the source code and all documentation
+ */
+
+/* code for parsing the fvwm style command */
+
+/* ---------------------------- included header files ---------------------- */
+
+#include "config.h"
+#include <stdio.h>
+
+#include "libs/fvwmlib.h"
+#include "libs/FScreen.h"
+#include "libs/charmap.h"
+#include "libs/modifiers.h"
+#include "fvwm.h"
+#include "execcontext.h"
+#include "misc.h"
+#include "screen.h"
+#include "update.h"
+#include "style.h"
+#include "colorset.h"
+#include "ewmh.h"
+#include "gnome.h"
+
+/* ---------------------------- local definitions -------------------------- */
+
+#define SAFEFREE( p )  {if (p) {free(p);(p)=NULL;}}
+
+/* ---------------------------- local macros ------------------------------- */
+
+/* ---------------------------- imports ------------------------------------ */
+
+/* ---------------------------- included code files ------------------------ */
+
+/* ---------------------------- local types -------------------------------- */
+
+/* ---------------------------- forward declarations ----------------------- */
+
+/* ---------------------------- local variables ---------------------------- */
+
+/* list of window names with attributes */
+static window_style *all_styles = NULL;
+static window_style *last_style_in_list = NULL;
+
+/* ---------------------------- exported variables (globals) --------------- */
+
+/* ---------------------------- local functions ---------------------------- */
+
+static int blockor(char *dest, char *blk1, char *blk2, int length)
+{
+	int i;
+	char result = 0;
+
+	for (i = 0; i < length; i++)
+	{
+		dest[i] = (blk1[i] | blk2[i]);
+		result |= dest[i];
+	}
+
+	return (result) ? 1 : 0;
+}
+
+static int blockand(char *dest, char *blk1, char *blk2, int length)
+{
+	int i;
+	char result = 0;
+
+	for (i = 0; i < length; i++)
+	{
+		dest[i] = (blk1[i] & blk2[i]);
+		result |= dest[i];
+	}
+
+	return (result) ? 1 : 0;
+}
+
+static int blockunmask(char *dest, char *blk1, char *blk2, int length)
+{
+	int i;
+	char result = (char)0xff;
+
+	for (i = 0; i < length; i++)
+	{
+		dest[i] = (blk1[i] & ~blk2[i]);
+		result |= dest[i];
+	}
+
+	return (result) ? 1 : 0;
+}
+
+static int blockissubset(char *sub, char *super, int length)
+{
+	int i;
+
+	for (i = 0; i < length; i++)
+	{
+		if ((sub[i] & super[i]) != sub[i])
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int blocksintersect(char *blk1, char *blk2, int length)
+{
+	int i;
+
+	for (i = 0; i < length; i++)
+	{
+		if (blk1[i] & blk2[i])
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int style_ids_are_equal(style_id_t *a, style_id_t *b)
+{
+	if (
+		SID_GET_HAS_NAME(*a) && SID_GET_HAS_NAME(*b) &&
+		!strcmp(SID_GET_NAME(*a), SID_GET_NAME(*b)))
+	{
+		return 1;
+	}
+	if (
+		SID_GET_HAS_WINDOW_ID(*a) && SID_GET_HAS_WINDOW_ID(*b) &&
+		SID_GET_WINDOW_ID(*a) == SID_GET_WINDOW_ID(*b))
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+static int style_id_equals_id(window_style *s, style_id_t* id)
+{
+	return style_ids_are_equal(&SGET_ID(*s), id);
+}
+
+static int styles_have_same_id(window_style* s, window_style* t)
+{
+	return style_ids_are_equal(&SGET_ID(*s), &SGET_ID(*t));
+}
+
+static int fw_match_style_id(FvwmWindow *fw, style_id_t s_id)
+{
+	if (SID_GET_HAS_NAME(s_id))
+	{
+		if (matchWildcards(SID_GET_NAME(s_id), fw->class.res_class) ==
+		    1)
+		{
+			return 1;
+		}
+		if (matchWildcards(SID_GET_NAME(s_id), fw->class.res_name) ==
+		    1)
+		{
+			return 1;
+		}
+		if (matchWildcards(SID_GET_NAME(s_id), fw->name.name) == 1)
+		{
+			return 1;
+		}
+		if (fw->style_name == NULL &&
+		    matchWildcards(SID_GET_NAME(s_id), fw->style_name) == 1)
+		{
+			return 1;
+		}
+	}
+	if (SID_GET_HAS_WINDOW_ID(s_id) &&
+	    SID_GET_WINDOW_ID(s_id) == (XID)FW_W(fw))
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+static int one_fw_can_match_both_ids(window_style *s, window_style *t)
+{
+	if (SGET_ID_HAS_WINDOW_ID(*s) && SGET_ID_HAS_WINDOW_ID(*t) &&
+	    SGET_WINDOW_ID(*s) != SGET_WINDOW_ID(*t))
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+static void remove_icon_boxes_from_style(window_style *pstyle)
+{
+	if (SHAS_ICON_BOXES(&pstyle->flags))
+	{
+		free_icon_boxes(SGET_ICON_BOXES(*pstyle));
+		pstyle->flags.has_icon_boxes = 0;
+		SSET_ICON_BOXES(*pstyle, NULL);
+	}
+
+	return;
+}
+
+static void copy_icon_boxes(icon_boxes **pdest, icon_boxes *src)
+{
+	icon_boxes *last = NULL;
+	icon_boxes *temp;
+
+	*pdest = NULL;
+	/* copy the icon boxes */
+	for ( ; src != NULL; src = src->next)
+	{
+		temp = (icon_boxes *)safemalloc(sizeof(icon_boxes));
+		memcpy(temp, src, sizeof(icon_boxes));
+		temp->next = NULL;
+		if (last != NULL)
+			last->next = temp;
+		else
+			*pdest = temp;
+		last = temp;
+	}
+}
+
+/* Check word after IconFill to see if its "Top,Bottom,Left,Right" */
+static int Get_TBLR(char *token, unsigned char *IconFill)
+{
+	/* init */
+	if (StrEquals(token, "B") ||
+	    StrEquals(token, "BOT")||
+	    StrEquals(token, "BOTTOM"))
+	{
+		/* turn on bottom and verical */
+		*IconFill = ICONFILLBOT | ICONFILLHRZ;
+	}
+	else if (StrEquals(token, "T") ||
+		 StrEquals(token, "TOP"))
+	{
+		/* turn on vertical */
+		*IconFill = ICONFILLHRZ;
+	}
+	else if (StrEquals(token, "R") ||
+		 StrEquals(token, "RGT") ||
+		 StrEquals(token, "RIGHT"))
+	{
+		/* turn on right bit */
+		*IconFill = ICONFILLRGT;
+	}
+	else if (StrEquals(token, "L") ||
+		 StrEquals(token, "LFT") ||
+		 StrEquals(token, "LEFT"))
+	{
+		*IconFill = 0;
+	}
+	else
+	{
+		/* anything else is bad */
+		return 0;
+	}
+
+	/* return OK */
+	return 1;
+}
+
+static void cleanup_style_defaults(window_style *style)
+{
+	int i;
+	char *dflt;
+	char *mask;
+
+	mask = (char *)&(style->flag_mask);
+	dflt = (char *)&(style->flag_default);
+	for (i = 0; i < sizeof(style_flags); i++)
+	{
+		dflt[i] &= ~mask[i];
+	}
+
+	return;
+}
+
+/* merge_styles - For a matching style, merge window_style to window_style
+ *
+ *  Returned Value:
+ *	merged matching styles in callers window_style.
+ *
+ *  Inputs:
+ *	merged_style - style resulting from the merge
+ *	add_style    - the style to be added into the merge_style
+ *	do_free_src_and_alloc_copy
+ *		     - free allocated parts of merge_style that are replaced
+ *		       from add_style.	Create a copy of of the replaced
+ *		       styles in allocated memory.
+ *
+ *  Note:
+ *	The only trick here is that on and off flags/buttons are
+ *	combined into the on flag/button. */
+static void merge_styles(
+	window_style *merged_style, window_style *add_style,
+	Bool do_free_src_and_alloc_copy)
+{
+	int i;
+	char *merge_flags;
+	char *add_flags;
+	char *merge_mask;
+	char *add_mask;
+	char *merge_dflt;
+	char *add_dflt;
+	char *merge_change_mask;
+	char *add_change_mask;
+
+	if (add_style->flag_mask.has_icon)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_ICON_NAME(*merged_style));
+			SSET_ICON_NAME(
+				*merged_style, (SGET_ICON_NAME(*add_style)) ?
+				safestrdup(SGET_ICON_NAME(*add_style)) : NULL);
+		}
+		else
+		{
+			SSET_ICON_NAME(
+				*merged_style, SGET_ICON_NAME(*add_style));
+		}
+	}
+	if (FMiniIconsSupported && add_style->flag_mask.has_mini_icon)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_MINI_ICON_NAME(*merged_style));
+			SSET_MINI_ICON_NAME(
+				*merged_style,
+				(SGET_MINI_ICON_NAME(*add_style)) ?
+				safestrdup(SGET_MINI_ICON_NAME(*add_style)) :
+				NULL);
+		}
+		else
+		{
+			SSET_MINI_ICON_NAME(
+				*merged_style, SGET_MINI_ICON_NAME(*add_style));
+		}
+	}
+#ifdef USEDECOR
+	if (add_style->flag_mask.has_decor)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_DECOR_NAME(*merged_style));
+			SSET_DECOR_NAME(
+				*merged_style, (SGET_DECOR_NAME(*add_style)) ?
+				safestrdup(SGET_DECOR_NAME(*add_style)) : NULL);
+		}
+		else
+		{
+			SSET_DECOR_NAME(
+				*merged_style, SGET_DECOR_NAME(*add_style));
+		}
+	}
+#endif
+	if (S_HAS_ICON_FONT(SCF(*add_style)))
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_ICON_FONT(*merged_style));
+			SSET_ICON_FONT(
+				*merged_style, (SGET_ICON_FONT(*add_style)) ?
+				safestrdup(SGET_ICON_FONT(*add_style)) : NULL);
+		}
+		else
+		{
+			SSET_ICON_FONT(
+				*merged_style, SGET_ICON_FONT(*add_style));
+		}
+	}
+	if (S_HAS_WINDOW_FONT(SCF(*add_style)))
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_WINDOW_FONT(*merged_style));
+			SSET_WINDOW_FONT(
+				*merged_style, (SGET_WINDOW_FONT(*add_style)) ?
+				safestrdup(SGET_WINDOW_FONT(*add_style)) :
+				NULL);
+		}
+		else
+		{
+			SSET_WINDOW_FONT(
+				*merged_style, SGET_WINDOW_FONT(*add_style));
+		}
+	}
+	if (add_style->flags.use_start_on_desk)
+	{
+		SSET_START_DESK(*merged_style, SGET_START_DESK(*add_style));
+		SSET_START_PAGE_X(
+			*merged_style, SGET_START_PAGE_X(*add_style));
+		SSET_START_PAGE_Y(
+			*merged_style, SGET_START_PAGE_Y(*add_style));
+	}
+	if (add_style->flags.use_start_on_screen)
+	{
+		SSET_START_SCREEN
+			(*merged_style, SGET_START_SCREEN(*add_style));
+	}
+	if (add_style->flag_mask.has_color_fore)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_FORE_COLOR_NAME(*merged_style));
+			SSET_FORE_COLOR_NAME(
+				*merged_style,
+				(SGET_FORE_COLOR_NAME(*add_style)) ?
+				safestrdup(SGET_FORE_COLOR_NAME(*add_style)) :
+				NULL);
+		}
+		else
+		{
+			SSET_FORE_COLOR_NAME(
+				*merged_style,
+				SGET_FORE_COLOR_NAME(*add_style));
+		}
+	}
+	if (add_style->flag_mask.has_color_back)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_BACK_COLOR_NAME(*merged_style));
+			SSET_BACK_COLOR_NAME(
+				*merged_style,
+				(SGET_BACK_COLOR_NAME(*add_style)) ?
+				safestrdup(SGET_BACK_COLOR_NAME(*add_style)) :
+				NULL);
+		}
+		else
+		{
+			SSET_BACK_COLOR_NAME(
+				*merged_style,
+				SGET_BACK_COLOR_NAME(*add_style));
+		}
+	}
+	if (add_style->flag_mask.has_color_fore_hi)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_FORE_COLOR_NAME_HI(*merged_style));
+			SSET_FORE_COLOR_NAME_HI(
+				*merged_style,
+				(SGET_FORE_COLOR_NAME_HI(*add_style)) ?
+				safestrdup(
+					SGET_FORE_COLOR_NAME_HI(*add_style)) :
+				NULL);
+		}
+		else
+		{
+			SSET_FORE_COLOR_NAME_HI(
+				*merged_style,
+				SGET_FORE_COLOR_NAME_HI(*add_style));
+		}
+	}
+	if (add_style->flag_mask.has_color_back_hi)
+	{
+		if (do_free_src_and_alloc_copy)
+		{
+			SAFEFREE(SGET_BACK_COLOR_NAME_HI(*merged_style));
+			SSET_BACK_COLOR_NAME_HI(
+				*merged_style,
+				(SGET_BACK_COLOR_NAME_HI(*add_style)) ?
+				safestrdup(
+					SGET_BACK_COLOR_NAME_HI(*add_style)) :
+				NULL);
+		}
+		else
+		{
+			SSET_BACK_COLOR_NAME_HI(
+				*merged_style,
+				SGET_BACK_COLOR_NAME_HI(*add_style));
+		}
+	}
+	if (add_style->flags.has_border_width)
+	{
+		SSET_BORDER_WIDTH(*merged_style, SGET_BORDER_WIDTH(*add_style));
+	}
+	if (add_style->flags.has_handle_width)
+	{
+		SSET_HANDLE_WIDTH(*merged_style, SGET_HANDLE_WIDTH(*add_style));
+	}
+	if (add_style->flags.has_icon_size_limits)
+	{
+		SSET_MIN_ICON_WIDTH(
+			*merged_style, SGET_MIN_ICON_WIDTH(*add_style));
+		SSET_MIN_ICON_HEIGHT(
+			*merged_style, SGET_MIN_ICON_HEIGHT(*add_style));
+		SSET_MAX_ICON_WIDTH(
+			*merged_style, SGET_MAX_ICON_WIDTH(*add_style));
+		SSET_MAX_ICON_HEIGHT(
+			*merged_style, SGET_MAX_ICON_HEIGHT(*add_style));
+		SSET_ICON_RESIZE_TYPE(
+			*merged_style, SGET_ICON_RESIZE_TYPE(*add_style));
+	}
+	if (add_style->flags.has_max_window_size)
+	{
+		SSET_MAX_WINDOW_WIDTH(
+			*merged_style, SGET_MAX_WINDOW_WIDTH(*add_style));
+		SSET_MAX_WINDOW_HEIGHT(
+			*merged_style, SGET_MAX_WINDOW_HEIGHT(*add_style));
+	}
+	if (add_style->flags.has_icon_background_relief)
+	{
+		SSET_ICON_BACKGROUND_RELIEF(
+			*merged_style, SGET_ICON_BACKGROUND_RELIEF(*add_style));
+	}
+	if (add_style->flags.has_icon_background_padding)
+	{
+		SSET_ICON_BACKGROUND_PADDING(
+			*merged_style, SGET_ICON_BACKGROUND_PADDING(*add_style));
+	}
+	if (add_style->flags.has_icon_title_relief)
+	{
+		SSET_ICON_TITLE_RELIEF(
+			*merged_style, SGET_ICON_TITLE_RELIEF(*add_style));
+	}
+	if (add_style->flags.has_window_shade_steps)
+	{
+		SSET_WINDOW_SHADE_STEPS(
+			*merged_style, SGET_WINDOW_SHADE_STEPS(*add_style));
+	}
+
+	/* Note:  Only one style cmd can define a window's iconboxes, the last one
+	 * encountered. */
+	if (SHAS_ICON_BOXES(&add_style->flag_mask))
+	{
+		/* If style has iconboxes */
+		/* copy it */
+		if (do_free_src_and_alloc_copy)
+		{
+			remove_icon_boxes_from_style(merged_style);
+			copy_icon_boxes(
+				&SGET_ICON_BOXES(*merged_style),
+				SGET_ICON_BOXES(*add_style));
+		}
+		else
+		{
+			SSET_ICON_BOXES(
+				*merged_style, SGET_ICON_BOXES(*add_style));
+		}
+	}
+	if (add_style->flags.use_layer)
+	{
+		SSET_LAYER(*merged_style, SGET_LAYER(*add_style));
+	}
+	if (add_style->flags.use_colorset)
+	{
+		SSET_COLORSET(*merged_style, SGET_COLORSET(*add_style));
+	}
+	if (add_style->flags.use_colorset_hi)
+	{
+		SSET_COLORSET_HI(*merged_style, SGET_COLORSET_HI(*add_style));
+	}
+	if (add_style->flags.use_border_colorset)
+	{
+		SSET_BORDER_COLORSET(
+			*merged_style, SGET_BORDER_COLORSET(*add_style));
+	}
+	if (add_style->flags.use_border_colorset_hi)
+	{
+		SSET_BORDER_COLORSET_HI(
+			*merged_style,SGET_BORDER_COLORSET_HI(*add_style));
+	}
+	if (add_style->flags.use_icon_title_colorset)
+	{
+		SSET_ICON_TITLE_COLORSET(
+			*merged_style,SGET_ICON_TITLE_COLORSET(*add_style));
+	}
+	if (add_style->flags.use_icon_title_colorset_hi)
+	{
+		SSET_ICON_TITLE_COLORSET_HI(
+			*merged_style,SGET_ICON_TITLE_COLORSET_HI(*add_style));
+	}
+	if (add_style->flags.use_icon_background_colorset)
+	{
+		SSET_ICON_BACKGROUND_COLORSET(
+			*merged_style,SGET_ICON_BACKGROUND_COLORSET(*add_style));
+	}
+	if (add_style->flags.has_placement_penalty)
+	{
+		SSET_NORMAL_PLACEMENT_PENALTY(
+			*merged_style,
+			SGET_NORMAL_PLACEMENT_PENALTY(*add_style));
+		SSET_ONTOP_PLACEMENT_PENALTY(
+			*merged_style,
+			SGET_ONTOP_PLACEMENT_PENALTY(*add_style));
+		SSET_ICON_PLACEMENT_PENALTY(
+			*merged_style, SGET_ICON_PLACEMENT_PENALTY(*add_style));
+		SSET_STICKY_PLACEMENT_PENALTY(
+			*merged_style,
+			SGET_STICKY_PLACEMENT_PENALTY(*add_style));
+		SSET_BELOW_PLACEMENT_PENALTY(
+			*merged_style,
+			SGET_BELOW_PLACEMENT_PENALTY(*add_style));
+		SSET_EWMH_STRUT_PLACEMENT_PENALTY(
+			*merged_style,
+			SGET_EWMH_STRUT_PLACEMENT_PENALTY(*add_style));
+	}
+	if (add_style->flags.has_placement_percentage_penalty)
+	{
+		SSET_99_PLACEMENT_PERCENTAGE_PENALTY(
+			*merged_style,
+			SGET_99_PLACEMENT_PERCENTAGE_PENALTY(*add_style));
+		SSET_95_PLACEMENT_PERCENTAGE_PENALTY(
+			*merged_style,
+			SGET_95_PLACEMENT_PERCENTAGE_PENALTY(*add_style));
+		SSET_85_PLACEMENT_PERCENTAGE_PENALTY(
+			*merged_style,
+			SGET_85_PLACEMENT_PERCENTAGE_PENALTY(*add_style));
+		SSET_75_PLACEMENT_PERCENTAGE_PENALTY(
+			*merged_style,
+			SGET_75_PLACEMENT_PERCENTAGE_PENALTY(*add_style));
+	}
+	/* merge the style flags */
+
+	/*** ATTENTION:
+	 ***	 This must be the last thing that is done in this function! */
+	merge_flags = (char *)&(merged_style->flags);
+	add_flags = (char *)&(add_style->flags);
+	merge_mask = (char *)&(merged_style->flag_mask);
+	add_mask = (char *)&(add_style->flag_mask);
+	merge_dflt = (char *)&(merged_style->flag_default);
+	add_dflt = (char *)&(add_style->flag_default);
+	merge_change_mask = (char *)&(merged_style->change_mask);
+	add_change_mask = (char *)&(add_style->change_mask);
+	for (i = 0; i < sizeof(style_flags); i++)
+	{
+		char m;
+
+		/* overwrite set styles */
+		merge_flags[i] |= (add_flags[i] & add_mask[i]);
+		merge_flags[i] &= (add_flags[i] | ~add_mask[i]);
+		/* overwrite default values */
+		m = add_dflt[i] & ~add_mask[i] & ~merge_mask[i];
+		merge_flags[i] |= (add_flags[i] & m);
+		merge_flags[i] &= (add_flags[i] | ~m);
+		/* overwrite even weaker default values */
+		m = ~add_dflt[i] & ~add_mask[i] & ~merge_dflt[i] &
+			~merge_mask[i];
+		merge_flags[i] |= (add_flags[i] & m);
+		merge_flags[i] &= (add_flags[i] | ~m);
+		/* other flags */
+		merge_change_mask[i] &= ~(add_mask[i]);
+		merge_change_mask[i] |= add_change_mask[i];
+		merge_mask[i] |= add_mask[i];
+		merge_dflt[i] |= add_dflt[i];
+		merge_dflt[i] &= ~merge_mask[i];
+	}
+	merged_style->has_style_changed |= add_style->has_style_changed;
+
+	return;
+}
+
+static void free_style(window_style *style)
+{
+	/* Free contents of style */
+	SAFEFREE(SGET_NAME(*style));
+	SAFEFREE(SGET_BACK_COLOR_NAME(*style));
+	SAFEFREE(SGET_FORE_COLOR_NAME(*style));
+	SAFEFREE(SGET_BACK_COLOR_NAME_HI(*style));
+	SAFEFREE(SGET_FORE_COLOR_NAME_HI(*style));
+	SAFEFREE(SGET_DECOR_NAME(*style));
+	SAFEFREE(SGET_ICON_FONT(*style));
+	SAFEFREE(SGET_WINDOW_FONT(*style));
+	SAFEFREE(SGET_ICON_NAME(*style));
+	SAFEFREE(SGET_MINI_ICON_NAME(*style));
+	remove_icon_boxes_from_style(style);
+
+	return;
+}
+
+/* Frees only selected members of a style; adjusts the flag_mask and
+ * change_mask appropriately. */
+static void free_style_mask(window_style *style, style_flags *mask)
+{
+	style_flags local_mask;
+	style_flags *pmask;
+
+	/* mask out all bits that are not set in the target style */
+	pmask =&local_mask;
+	blockand((char *)pmask, (char *)&style->flag_mask, (char *)mask,
+		 sizeof(style_flags));
+
+	/* Free contents of style */
+	if (pmask->has_color_back)
+	{
+		SAFEFREE(SGET_BACK_COLOR_NAME(*style));
+	}
+	if (pmask->has_color_fore)
+	{
+		SAFEFREE(SGET_FORE_COLOR_NAME(*style));
+	}
+	if (pmask->has_color_back_hi)
+	{
+		SAFEFREE(SGET_BACK_COLOR_NAME_HI(*style));
+	}
+	if (pmask->has_color_fore_hi)
+	{
+		SAFEFREE(SGET_FORE_COLOR_NAME_HI(*style));
+	}
+	if (pmask->has_decor)
+	{
+		SAFEFREE(SGET_DECOR_NAME(*style));
+	}
+	if (pmask->common.has_icon_font)
+	{
+		SAFEFREE(SGET_ICON_FONT(*style));
+	}
+	if (pmask->common.has_window_font)
+	{
+		SAFEFREE(SGET_WINDOW_FONT(*style));
+	}
+	if (pmask->has_icon)
+	{
+		SAFEFREE(SGET_ICON_NAME(*style));
+	}
+	if (pmask->has_mini_icon)
+	{
+		SAFEFREE(SGET_MINI_ICON_NAME(*style));
+	}
+	if (pmask->has_icon_boxes)
+	{
+		remove_icon_boxes_from_style(style);
+	}
+	/* remove styles from definitiion */
+	blockunmask((char *)&style->flag_mask, (char *)&style->flag_mask,
+		    (char *)pmask, sizeof(style_flags));
+	blockunmask((char *)&style->flag_default, (char *)&style->flag_default,
+		    (char *)pmask, sizeof(style_flags));
+	blockunmask((char *)&style->change_mask, (char *)&style->change_mask,
+		    (char *)pmask, sizeof(style_flags));
+
+	return;
+}
+
+static void add_style_to_list(window_style *new_style)
+{
+	/* This used to contain logic that returned if the style didn't contain
+	 * anything.    I don't see why we should bother. dje.
+	 *
+	 * used to merge duplicate entries, but that is no longer
+	 * appropriate since conflicting styles are possible, and the
+	 * last match should win! */
+
+	if (last_style_in_list != NULL)
+	{
+		/* not first entry in list chain this entry to the list */
+		SSET_NEXT_STYLE(*last_style_in_list, new_style);
+	}
+	else
+	{
+		/* first entry in list set the list root pointer. */
+		all_styles = new_style;
+	}
+	SSET_PREV_STYLE(*new_style, last_style_in_list);
+	SSET_NEXT_STYLE(*new_style, NULL);
+	last_style_in_list = new_style;
+	Scr.flags.do_need_style_list_update = 1;
+
+	return;
+} /* end function */
+
+static void remove_style_from_list(window_style *style, Bool do_free_style)
+{
+	window_style *prev;
+	window_style *next;
+
+	prev = SGET_PREV_STYLE(*style);
+	next = SGET_NEXT_STYLE(*style);
+	if (!prev)
+	{
+		/* first style in list */
+		all_styles = next;
+	}
+	else
+	{
+		/* not first style in list */
+		SSET_NEXT_STYLE(*prev, next);
+	}
+	if (!next)
+	{
+		/* last style in list */
+		last_style_in_list = prev;
+	}
+	else
+	{
+		SSET_PREV_STYLE(*next, prev);
+	}
+	if (do_free_style)
+	{
+		free_style(style);
+		free(style);
+	}
+}
+
+static int remove_all_of_style_from_list(style_id_t style_id)
+{
+	window_style *nptr = all_styles;
+	window_style *next;
+	int is_changed = 0;
+
+	/* loop though styles */
+	while (nptr)
+	{
+		next = SGET_NEXT_STYLE(*nptr);
+		/* Check if it's to be wiped */
+		if (style_id_equals_id(nptr, &style_id))
+		{
+			remove_style_from_list(nptr, True);
+			is_changed = 1;
+		}
+		/* move on */
+		nptr = next;
+	}
+
+	return is_changed;
+}
+
+static int __simplify_style_list(void)
+{
+	window_style *cur;
+	int has_modified;
+
+	/* Step 1:
+	 *   Remove styles that are completely overridden by later
+	 *   style definitions.  At the same time...
+	 * Step 2:
+	 *   Merge styles with the same name if there are no
+	 *   conflicting styles with other names set in between. */
+	for (
+		cur = last_style_in_list, has_modified = 0; cur;
+		cur = SGET_PREV_STYLE(*cur))
+	{
+		style_flags dummyflags;
+		/* incremental flags set in styles with the same name */
+		style_flags sumflags;
+		style_flags sumdflags;
+		/* incremental flags set in styles with other names */
+		style_flags interflags;
+		window_style *cmp;
+
+		memset(&interflags, 0, sizeof(style_flags));
+		memcpy(&sumflags, &cur->flag_mask, sizeof(style_flags));
+		memcpy(&sumdflags, &cur->flag_default, sizeof(style_flags));
+		cmp = SGET_PREV_STYLE(*cur);
+		while (cmp)
+		{
+			if (!styles_have_same_id(cur, cmp))
+			{
+				if (one_fw_can_match_both_ids(cur, cmp))
+				{
+					blockor((char *)&interflags,
+						(char *)&interflags,
+						(char *)&cmp->flag_mask,
+						sizeof(style_flags));
+					blockor((char *)&interflags,
+						(char *)&interflags,
+						(char *)&cmp->flag_default,
+						sizeof(style_flags));
+				}
+				cmp = SGET_PREV_STYLE(*cmp);
+				continue;
+			}
+			if (blockissubset(
+				    (char *)&cmp->flag_mask,
+				    (char *)&sumflags,
+				    sizeof(style_flags)) &&
+			    blockissubset(
+				    (char *)&cmp->flag_default,
+				    (char *)&sumdflags,
+				    sizeof(style_flags)))
+			{
+				/* The style is a subset of later style
+				 * definitions; nuke it */
+				window_style *tmp = SGET_PREV_STYLE(*cmp);
+				remove_style_from_list(cmp, True);
+				cmp = tmp;
+				has_modified = 1;
+				continue;
+			}
+			/* remove all styles that are overridden later from the
+			 * style */
+			blockor((char *)&dummyflags,
+				(char *)&sumdflags,
+				(char *)&sumflags,
+				sizeof(style_flags));
+			free_style_mask(cmp, &dummyflags);
+			if (
+				!blocksintersect(
+					(char *)&cmp->flag_mask,
+					(char *)&interflags,
+					sizeof(style_flags)) &&
+				!blocksintersect(
+					(char *)&cmp->flag_default,
+					(char *)&interflags,
+					sizeof(style_flags)))
+			{
+				/* merge old style into new style */
+				window_style *tmp = SGET_PREV_STYLE(*cmp);
+				window_style *prev = SGET_PREV_STYLE(*cur);
+				window_style *next = SGET_NEXT_STYLE(*cur);
+
+				/* Add the style to the set */
+				blockor((char *)&sumflags,
+					(char *)&sumflags,
+					(char *)&cmp->flag_mask,
+					sizeof(style_flags));
+				blockor((char *)&sumdflags,
+					(char *)&sumflags,
+					(char *)&cmp->flag_default,
+				sizeof(style_flags));
+				/* merge cmp into cur and delete it
+				 * afterwards */
+				merge_styles(cmp, cur, True);
+				free_style(cur);
+				memcpy(cur, cmp, sizeof(window_style));
+				/* restore fields overwritten by memcpy */
+				SSET_PREV_STYLE(*cur, prev);
+				SSET_NEXT_STYLE(*cur, next);
+				/* remove the style without freeing the
+				 * memory */
+				remove_style_from_list(cmp, False);
+				/* release the style structure */
+				free(cmp);
+				cmp = tmp;
+				has_modified = 1;
+			}
+			else if	(
+				!blocksintersect(
+					(char *)&cur->flag_mask,
+					(char *)&interflags,
+					sizeof(style_flags)) &&
+				!blocksintersect(
+					(char *)&cur->flag_default,
+					(char *)&interflags,
+					sizeof(style_flags)))
+			{
+				/* merge new style into old style */
+				window_style *tmp = SGET_PREV_STYLE(*cmp);
+
+				/* Add the style to the set */
+				blockor((char *)&sumflags,
+					(char *)&sumflags,
+					(char *)&cur->flag_mask,
+					sizeof(style_flags));
+				blockor((char *)&sumdflags,
+					(char *)&sumflags,
+					(char *)&cur->flag_default,
+					sizeof(style_flags));
+				/* merge cur into cmp and delete it
+				 * afterwards */
+				merge_styles(cmp, cur, True);
+				remove_style_from_list(cur, True);
+				cur = cmp;
+				cmp = tmp;
+				has_modified = 1;
+				memset(&interflags, 0, sizeof(style_flags));
+				continue;
+			}
+			else
+			{
+				/* Add it to the set of interfering styles. */
+				blockor((char *)&interflags,
+					(char *)&interflags,
+					(char *)&cmp->flag_mask,
+					sizeof(style_flags));
+				blockor((char *)&interflags,
+					(char *)&interflags,
+					(char *)&cmp->flag_default,
+					sizeof(style_flags));
+				cmp = SGET_PREV_STYLE(*cmp);
+			}
+		}
+	}
+
+	return has_modified;
+}
+
+static void style_set_old_focus_policy(window_style *ps, int policy)
+{
+	focus_policy_t fp;
+
+	switch (policy)
+	{
+	case 0:
+		/* ClickToFocus */
+		FPS_FOCUS_ENTER(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_UNFOCUS_LEAVE(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_CLIENT(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_CLICK_DECOR(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_CLICK_ICON(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_BY_FUNCTION(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_BY_PROGRAM(fp, 1);
+		FPS_GRAB_FOCUS(fp, 1);
+		FPS_RELEASE_FOCUS(fp, 1);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(fp, 1);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(fp, 1);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(fp, 1);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(fp, 1);
+		FPS_PASS_FOCUS_CLICK(fp, 1);
+		FPS_PASS_RAISE_CLICK(fp, 1);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(fp, 1);
+		FPS_ALLOW_FUNC_RAISE_CLICK(fp, 1);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(fp, 0);
+		break;
+	case 1:
+		/* MouseFocus */
+		FPS_FOCUS_ENTER(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_UNFOCUS_LEAVE(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_CLICK_CLIENT(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_DECOR(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_ICON(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_BY_FUNCTION(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_BY_PROGRAM(fp, 1);
+		FPS_GRAB_FOCUS(fp, 0);
+		FPS_RELEASE_FOCUS(fp, 0);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(fp, 0);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(fp, 0);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(fp, 0);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(fp, 0);
+		FPS_PASS_FOCUS_CLICK(fp, 1);
+		FPS_PASS_RAISE_CLICK(fp, 1);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(fp, 0);
+		FPS_ALLOW_FUNC_RAISE_CLICK(fp, 0);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(fp, 1);
+		break;
+	case 2:
+		/* SloppyFocus */
+		FPS_FOCUS_ENTER(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_UNFOCUS_LEAVE(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_CLIENT(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_DECOR(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_ICON(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_BY_FUNCTION(S_FOCUS_POLICY(SCF(*ps)), 1);
+		FPS_FOCUS_BY_PROGRAM(fp, 1);
+		FPS_GRAB_FOCUS(fp, 0);
+		FPS_RELEASE_FOCUS(fp, 1);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(fp, 0);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(fp, 0);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(fp, 0);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(fp, 0);
+		FPS_PASS_FOCUS_CLICK(fp, 1);
+		FPS_PASS_RAISE_CLICK(fp, 1);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(fp, 0);
+		FPS_ALLOW_FUNC_RAISE_CLICK(fp, 0);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(fp, 1);
+		break;
+	case 3:
+		/* NeverFocus */
+		FPS_FOCUS_ENTER(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_UNFOCUS_LEAVE(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_CLIENT(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_DECOR(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_CLICK_ICON(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_BY_FUNCTION(S_FOCUS_POLICY(SCF(*ps)), 0);
+		FPS_FOCUS_BY_PROGRAM(fp, 1);
+		FPS_GRAB_FOCUS(fp, 0);
+		FPS_RELEASE_FOCUS(fp, 0);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(fp, 0);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(fp, 0);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(fp, 0);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(fp, 0);
+		FPS_PASS_FOCUS_CLICK(fp, 1);
+		FPS_PASS_RAISE_CLICK(fp, 1);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(fp, 1);
+		FPS_ALLOW_FUNC_RAISE_CLICK(fp, 1);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(fp, 0);
+		break;
+	}
+	FPS_FOCUS_ENTER(S_FOCUS_POLICY(SCM(*ps)), 1);
+	FPS_FOCUS_ENTER(S_FOCUS_POLICY(SCC(*ps)), 1);
+	FPS_UNFOCUS_LEAVE(S_FOCUS_POLICY(SCM(*ps)), 1);
+	FPS_UNFOCUS_LEAVE(S_FOCUS_POLICY(SCC(*ps)), 1);
+	FPS_FOCUS_CLICK_CLIENT(S_FOCUS_POLICY(SCM(*ps)), 1);
+	FPS_FOCUS_CLICK_CLIENT(S_FOCUS_POLICY(SCC(*ps)), 1);
+	FPS_FOCUS_CLICK_DECOR(S_FOCUS_POLICY(SCM(*ps)), 1);
+	FPS_FOCUS_CLICK_DECOR(S_FOCUS_POLICY(SCC(*ps)), 1);
+	FPS_FOCUS_CLICK_ICON(S_FOCUS_POLICY(SCM(*ps)), 1);
+	FPS_FOCUS_CLICK_ICON(S_FOCUS_POLICY(SCC(*ps)), 1);
+	FPS_FOCUS_BY_FUNCTION(S_FOCUS_POLICY(SCM(*ps)), 1);
+	FPS_FOCUS_BY_FUNCTION(S_FOCUS_POLICY(SCC(*ps)), 1);
+
+	if (!FP_DO_FOCUS_BY_PROGRAM(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_FOCUS_BY_PROGRAM(
+			S_FOCUS_POLICY(SCF(*ps)), FP_DO_FOCUS_BY_PROGRAM(fp));
+		FPS_FOCUS_BY_PROGRAM(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_FOCUS_BY_PROGRAM(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_GRAB_FOCUS(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCF(*ps)), FP_DO_GRAB_FOCUS(fp));
+		FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_RELEASE_FOCUS(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_RELEASE_FOCUS(
+			S_FOCUS_POLICY(SCF(*ps)), FP_DO_RELEASE_FOCUS(fp));
+		FPS_RELEASE_FOCUS(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_RELEASE_FOCUS(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_RAISE_FOCUSED_CLIENT_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_RAISE_FOCUSED_CLIENT_CLICK(fp));
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_RAISE_UNFOCUSED_CLIENT_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_RAISE_UNFOCUSED_CLIENT_CLICK(fp));
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_RAISE_FOCUSED_DECOR_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_RAISE_FOCUSED_DECOR_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_RAISE_FOCUSED_DECOR_CLICK(fp));
+		FPS_RAISE_FOCUSED_DECOR_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_RAISE_UNFOCUSED_DECOR_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_RAISE_UNFOCUSED_DECOR_CLICK(fp));
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_PASS_FOCUS_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)), FP_DO_PASS_FOCUS_CLICK(fp));
+		FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_PASS_RAISE_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)), FP_DO_PASS_RAISE_CLICK(fp));
+		FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_ALLOW_FUNC_FOCUS_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_ALLOW_FUNC_FOCUS_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_ALLOW_FUNC_FOCUS_CLICK(fp));
+		FPS_ALLOW_FUNC_FOCUS_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_ALLOW_FUNC_RAISE_CLICK(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_ALLOW_FUNC_RAISE_CLICK(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_ALLOW_FUNC_RAISE_CLICK(fp));
+		FPS_ALLOW_FUNC_RAISE_CLICK(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_ALLOW_FUNC_RAISE_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_WARP_POINTER_ON_FOCUS_FUNC(
+		    S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_WARP_POINTER_ON_FOCUS_FUNC(fp));
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+	if (!FP_DO_SORT_WINDOWLIST_BY(S_FOCUS_POLICY(SCM(*ps))))
+	{
+		FPS_SORT_WINDOWLIST_BY(
+			S_FOCUS_POLICY(SCF(*ps)),
+			FP_DO_SORT_WINDOWLIST_BY(fp));
+		FPS_SORT_WINDOWLIST_BY(S_FOCUS_POLICY(SCD(*ps)), 1);
+		FPS_SORT_WINDOWLIST_BY(S_FOCUS_POLICY(SCC(*ps)), 1);
+	}
+
+	return;
+}
+
+static char *style_parse_button_style(
+	window_style *ps, char *button_string, int on)
+{
+	int button;
+	char *rest;
+
+	button = -1;
+	GetIntegerArguments(button_string, &rest, &button, 1);
+	button = BUTTON_INDEX(button);
+	if (button < 0 || button >= NUMBER_OF_TITLE_BUTTONS)
+	{
+		fvwm_msg(
+			ERR, "CMD_Style",
+			"Button and NoButton styles require an argument");
+	}
+	else
+	{
+		if (on)
+		{
+			ps->flags.is_button_disabled &= ~(1 << button);
+			ps->flag_mask.is_button_disabled |= (1 << button);
+			ps->change_mask.is_button_disabled |= (1 << button);
+		}
+		else
+		{
+			ps->flags.is_button_disabled |= (1 << button);
+			ps->flag_mask.is_button_disabled |= (1 << button);
+			ps->change_mask.is_button_disabled |= (1 << button);
+		}
+	}
+
+	return rest;
+}
+
+static Bool style_parse_focus_policy_style(
+	char *option, char *rest, char **ret_rest, Bool is_reversed,
+	focus_policy_t *f, focus_policy_t *m, focus_policy_t *c)
+{
+	char *optlist[] = {
+		"SortWindowlistByFocus",
+		"FocusClickButtons",
+		"FocusClickModifiers",
+		"ClickRaisesFocused",
+		"ClickDecorRaisesFocused",
+		"ClickIconRaisesFocused",
+		"ClickRaisesUnfocused",
+		"ClickDecorRaisesUnfocused",
+		"ClickIconRaisesUnfocused",
+		"ClickToFocus",
+		"ClickDecorToFocus",
+		"ClickIconToFocus",
+		"EnterToFocus",
+		"LeaveToUnfocus",
+		"FocusByProgram",
+		"FocusByFunction",
+		"FocusByFunctionWarpPointer",
+		"Lenient",
+		"PassFocusClick",
+		"PassRaiseClick",
+		"IgnoreFocusClickMotion",
+		"IgnoreRaiseClickMotion",
+		"AllowFocusClickFunction",
+		"AllowRaiseClickFunction",
+		"GrabFocus",
+		"GrabFocusTransient",
+		"OverrideGrabFocus",
+		"ReleaseFocus",
+		"ReleaseFocusTransient",
+		"OverrideReleaseFocus",
+		NULL
+	};
+	Bool found;
+	int val;
+	int index;
+	char *token;
+
+	if (ret_rest)
+	{
+		*ret_rest = rest;
+	}
+
+	found = True;
+	val = !is_reversed;
+	GetNextTokenIndex(option, optlist, 0, &index);
+	switch (index)
+	{
+	case 0:
+		/* SortWindowlistByFocus */
+		FPS_SORT_WINDOWLIST_BY(
+			*f, (val) ?
+			FPOL_SORT_WL_BY_FOCUS : FPOL_SORT_WL_BY_OPEN);
+		FPS_SORT_WINDOWLIST_BY(*m, 1);
+		FPS_SORT_WINDOWLIST_BY(*c, 1);
+		break;
+	case 1:
+		/* FocusClickButtons */
+		if (is_reversed)
+		{
+			found = False;
+			break;
+		}
+		token = PeekToken(rest, ret_rest);
+		val = 0;
+		for ( ; token != NULL && isdigit(*token); token++)
+		{
+			int button;
+			char s[2];
+
+			s[0] = *token;
+			s[1] = 0;
+			button = atoi(s);
+			if (button == 0)
+			{
+				val = ~0;
+			}
+			else if (button > NUMBER_OF_EXTENDED_MOUSE_BUTTONS)
+			{
+				break;
+			}
+			else
+			{
+				val |= (1 << (button - 1));
+			}
+		}
+		if (token != NULL && *token != 0)
+		{
+			fvwm_msg(
+				ERR, "style_parse_focus_policy_style",
+				"illegal mouse button '%c'", *token);
+			val = DEF_FP_MOUSE_BUTTONS;
+		}
+		if (token == NULL)
+		{
+			val = DEF_FP_MOUSE_BUTTONS;
+		}
+		FPS_MOUSE_BUTTONS(*f, val);
+		FPS_MOUSE_BUTTONS(*m, ~0);
+		FPS_MOUSE_BUTTONS(*c, ~0);
+		break;
+	case 2:
+		/* FocusClickModifiers */
+		if (is_reversed)
+		{
+			found = False;
+			break;
+		}
+		token = PeekToken(rest, ret_rest);
+		if (token == NULL ||
+		    modifiers_string_to_modmask(token, &val) == 1)
+		{
+			val = DEF_FP_MODIFIERS;
+		}
+		if (val & AnyModifier)
+		{
+			val = FPOL_ANY_MODIFIER;
+		}
+		FPS_MODIFIERS(*f, val);
+		FPS_MODIFIERS(*m, ~0);
+		FPS_MODIFIERS(*c, ~0);
+		break;
+	case 3:
+		/* ClickRaisesFocused */
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(*f, val);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(*m, 1);
+		FPS_RAISE_FOCUSED_CLIENT_CLICK(*c, 1);
+		break;
+	case 4:
+		/* ClickDecorRaisesFocused */
+		FPS_RAISE_FOCUSED_DECOR_CLICK(*f, val);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(*m, 1);
+		FPS_RAISE_FOCUSED_DECOR_CLICK(*c, 1);
+		break;
+	case 5:
+		/* ClickIconRaisesFocused */
+		FPS_RAISE_FOCUSED_ICON_CLICK(*f, val);
+		FPS_RAISE_FOCUSED_ICON_CLICK(*m, 1);
+		FPS_RAISE_FOCUSED_ICON_CLICK(*c, 1);
+		break;
+	case 6:
+		/* ClickRaisesUnfocused */
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(*f, val);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(*m, 1);
+		FPS_RAISE_UNFOCUSED_CLIENT_CLICK(*c, 1);
+		break;
+	case 7:
+		/* ClickDecorRaisesUnfocused */
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(*f, val);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(*m, 1);
+		FPS_RAISE_UNFOCUSED_DECOR_CLICK(*c, 1);
+		break;
+	case 8:
+		/* ClickIconRaisesUnfocused */
+		FPS_RAISE_UNFOCUSED_ICON_CLICK(*f, val);
+		FPS_RAISE_UNFOCUSED_ICON_CLICK(*m, 1);
+		FPS_RAISE_UNFOCUSED_ICON_CLICK(*c, 1);
+		break;
+	case 9:
+		/* ClickToFocus */
+		FPS_FOCUS_CLICK_CLIENT(*f, val);
+		FPS_FOCUS_CLICK_CLIENT(*m, 1);
+		FPS_FOCUS_CLICK_CLIENT(*c, 1);
+		break;
+	case 10:
+		/* ClickDecorToFocus */
+		FPS_FOCUS_CLICK_DECOR(*f, val);
+		FPS_FOCUS_CLICK_DECOR(*m, 1);
+		FPS_FOCUS_CLICK_DECOR(*c, 1);
+		break;
+	case 11:
+		/* ClickIconToFocus */
+		FPS_FOCUS_CLICK_ICON(*f, val);
+		FPS_FOCUS_CLICK_ICON(*m, 1);
+		FPS_FOCUS_CLICK_ICON(*c, 1);
+		break;
+	case 12:
+		/* EnterToFocus */
+		FPS_FOCUS_ENTER(*f, val);
+		FPS_FOCUS_ENTER(*m, 1);
+		FPS_FOCUS_ENTER(*c, 1);
+		break;
+	case 13:
+		/* LeaveToUnfocus */
+		FPS_UNFOCUS_LEAVE(*f, val);
+		FPS_UNFOCUS_LEAVE(*m, 1);
+		FPS_UNFOCUS_LEAVE(*c, 1);
+		break;
+	case 14:
+		/* FocusByProgram */
+		FPS_FOCUS_BY_PROGRAM(*f, val);
+		FPS_FOCUS_BY_PROGRAM(*m, 1);
+		FPS_FOCUS_BY_PROGRAM(*c, 1);
+		break;
+	case 15:
+		/* FocusByFunction */
+		FPS_FOCUS_BY_FUNCTION(*f, val);
+		FPS_FOCUS_BY_FUNCTION(*m, 1);
+		FPS_FOCUS_BY_FUNCTION(*c, 1);
+		break;
+	case 16:
+		/* FocusByFunctionWarpPointer */
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(*f, val);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(*m, 1);
+		FPS_WARP_POINTER_ON_FOCUS_FUNC(*c, 1);
+		break;
+	case 17:
+		/* Lenient */
+		FPS_LENIENT(*f, val);
+		FPS_LENIENT(*m, 1);
+		FPS_LENIENT(*c, 1);
+		break;
+	case 18:
+		/* PassFocusClick */
+		FPS_PASS_FOCUS_CLICK(*f, val);
+		FPS_PASS_FOCUS_CLICK(*m, 1);
+		FPS_PASS_FOCUS_CLICK(*c, 1);
+		break;
+	case 19:
+		/* PassRaiseClick */
+		FPS_PASS_RAISE_CLICK(*f, val);
+		FPS_PASS_RAISE_CLICK(*m, 1);
+		FPS_PASS_RAISE_CLICK(*c, 1);
+		break;
+	case 20:
+		/* IgnoreFocusClickMotion */
+		FPS_IGNORE_FOCUS_CLICK_MOTION(*f, val);
+		FPS_IGNORE_FOCUS_CLICK_MOTION(*m, 1);
+		FPS_IGNORE_FOCUS_CLICK_MOTION(*c, 1);
+		break;
+	case 21:
+		/* IgnoreRaiseClickMotion */
+		FPS_IGNORE_RAISE_CLICK_MOTION(*f, val);
+		FPS_IGNORE_RAISE_CLICK_MOTION(*m, 1);
+		FPS_IGNORE_RAISE_CLICK_MOTION(*c, 1);
+		break;
+	case 22:
+		/* AllowFocusClickFunction */
+		FPS_ALLOW_FUNC_FOCUS_CLICK(*f, val);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(*m, 1);
+		FPS_ALLOW_FUNC_FOCUS_CLICK(*c, 1);
+		break;
+	case 23:
+		/* AllowRaiseClickFunction */
+		FPS_ALLOW_FUNC_RAISE_CLICK(*f, val);
+		FPS_ALLOW_FUNC_RAISE_CLICK(*m, 1);
+		FPS_ALLOW_FUNC_RAISE_CLICK(*c, 1);
+		break;
+	case 24:
+		/* GrabFocus */
+		FPS_GRAB_FOCUS(*f, val);
+		FPS_GRAB_FOCUS(*m, 1);
+		FPS_GRAB_FOCUS(*c, 1);
+		break;
+	case 25:
+		/* GrabFocusTransient */
+		FPS_GRAB_FOCUS_TRANSIENT(*f, val);
+		FPS_GRAB_FOCUS_TRANSIENT(*m, 1);
+		FPS_GRAB_FOCUS_TRANSIENT(*c, 1);
+		break;
+	case 26:
+		/* OverrideGrabFocus */
+		FPS_OVERRIDE_GRAB_FOCUS(*f, val);
+		FPS_OVERRIDE_GRAB_FOCUS(*m, 1);
+		FPS_OVERRIDE_GRAB_FOCUS(*c, 1);
+		break;
+	case 27:
+		/* ReleaseFocus */
+		FPS_RELEASE_FOCUS(*f, val);
+		FPS_RELEASE_FOCUS(*m, 1);
+		FPS_RELEASE_FOCUS(*c, 1);
+		break;
+	case 28:
+		/* ReleaseFocusTransient */
+		FPS_RELEASE_FOCUS_TRANSIENT(*f, val);
+		FPS_RELEASE_FOCUS_TRANSIENT(*m, 1);
+		FPS_RELEASE_FOCUS_TRANSIENT(*c, 1);
+		break;
+	case 29:
+		/* OverrideReleaseFocus */
+		FPS_OVERRIDE_RELEASE_FOCUS(*f, val);
+		FPS_OVERRIDE_RELEASE_FOCUS(*m, 1);
+		FPS_OVERRIDE_RELEASE_FOCUS(*c, 1);
+		break;
+	default:
+		found = False;
+		break;
+	}
+
+	return found;
+}
+
+static char *style_parse_icon_size_style(
+	char *option, char *rest, window_style *ps)
+{
+	int vals[4];
+	int i;
+
+	option = PeekToken(rest, NULL);
+	if (StrEquals(option, "Stretched"))
+	{
+		SSET_ICON_RESIZE_TYPE(*ps, ICON_RESIZE_TYPE_STRETCHED);
+		option = PeekToken(rest, &rest);
+	}
+	else if (StrEquals(option, "Adjusted"))
+	{
+		SSET_ICON_RESIZE_TYPE(*ps, ICON_RESIZE_TYPE_ADJUSTED);
+		option = PeekToken(rest, &rest);
+	}
+	else if (StrEquals(option, "Shrunk"))
+	{
+		SSET_ICON_RESIZE_TYPE(*ps, ICON_RESIZE_TYPE_SHRUNK);
+		option = PeekToken(rest, &rest);
+	}
+	else
+	{
+		SSET_ICON_RESIZE_TYPE(*ps, ICON_RESIZE_TYPE_NONE);
+	}
+
+	switch (GetIntegerArguments(rest, &rest, vals, 4))
+	{
+	case 0:
+		/* No arguments results in default values */
+		vals[0] = vals[1] = UNSPECIFIED_ICON_DIMENSION;
+		/* fall through */
+	case 2:
+		/* Max and min values are the same */
+		vals[2] = vals[0];
+		vals[3] = vals[1];
+		/* fall through */
+	case 4:
+		/* Validate values */
+		for (i = 0; i < 4; i++)
+		{
+			int use_default = 0;
+
+			if (vals[i] != UNSPECIFIED_ICON_DIMENSION &&
+			    (vals[i] < MIN_ALLOWABLE_ICON_DIMENSION ||
+			     vals[i] > MAX_ALLOWABLE_ICON_DIMENSION))
+			{
+				fvwm_msg(
+					ERR, "CMD_Style",
+					"IconSize dimension (%d) not in valid"
+					" range (%d-%d)",
+					 vals[i], MIN_ALLOWABLE_ICON_DIMENSION,
+					 MAX_ALLOWABLE_ICON_DIMENSION);
+				use_default = 1;
+			}
+
+			/* User requests default value for this dimension */
+			else if (vals[i] == UNSPECIFIED_ICON_DIMENSION)
+			{
+				use_default = 1;
+			}
+
+			if (use_default)
+			{
+				/* Set default value for this dimension.  The
+				 * first two indexes refer to min values, the
+				 * latter two to max values. */
+				vals[i] = i < 2 ? MIN_ALLOWABLE_ICON_DIMENSION :
+					MAX_ALLOWABLE_ICON_DIMENSION;
+			}
+		}
+		SSET_MIN_ICON_WIDTH(*ps, vals[0]);
+		SSET_MIN_ICON_HEIGHT(*ps, vals[1]);
+		SSET_MAX_ICON_WIDTH(*ps, vals[2]);
+		SSET_MAX_ICON_HEIGHT(*ps, vals[3]);
+
+		ps->flags.has_icon_size_limits = 1;
+		ps->flag_mask.has_icon_size_limits = 1;
+		ps->change_mask.has_icon_size_limits = 1;
+		break;
+	default:
+		fvwm_msg(
+			ERR, "CMD_Style",
+			"IconSize requires exactly 0, 2 or 4"
+			" numerical arguments");
+		break;
+	}
+
+	return rest;
+}
+
+static char *style_parse_icon_box_style(
+	icon_boxes **ret_ib, char *option, char *rest, window_style *ps)
+{
+	icon_boxes *IconBoxes = NULL;
+	Bool is_screen_given = False;
+	int val[4];
+	int num;
+	int i;
+
+	option = PeekToken(rest, NULL);
+	if (!option || StrEquals(option, "none"))
+	{
+		option = PeekToken(rest, &rest);
+		/* delete icon boxes from style */
+		if (SGET_ICON_BOXES(*ps))
+		{
+			remove_icon_boxes_from_style(ps);
+		}
+		(*ret_ib) = NULL;
+		if (option)
+		{
+			/* disable default icon box */
+			S_SET_DO_IGNORE_ICON_BOXES(SCF(*ps), 1);
+		}
+		else
+		{
+			/* use default icon box */
+			S_SET_DO_IGNORE_ICON_BOXES(SCF(*ps), 0);
+		}
+		S_SET_DO_IGNORE_ICON_BOXES(SCM(*ps), 1);
+		S_SET_DO_IGNORE_ICON_BOXES(SCC(*ps), 1);
+		ps->flags.has_icon_boxes = 0;
+		ps->flag_mask.has_icon_boxes = 1;
+		ps->change_mask.has_icon_boxes = 1;
+		return rest;
+	}
+
+	/* otherwise try to parse the icon box */
+	IconBoxes = (icon_boxes *)safemalloc(sizeof(icon_boxes));
+	/* clear it */
+	memset(IconBoxes, 0, sizeof(icon_boxes));
+	IconBoxes->IconScreen = FSCREEN_GLOBAL;
+	/* init grid x */
+	IconBoxes->IconGrid[0] = 3;
+	/* init grid y */
+	IconBoxes->IconGrid[1] = 3;
+
+	/* check for screen (for 4 numbers) */
+	if (StrEquals(option, "screen"))
+	{
+		is_screen_given = True;
+		option = PeekToken(rest, &rest); /* skip screen */
+		option = PeekToken(rest, &rest); /* get the screen spec */
+		IconBoxes->IconScreen =
+			FScreenGetScreenArgument(option, FSCREEN_SPEC_PRIMARY);
+	}
+
+	/* try for 4 numbers x y x y */
+	num = GetIntegerArguments(rest, NULL, val, 4);
+
+	/* if 4 numbers */
+	if (num == 4)
+	{
+		for (i = 0; i < 4; i++)
+		{
+			/* make sure the value fits into a short */
+			if (val[i] < -32768)
+			{
+				val[i] = -32768;
+			}
+			if (val[i] > 32767)
+			{
+				val[i] = 32767;
+			}
+			IconBoxes->IconBox[i] = val[i];
+			/* If leading minus sign */
+			option = PeekToken(rest, &rest);
+			if (option[0] == '-')
+			{
+				IconBoxes->IconSign[i]='-';
+			} /* end leading minus sign */
+		}
+		/* Note: here there is no test for valid co-ords, use geom */
+	}
+	else if  (is_screen_given)
+	{
+		/* screen-spec is given but not 4 numbers */
+		fvwm_msg(
+			ERR,"CMD_Style",
+			"IconBox requires 4 numbers if screen is given!"
+			" Invalid: <%s>.", option);
+		/* Drop the box */
+		free(IconBoxes);
+		/* forget about it */
+		IconBoxes = 0;
+	}
+	else
+	{
+		/* Not 4 numeric args dje */
+		/* bigger than =32767x32767+32767+32767 */
+		int geom_flags;
+		int l;
+		int width;
+		int height;
+
+		/* read in 1 word w/o advancing */
+		option = PeekToken(rest, NULL);
+		if (!option)
+		{
+			return rest;
+		}
+		l = strlen(option);
+		if (l > 0 && l < 24)
+		{
+			/* advance */
+			option = PeekToken(rest, &rest);
+			/* if word found, not too long */
+			geom_flags = FScreenParseGeometryWithScreen(
+				option, &IconBoxes->IconBox[0],
+				&IconBoxes->IconBox[1],	(unsigned int*)&width,
+				(unsigned int*)&height,
+				&IconBoxes->IconScreen);
+			if (width == 0 || !(geom_flags & WidthValue))
+			{
+				/* zero width is invalid */
+				fvwm_msg(
+					ERR,"CMD_Style",
+					"IconBox requires 4 numbers or"
+					" geometry! Invalid string <%s>.",
+					option);
+				/* Drop the box */
+				free(IconBoxes);
+				/* forget about it */
+				IconBoxes = 0;
+			}
+			else
+			{
+				/* got valid iconbox geom */
+				if (geom_flags & XNegative)
+				{
+					IconBoxes->IconBox[0] =
+						/* neg x coord */
+						IconBoxes->IconBox[0] -
+						width - 2;
+					/* save for later */
+					IconBoxes->IconSign[0]='-';
+					IconBoxes->IconSign[2]='-';
+				}
+				if (geom_flags & YNegative)
+				{
+					IconBoxes->IconBox[1] =
+						/* neg y coord */
+						IconBoxes->IconBox[1]
+						- height -2;
+					/* save for later */
+					IconBoxes->IconSign[1]='-';
+					IconBoxes->IconSign[3]='-';
+				}
+				/* x + wid = right x */
+				IconBoxes->IconBox[2] =
+					width + IconBoxes->IconBox[0];
+				/* y + height = bottom y */
+				IconBoxes->IconBox[3] =
+					height + IconBoxes->IconBox[1];
+			} /* end icon geom worked */
+		}
+		else
+		{
+			/* no word or too long; drop the box */
+			free(IconBoxes);
+			/* forget about it */
+			IconBoxes = 0;
+		} /* end word found, not too long */
+	} /* end not 4 args */
+	/* If we created an IconBox, put it in the chain. */
+	if (IconBoxes != 0)
+	{
+		/* no error */
+		if (SGET_ICON_BOXES(*ps) == 0)
+		{
+			/* first one, chain to root */
+			SSET_ICON_BOXES(*ps, IconBoxes);
+		}
+		else
+		{
+			/* else not first one, add to end of chain */
+			(*ret_ib)->next = IconBoxes;
+		} /* end not first one */
+		/* new current box. save for grid */
+		(*ret_ib) = IconBoxes;
+	} /* end no error */
+	S_SET_DO_IGNORE_ICON_BOXES(SCF(*ps), 0);
+	S_SET_DO_IGNORE_ICON_BOXES(SCM(*ps), 1);
+	S_SET_DO_IGNORE_ICON_BOXES(SCC(*ps), 1);
+	ps->flags.has_icon_boxes = !!(SGET_ICON_BOXES(*ps));
+	ps->flag_mask.has_icon_boxes = 1;
+	ps->change_mask.has_icon_boxes = 1;
+
+	return rest;
+}
+
+static char *style_parse_icon_grid_style(
+	char *option, char *rest, window_style *ps, icon_boxes *ib)
+{
+	int val[4];
+	int num;
+	int i;
+
+	/* The grid always affects the prior iconbox */
+	if (ib == 0)
+	{
+		/* If no current box */
+		fvwm_msg(
+			ERR,"CMD_Style",
+			"IconGrid must follow an IconBox in same Style"
+			" command");
+		return rest;
+	}
+	/* have a place to grid */
+	/* 2 ints */
+	num = GetIntegerArguments(rest, &rest, val, 2);
+	if (num != 2 || val[0] < 1 || val[1] < 1)
+	{
+		fvwm_msg(
+			ERR,"CMD_Style",
+			"IconGrid needs 2 numbers > 0. Got %d numbers."
+			" x=%d y=%d!", num, val[0], val[1]);
+		/* reset grid */
+		ib->IconGrid[0] = 3;
+		ib->IconGrid[1] = 3;
+	}
+	else
+	{
+		for (i = 0; i < 2; i++)
+		{
+			ib->IconGrid[i] = val[i];
+		}
+	} /* end bad grid */
+
+	return rest;
+}
+
+static char *style_parse_icon_fill_style(
+	char *option, char *rest, window_style *ps, icon_boxes *ib)
+{
+	/* first  type direction parsed */
+	unsigned char IconFill_1;
+	/* second type direction parsed */
+	unsigned char IconFill_2;
+
+	/* direction to fill iconbox */
+	/* The fill always affects the prior iconbox */
+	if (ib == 0)
+	{
+		/* If no current box */
+		fvwm_msg(
+			ERR,"CMD_Style",
+			"IconFill must follow an IconBox in same Style"
+			" command");
+		return rest;
+	}
+	/* have a place to fill */
+	option = PeekToken(rest, &rest);
+	/* top/bot/lft/rgt */
+	if (!option || Get_TBLR(option, &IconFill_1) == 0)
+	{
+		/* its wrong */
+		if (!option)
+		{
+			option = "(none)";
+		}
+		fvwm_msg(
+			ERR,"CMD_Style",
+			"IconFill must be followed by T|B|R|L, found"
+			" %s.", option);
+		return rest;
+	}
+	/* first word valid */
+
+	/* read in second word */
+	option = PeekToken(rest, &rest);
+	/* top/bot/lft/rgt */
+	if (!option || Get_TBLR(option, &IconFill_2) == 0)
+	{
+		/* its wrong */
+		if (!option)
+		{
+			option = "(none)";
+		}
+		fvwm_msg(
+			ERR,"CMD_Style",
+			"IconFill must be followed by T|B|R|L,"
+			" found %s.", option);
+		return rest;
+	}
+	if ((IconFill_1 & ICONFILLHRZ) == (IconFill_2 & ICONFILLHRZ))
+	{
+		fvwm_msg(
+			ERR, "CMD_Style",
+			"IconFill must specify a horizontal"
+			" and vertical direction.");
+		return rest;
+	}
+	/* Its valid! */
+	/* merge in flags */
+	ib->IconFlags |= IconFill_1;
+	/* ignore horiz in 2nd arg */
+	IconFill_2 &= ~ICONFILLHRZ;
+	/* merge in flags */
+	ib->IconFlags |= IconFill_2;
+
+	return rest;
+}
+
+static Bool style_parse_one_style_option(
+	char *token, char *rest, char **ret_rest, char *prefix,
+	window_style *ps, icon_boxes **cur_ib)
+{
+	window_style *add_style;
+	/* work area for button number */
+	int num;
+	int i;
+	int tmpno[3] = { -1, -1, -1 };
+	int val[4];
+	int spargs = 0;
+	Bool found;
+	int on;
+	char *token_l = NULL;
+
+	found = True;
+	on = 1;
+	while (token[0] == '!')
+	{
+		on ^= 1;
+		token++;
+	}
+	if (prefix != NULL && *prefix != 0)
+	{
+		int l;
+
+		l = strlen(prefix);
+		if (strncasecmp(token, prefix, l) != 0)
+		{
+			/* add missing prefix */
+			token_l = (char *)safemalloc(l + strlen(token) + 1);
+			strcpy(token_l, prefix);
+			strcat(token_l, token);
+			token = token_l;
+		}
+	}
+	switch (tolower(token[0]))
+	{
+	case 'a':
+		if (StrEquals(token, "ACTIVEPLACEMENT"))
+		{
+			ps->flags.placement_mode &= (~PLACE_RANDOM);
+			ps->flag_mask.placement_mode |= PLACE_RANDOM;
+			ps->change_mask.placement_mode |= PLACE_RANDOM;
+		}
+		else if (StrEquals(token, "ACTIVEPLACEMENTHONORSSTARTSONPAGE"))
+		{
+			ps->flags.manual_placement_honors_starts_on_page = on;
+			ps->flag_mask.manual_placement_honors_starts_on_page =
+				1;
+			ps->change_mask.manual_placement_honors_starts_on_page
+				= 1;
+		}
+		else if (StrEquals(
+				 token, "ACTIVEPLACEMENTIGNORESSTARTSONPAGE"))
+		{
+			ps->flags.manual_placement_honors_starts_on_page = !on;
+			ps->flag_mask.manual_placement_honors_starts_on_page =
+				1;
+			ps->change_mask.manual_placement_honors_starts_on_page
+				= 1;
+		}
+		else if (StrEquals(token, "AllowRestack"))
+		{
+			S_SET_DO_IGNORE_RESTACK(SCF(*ps), !on);
+			S_SET_DO_IGNORE_RESTACK(SCM(*ps), 1);
+			S_SET_DO_IGNORE_RESTACK(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "AllowMaximizeFixedSize"))
+		{
+			S_SET_MAXIMIZE_FIXED_SIZE_DISALLOWED(SCF(*ps), !on);
+			S_SET_MAXIMIZE_FIXED_SIZE_DISALLOWED(SCM(*ps), 1);
+			S_SET_MAXIMIZE_FIXED_SIZE_DISALLOWED(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'b':
+		if (StrEquals(token, "BackColor"))
+		{
+			rest = GetNextToken(rest, &token);
+			if (token)
+			{
+				SAFEFREE(SGET_BACK_COLOR_NAME(*ps));
+				SSET_BACK_COLOR_NAME(*ps, token);
+				ps->flags.has_color_back = 1;
+				ps->flag_mask.has_color_back = 1;
+				ps->change_mask.has_color_back = 1;
+				ps->flags.use_colorset = 0;
+				ps->flag_mask.use_colorset = 1;
+				ps->change_mask.use_colorset = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_on_estyle_option",
+					"Style BackColor requires color"
+					" argument");
+			}
+		}
+		else if (StrEquals(token, "Button"))
+		{
+			rest = style_parse_button_style(ps, rest, on);
+		}
+		else if (StrEquals(token, "BorderWidth"))
+		{
+			if (GetIntegerArguments(rest, &rest, val, 1))
+			{
+				SSET_BORDER_WIDTH(*ps, (short)*val);
+				ps->flags.has_border_width = 1;
+				ps->flag_mask.has_border_width = 1;
+				ps->change_mask.has_border_width = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"Style BorderWidth requires width"
+					" argument");
+			}
+		}
+		else if (StrEquals(token, "BackingStore"))
+		{
+			ps->flags.use_backing_store = BACKINGSTORE_ON;
+			ps->flag_mask.use_backing_store = BACKINGSTORE_MASK;
+			ps->change_mask.use_backing_store = BACKINGSTORE_MASK;
+		}
+		else if (StrEquals(token, "BackingStoreOff"))
+		{
+			ps->flags.use_backing_store = BACKINGSTORE_OFF;
+			ps->flag_mask.use_backing_store = BACKINGSTORE_MASK;
+			ps->change_mask.use_backing_store = BACKINGSTORE_MASK;
+		}
+		else if (StrEquals(token, "BackingStoreWindowDefault"))
+		{
+			ps->flags.use_backing_store = BACKINGSTORE_DEFAULT;
+			ps->flag_mask.use_backing_store = BACKINGSTORE_MASK;
+			ps->change_mask.use_backing_store = BACKINGSTORE_MASK;
+		}
+		else if (StrEquals(token, "BorderColorset"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest, &rest, val, 1);
+			SSET_BORDER_COLORSET(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_border_colorset = (*val >= 0);
+			ps->flag_mask.use_border_colorset = 1;
+			ps->change_mask.use_border_colorset = 1;
+		}
+		else if (StrEquals(token, "BottomTitleRotated"))
+		{
+			S_SET_IS_BOTTOM_TITLE_ROTATED(SCF(*ps), on);
+			S_SET_IS_BOTTOM_TITLE_ROTATED(SCM(*ps), 1);
+			S_SET_IS_BOTTOM_TITLE_ROTATED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "BottomTitleNotRotated"))
+		{
+			S_SET_IS_BOTTOM_TITLE_ROTATED(SCF(*ps), !on);
+			S_SET_IS_BOTTOM_TITLE_ROTATED(SCM(*ps), 1);
+			S_SET_IS_BOTTOM_TITLE_ROTATED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "Borders"))
+		{
+			S_SET_HAS_NO_BORDER(SCF(*ps), !on);
+			S_SET_HAS_NO_BORDER(SCM(*ps), 1);
+			S_SET_HAS_NO_BORDER(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'c':
+		if (StrEquals(token, "CenterPlacement"))
+		{
+			ps->flags.placement_mode = PLACE_CENTER;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "CascadePlacement"))
+		{
+			ps->flags.placement_mode = PLACE_CASCADE;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "CLEVERPLACEMENT"))
+		{
+			ps->flags.placement_mode |= PLACE_CLEVER;
+			ps->flag_mask.placement_mode |= PLACE_CLEVER;
+			ps->change_mask.placement_mode |= PLACE_CLEVER;
+		}
+		else if (StrEquals(token, "CleverPlacementOff"))
+		{
+			ps->flags.placement_mode &= (~PLACE_CLEVER);
+			ps->flag_mask.placement_mode |= PLACE_CLEVER;
+			ps->change_mask.placement_mode |= PLACE_CLEVER;
+		}
+		else if (StrEquals(token, "CaptureHonorsStartsOnPage"))
+		{
+			ps->flags.capture_honors_starts_on_page = on;
+			ps->flag_mask.capture_honors_starts_on_page = 1;
+			ps->change_mask.capture_honors_starts_on_page = 1;
+		}
+		else if (StrEquals(token, "CaptureIgnoresStartsonPage"))
+		{
+			ps->flags.capture_honors_starts_on_page = !on;
+			ps->flag_mask.capture_honors_starts_on_page = 1;
+			ps->change_mask.capture_honors_starts_on_page = 1;
+		}
+		else if (StrEquals(token, "ColorSet"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest, &rest, val, 1);
+			if (*val < 0)
+			{
+				*val = -1;
+			}
+			SSET_COLORSET(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_colorset = (*val >= 0);
+			ps->flag_mask.use_colorset = 1;
+			ps->change_mask.use_colorset = 1;
+		}
+		else if (StrEquals(token, "Color"))
+		{
+			char c = 0;
+			char *next;
+
+			next = GetNextToken(rest, &token);
+			if (token == NULL)
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"Color Style requires a color"
+					" argument");
+				break;
+			}
+			if (strncasecmp(token, "rgb:", 4) == 0)
+			{
+				char *s;
+				int i;
+
+				/* spool to third '/' */
+				for (i = 0, s = token + 4; *s && i < 3; s++)
+				{
+					if (*s == '/')
+					{
+						i++;
+					}
+				}
+				s--;
+				if (i == 3)
+				{
+					*s = 0;
+					/* spool to third '/' in original
+					 * string too */
+					for (i = 0, s = rest; *s && i < 3; s++)
+					{
+						if (*s == '/')
+						{
+							i++;
+						}
+					}
+					next = s - 1;
+				}
+			}
+			else
+			{
+				free(token);
+				next = DoGetNextToken(
+					rest, &token, NULL, ",/", &c);
+			}
+			rest = next;
+			SAFEFREE(SGET_FORE_COLOR_NAME(*ps));
+			SSET_FORE_COLOR_NAME(*ps, token);
+			ps->flags.has_color_fore = 1;
+			ps->flag_mask.has_color_fore = 1;
+			ps->change_mask.has_color_fore = 1;
+			ps->flags.use_colorset = 0;
+			ps->flag_mask.use_colorset = 1;
+			ps->change_mask.use_colorset = 1;
+
+			/* skip over '/' */
+			if (c != '/')
+			{
+				while (rest && *rest &&
+				       isspace((unsigned char)*rest) &&
+				       *rest != ',' && *rest != '/')
+				{
+					rest++;
+				}
+				if (*rest == '/')
+				{
+					rest++;
+				}
+			}
+
+			rest=GetNextToken(rest, &token);
+			if (!token)
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"Color Style called with incomplete"
+					" color argument.");
+				break;
+			}
+			SAFEFREE(SGET_BACK_COLOR_NAME(*ps));
+			SSET_BACK_COLOR_NAME(*ps, token);
+			ps->flags.has_color_back = 1;
+			ps->flag_mask.has_color_back = 1;
+			ps->change_mask.has_color_back = 1;
+			break;
+		}
+		else if (StrEquals(token, "CirculateSkipIcon"))
+		{
+			S_SET_DO_CIRCULATE_SKIP_ICON(SCF(*ps), on);
+			S_SET_DO_CIRCULATE_SKIP_ICON(SCM(*ps), 1);
+			S_SET_DO_CIRCULATE_SKIP_ICON(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "CirculateSkipShaded"))
+		{
+			S_SET_DO_CIRCULATE_SKIP_SHADED(SCF(*ps), on);
+			S_SET_DO_CIRCULATE_SKIP_SHADED(SCM(*ps), 1);
+			S_SET_DO_CIRCULATE_SKIP_SHADED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "CirculateHitShaded"))
+		{
+			S_SET_DO_CIRCULATE_SKIP_SHADED(SCF(*ps), !on);
+			S_SET_DO_CIRCULATE_SKIP_SHADED(SCM(*ps), 1);
+			S_SET_DO_CIRCULATE_SKIP_SHADED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "CirculateHitIcon"))
+		{
+			S_SET_DO_CIRCULATE_SKIP_ICON(SCF(*ps), !on);
+			S_SET_DO_CIRCULATE_SKIP_ICON(SCM(*ps), 1);
+			S_SET_DO_CIRCULATE_SKIP_ICON(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ClickToFocus"))
+		{
+			style_set_old_focus_policy(ps, 0);
+		}
+		else if (StrEquals(token, "ClickToFocusPassesClick"))
+		{
+			FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+			FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "ClickToFocusPassesClickOff"))
+		{
+			FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_PASS_FOCUS_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+			FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_PASS_RAISE_CLICK(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "ClickToFocusRaises"))
+		{
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "ClickToFocusRaisesOff"))
+		{
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "CirculateSkip"))
+		{
+			S_SET_DO_CIRCULATE_SKIP(SCF(*ps), on);
+			S_SET_DO_CIRCULATE_SKIP(SCM(*ps), 1);
+			S_SET_DO_CIRCULATE_SKIP(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "CirculateHit"))
+		{
+			S_SET_DO_CIRCULATE_SKIP(SCF(*ps), !on);
+			S_SET_DO_CIRCULATE_SKIP(SCM(*ps), 1);
+			S_SET_DO_CIRCULATE_SKIP(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "Closable"))
+		{
+			S_SET_IS_UNCLOSABLE(SCF(*ps), !on);
+			S_SET_IS_UNCLOSABLE(SCM(*ps), 1);
+			S_SET_IS_UNCLOSABLE(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'd':
+		if (StrEquals(token, "DepressableBorder"))
+		{
+			S_SET_HAS_DEPRESSABLE_BORDER(SCF(*ps), on);
+			S_SET_HAS_DEPRESSABLE_BORDER(SCM(*ps), 1);
+			S_SET_HAS_DEPRESSABLE_BORDER(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "DecorateTransient"))
+		{
+			ps->flags.do_decorate_transient = on;
+			ps->flag_mask.do_decorate_transient = 1;
+			ps->change_mask.do_decorate_transient = 1;
+		}
+		else if (StrEquals(token, "DumbPlacement"))
+		{
+			ps->flags.placement_mode &= (~PLACE_SMART);
+			ps->flag_mask.placement_mode |= PLACE_SMART;
+			ps->change_mask.placement_mode |= PLACE_SMART;
+		}
+		else if (StrEquals(token, "DONTRAISETRANSIENT"))
+		{
+			S_SET_DO_RAISE_TRANSIENT(SCF(*ps), !on);
+			S_SET_DO_RAISE_TRANSIENT(SCM(*ps), 1);
+			S_SET_DO_RAISE_TRANSIENT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "DONTLOWERTRANSIENT"))
+		{
+			S_SET_DO_LOWER_TRANSIENT(SCF(*ps), !on);
+			S_SET_DO_LOWER_TRANSIENT(SCM(*ps), 1);
+			S_SET_DO_LOWER_TRANSIENT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "DontStackTransientParent"))
+		{
+			S_SET_DO_STACK_TRANSIENT_PARENT(SCF(*ps), !on);
+			S_SET_DO_STACK_TRANSIENT_PARENT(SCM(*ps), 1);
+			S_SET_DO_STACK_TRANSIENT_PARENT(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'e':
+		if (StrEquals(token, "ExactWindowName"))
+		{
+			S_SET_USE_INDEXED_WINDOW_NAME(SCF(*ps), !on);
+			S_SET_USE_INDEXED_WINDOW_NAME(SCM(*ps), 1);
+			S_SET_USE_INDEXED_WINDOW_NAME(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ExactIconName"))
+		{
+			S_SET_USE_INDEXED_ICON_NAME(SCF(*ps), !on);
+			S_SET_USE_INDEXED_ICON_NAME(SCM(*ps), 1);
+			S_SET_USE_INDEXED_ICON_NAME(SCC(*ps), 1);
+		}
+		else
+		{
+			found = EWMH_CMD_Style(token, ps, on);
+		}
+		break;
+
+	case 'f':
+		if (strncasecmp(token, "fp", 2) == 0)
+		{
+			/* parse focus policy options */
+			found = style_parse_focus_policy_style(
+				token + 2, rest, &rest, (on) ? False : True,
+				&S_FOCUS_POLICY(SCF(*ps)),
+				&S_FOCUS_POLICY(SCM(*ps)),
+				&S_FOCUS_POLICY(SCC(*ps)));
+		}
+		else if (StrEquals(token, "Font"))
+		{
+			SAFEFREE(SGET_WINDOW_FONT(*ps));
+			rest = GetNextToken(rest, &token);
+			SSET_WINDOW_FONT(*ps, token);
+			S_SET_HAS_WINDOW_FONT(SCF(*ps), (token != NULL));
+			S_SET_HAS_WINDOW_FONT(SCM(*ps), 1);
+			S_SET_HAS_WINDOW_FONT(SCC(*ps), 1);
+
+		}
+		else if (StrEquals(token, "ForeColor"))
+		{
+			rest = GetNextToken(rest, &token);
+			if (token)
+			{
+				SAFEFREE(SGET_FORE_COLOR_NAME(*ps));
+				SSET_FORE_COLOR_NAME(*ps, token);
+				ps->flags.has_color_fore = 1;
+				ps->flag_mask.has_color_fore = 1;
+				ps->change_mask.has_color_fore = 1;
+				ps->flags.use_colorset = 0;
+				ps->flag_mask.use_colorset = 1;
+				ps->change_mask.use_colorset = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"ForeColor Style needs color argument"
+					);
+			}
+		}
+		else if (StrEquals(token, "FVWMBUTTONS"))
+		{
+			S_SET_HAS_MWM_BUTTONS(SCF(*ps), !on);
+			S_SET_HAS_MWM_BUTTONS(SCM(*ps), 1);
+			S_SET_HAS_MWM_BUTTONS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "FVWMBORDER"))
+		{
+			S_SET_HAS_MWM_BORDER(SCF(*ps), !on);
+			S_SET_HAS_MWM_BORDER(SCM(*ps), 1);
+			S_SET_HAS_MWM_BORDER(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "FocusFollowsMouse"))
+		{
+			style_set_old_focus_policy(ps, 1);
+		}
+		else if (StrEquals(token, "FirmBorder"))
+		{
+			S_SET_HAS_DEPRESSABLE_BORDER(SCF(*ps), !on);
+			S_SET_HAS_DEPRESSABLE_BORDER(SCM(*ps), 1);
+			S_SET_HAS_DEPRESSABLE_BORDER(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "FixedPosition") ||
+			 StrEquals(token, "FixedUSPosition"))
+		{
+			S_SET_IS_FIXED(SCF(*ps), on);
+			S_SET_IS_FIXED(SCM(*ps), 1);
+			S_SET_IS_FIXED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "FixedPPosition"))
+		{
+			S_SET_IS_FIXED_PPOS(SCF(*ps), on);
+			S_SET_IS_FIXED_PPOS(SCM(*ps), 1);
+			S_SET_IS_FIXED_PPOS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "FixedSize") ||
+			 StrEquals(token, "FixedUSSize"))
+		{
+			S_SET_IS_SIZE_FIXED(SCF(*ps), on);
+			S_SET_IS_SIZE_FIXED(SCM(*ps), 1);
+			S_SET_IS_SIZE_FIXED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "FixedPSize"))
+		{
+			S_SET_IS_PSIZE_FIXED(SCF(*ps), on);
+			S_SET_IS_PSIZE_FIXED(SCM(*ps), 1);
+			S_SET_IS_PSIZE_FIXED(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'g':
+		if (StrEquals(token, "GrabFocusOff"))
+		{
+			FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "GrabFocus"))
+		{
+			FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_GRAB_FOCUS(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "GrabFocusTransientOff"))
+		{
+			FPS_GRAB_FOCUS_TRANSIENT(
+				S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_GRAB_FOCUS_TRANSIENT(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_GRAB_FOCUS_TRANSIENT(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "GrabFocusTransient"))
+		{
+			FPS_GRAB_FOCUS_TRANSIENT(S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_GRAB_FOCUS_TRANSIENT(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_GRAB_FOCUS_TRANSIENT(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "GNOMEIgnoreHints"))
+		{
+			S_SET_DO_IGNORE_GNOME_HINTS(SCF(*ps), on);
+			S_SET_DO_IGNORE_GNOME_HINTS(SCM(*ps), 1);
+			S_SET_DO_IGNORE_GNOME_HINTS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "GNOMEUseHints"))
+		{
+			S_SET_DO_IGNORE_GNOME_HINTS(SCF(*ps), !on);
+			S_SET_DO_IGNORE_GNOME_HINTS(SCM(*ps), 1);
+			S_SET_DO_IGNORE_GNOME_HINTS(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'h':
+		if (StrEquals(token, "HintOverride"))
+		{
+			S_SET_HAS_MWM_OVERRIDE(SCF(*ps), on);
+			S_SET_HAS_MWM_OVERRIDE(SCM(*ps), 1);
+			S_SET_HAS_MWM_OVERRIDE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "Handles"))
+		{
+			ps->flags.has_no_handles = !on;
+			ps->flag_mask.has_no_handles = 1;
+			ps->change_mask.has_no_handles = 1;
+		}
+		else if (StrEquals(token, "HandleWidth"))
+		{
+			if (GetIntegerArguments(rest, &rest, val, 1))
+			{
+				SSET_HANDLE_WIDTH(*ps, (short)*val);
+				ps->flags.has_handle_width = 1;
+				ps->flag_mask.has_handle_width = 1;
+				ps->change_mask.has_handle_width = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"HandleWidth Style needs width"
+					" argument");
+			}
+		}
+		else if (StrEquals(token, "HilightFore"))
+		{
+			rest = GetNextToken(rest, &token);
+			if (token)
+			{
+				SAFEFREE(SGET_FORE_COLOR_NAME_HI(*ps));
+				SSET_FORE_COLOR_NAME_HI(*ps, token);
+				ps->flags.has_color_fore_hi = 1;
+				ps->flag_mask.has_color_fore_hi = 1;
+				ps->change_mask.has_color_fore_hi = 1;
+				ps->flags.use_colorset_hi = 0;
+				ps->flag_mask.use_colorset_hi = 1;
+				ps->change_mask.use_colorset_hi = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"HilightFore Style needs color"
+					" argument");
+			}
+		}
+		else if (StrEquals(token, "HilightBack"))
+		{
+			rest = GetNextToken(rest, &token);
+			if (token)
+			{
+				SAFEFREE(SGET_BACK_COLOR_NAME_HI(*ps));
+				SSET_BACK_COLOR_NAME_HI(*ps, token);
+				ps->flags.has_color_back_hi = 1;
+				ps->flag_mask.has_color_back_hi = 1;
+				ps->change_mask.has_color_back_hi = 1;
+				ps->flags.use_colorset_hi = 0;
+				ps->flag_mask.use_colorset_hi = 1;
+				ps->change_mask.use_colorset_hi = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"HilightBack Style needs color"
+					" argument");
+			}
+		}
+		else if (StrEquals(token, "HilightColorset"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest, &rest, val, 1);
+			SSET_COLORSET_HI(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_colorset_hi = (*val >= 0);
+			ps->flag_mask.use_colorset_hi = 1;
+			ps->change_mask.use_colorset_hi = 1;
+		}
+		else if (StrEquals(token, "HilightBorderColorset"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest, &rest, val, 1);
+			SSET_BORDER_COLORSET_HI(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_border_colorset_hi = (*val >= 0);
+			ps->flag_mask.use_border_colorset_hi = 1;
+			ps->change_mask.use_border_colorset_hi = 1;
+		}
+		else if (StrEquals(token, "HilightIconTitleColorset"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest, &rest, val, 1);
+			SSET_ICON_TITLE_COLORSET_HI(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_icon_title_colorset_hi = (*val >= 0);
+			ps->flag_mask.use_icon_title_colorset_hi = 1;
+			ps->change_mask.use_icon_title_colorset_hi = 1;
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'i':
+		if (StrEquals(token, "Icon"))
+		{
+			if (on == 1)
+			{
+				rest = GetNextToken(rest, &token);
+
+				SAFEFREE(SGET_ICON_NAME(*ps));
+				SSET_ICON_NAME(*ps,token);
+				ps->flags.has_icon = (token != NULL);
+				ps->flag_mask.has_icon = 1;
+				ps->change_mask.has_icon = 1;
+
+				S_SET_IS_ICON_SUPPRESSED(SCF(*ps), 0);
+				S_SET_IS_ICON_SUPPRESSED(SCM(*ps), 1);
+				S_SET_IS_ICON_SUPPRESSED(SCC(*ps), 1);
+			}
+			else
+			{
+				S_SET_IS_ICON_SUPPRESSED(SCF(*ps), 1);
+				S_SET_IS_ICON_SUPPRESSED(SCM(*ps), 1);
+				S_SET_IS_ICON_SUPPRESSED(SCC(*ps), 1);
+			}
+		}
+		else if (StrEquals(token, "IconBackgroundColorset"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest, &rest, val, 1);
+			SSET_ICON_BACKGROUND_COLORSET(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_icon_background_colorset = (*val >= 0);
+			ps->flag_mask.use_icon_background_colorset = 1;
+			ps->change_mask.use_icon_background_colorset = 1;
+		}
+		else if (StrEquals(token, "IconBackgroundPadding"))
+		{
+			*val = ICON_BACKGROUND_PADDING;
+			GetIntegerArguments(rest, &rest, val, 1);
+			if (*val < 0)
+			{
+				*val = 0;
+			}
+			else if (*val > 50)
+			{
+				*val = 50;
+			}
+			SSET_ICON_BACKGROUND_PADDING(*ps, (unsigned char)*val);
+			ps->flags.has_icon_background_padding = 1;
+			ps->flag_mask.has_icon_background_padding = 1;
+			ps->change_mask.has_icon_background_padding = 1;
+		}
+		else if (StrEquals(token, "IconBackgroundRelief"))
+		{
+			*val = ICON_RELIEF_WIDTH;
+			GetIntegerArguments(rest, &rest, val, 1);
+			if (*val < -50)
+			{
+				*val = -50;
+			}
+			else if (*val > 50)
+			{
+				*val = 50;
+			}
+			SSET_ICON_BACKGROUND_RELIEF(*ps, (signed char)*val);
+			ps->flags.has_icon_background_relief = 1;
+			ps->flag_mask.has_icon_background_relief = 1;
+			ps->change_mask.has_icon_background_relief = 1;
+		}
+		else if (StrEquals(token, "IconFont"))
+		{
+			SAFEFREE(SGET_ICON_FONT(*ps));
+			rest = GetNextToken(rest, &token);
+			SSET_ICON_FONT(*ps, token);
+			S_SET_HAS_ICON_FONT(SCF(*ps), (token != NULL));
+			S_SET_HAS_ICON_FONT(SCM(*ps), 1);
+			S_SET_HAS_ICON_FONT(SCC(*ps), 1);
+
+		}
+		else if (StrEquals(token, "IconOverride"))
+		{
+			S_SET_ICON_OVERRIDE(SCF(*ps), ICON_OVERRIDE);
+			S_SET_ICON_OVERRIDE(SCM(*ps), ICON_OVERRIDE_MASK);
+			S_SET_ICON_OVERRIDE(SCC(*ps), ICON_OVERRIDE_MASK);
+		}
+		else if (StrEquals(token, "IgnoreRestack"))
+		{
+			S_SET_DO_IGNORE_RESTACK(SCF(*ps), on);
+			S_SET_DO_IGNORE_RESTACK(SCM(*ps), 1);
+			S_SET_DO_IGNORE_RESTACK(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "IconTitle"))
+		{
+			S_SET_HAS_NO_ICON_TITLE(SCF(*ps), !on);
+			S_SET_HAS_NO_ICON_TITLE(SCM(*ps), 1);
+			S_SET_HAS_NO_ICON_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "IconTitleColorset"))
+		{
+			*val = -1;
+			GetIntegerArguments(rest,&rest, val, 1);
+			SSET_ICON_TITLE_COLORSET(*ps, *val);
+			alloc_colorset(*val);
+			ps->flags.use_icon_title_colorset = (*val >= 0);
+			ps->flag_mask.use_icon_title_colorset = 1;
+			ps->change_mask.use_icon_title_colorset = 1;
+		}
+		else if (StrEquals(token, "IconTitleRelief"))
+		{
+			*val = ICON_RELIEF_WIDTH;
+			GetIntegerArguments(rest, &rest, val, 1);
+			if (*val < -50)
+			{
+				*val = -50;
+			}
+			else if (*val > 50)
+			{
+				*val = 50;
+			}
+			SSET_ICON_TITLE_RELIEF(*ps, (signed char)*val);
+			ps->flags.has_icon_title_relief = 1;
+			ps->flag_mask.has_icon_title_relief = 1;
+			ps->change_mask.has_icon_title_relief = 1;
+		}
+		else if (StrEquals(token, "IconSize"))
+		{
+			rest = style_parse_icon_size_style(token, rest, ps);
+		}
+		else if (StrEquals(token, "IconBox"))
+		{
+			rest = style_parse_icon_box_style(cur_ib, token, rest,
+							  ps);
+		} /* end iconbox parameter */
+		else if (StrEquals(token, "ICONGRID"))
+		{
+			rest = style_parse_icon_grid_style(token, rest, ps,
+							   *cur_ib);
+		}
+		else if (StrEquals(token, "ICONFILL"))
+		{
+			rest = style_parse_icon_fill_style(token, rest, ps,
+						    *cur_ib);
+		} /* end iconfill */
+		else if (StrEquals(token, "IconifyWindowGroups"))
+		{
+			S_SET_DO_ICONIFY_WINDOW_GROUPS(SCF(*ps), on);
+			S_SET_DO_ICONIFY_WINDOW_GROUPS(SCM(*ps), 1);
+			S_SET_DO_ICONIFY_WINDOW_GROUPS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "IconifyWindowGroupsOff"))
+		{
+			S_SET_DO_ICONIFY_WINDOW_GROUPS(SCF(*ps), !on);
+			S_SET_DO_ICONIFY_WINDOW_GROUPS(SCM(*ps), 1);
+			S_SET_DO_ICONIFY_WINDOW_GROUPS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "Iconifiable"))
+		{
+			S_SET_IS_UNICONIFIABLE(SCF(*ps), !on);
+			S_SET_IS_UNICONIFIABLE(SCM(*ps), 1);
+			S_SET_IS_UNICONIFIABLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "IndexedWindowName"))
+		{
+			S_SET_USE_INDEXED_WINDOW_NAME(SCF(*ps), on);
+			S_SET_USE_INDEXED_WINDOW_NAME(SCM(*ps), 1);
+			S_SET_USE_INDEXED_WINDOW_NAME(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "IndexedIconName"))
+		{
+			S_SET_USE_INDEXED_ICON_NAME(SCF(*ps), on);
+			S_SET_USE_INDEXED_ICON_NAME(SCM(*ps), 1);
+			S_SET_USE_INDEXED_ICON_NAME(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'j':
+		if (0)
+		{
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'k':
+		if (StrEquals(token, "KeepWindowGroupsOnDesk"))
+		{
+			S_SET_DO_USE_WINDOW_GROUP_HINT(SCF(*ps), on);
+			S_SET_DO_USE_WINDOW_GROUP_HINT(SCM(*ps), 1);
+			S_SET_DO_USE_WINDOW_GROUP_HINT(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'l':
+		if (StrEquals(token, "LeftTitleRotatedCW"))
+		{
+			S_SET_IS_LEFT_TITLE_ROTATED_CW(SCF(*ps), on);
+			S_SET_IS_LEFT_TITLE_ROTATED_CW(SCM(*ps), 1);
+			S_SET_IS_LEFT_TITLE_ROTATED_CW(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "LeftTitleRotatedCCW"))
+		{
+			S_SET_IS_LEFT_TITLE_ROTATED_CW(SCF(*ps), !on);
+			S_SET_IS_LEFT_TITLE_ROTATED_CW(SCM(*ps), 1);
+			S_SET_IS_LEFT_TITLE_ROTATED_CW(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "Lenience"))
+		{
+			FPS_LENIENT(S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_LENIENT(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_LENIENT(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "Layer"))
+		{
+			*val = -1;
+			if (GetIntegerArguments(rest, &rest, val, 1) &&
+			    *val < 0)
+			{
+				fvwm_msg(ERR, "style_parse_one_style_option",
+					 "Layer must be positive or zero.");
+			}
+			if (*val < 0)
+			{
+				SSET_LAYER(*ps, -9);
+				/* mark layer unset */
+				ps->flags.use_layer = 0;
+				ps->flag_mask.use_layer = 1;
+				ps->change_mask.use_layer = 1;
+			}
+			else
+			{
+				SSET_LAYER(*ps, *val);
+				ps->flags.use_layer = 1;
+				ps->flag_mask.use_layer = 1;
+				ps->change_mask.use_layer = 1;
+			}
+		}
+		else if (StrEquals(token, "LOWERTRANSIENT"))
+		{
+			S_SET_DO_LOWER_TRANSIENT(SCF(*ps), on);
+			S_SET_DO_LOWER_TRANSIENT(SCM(*ps), 1);
+			S_SET_DO_LOWER_TRANSIENT(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'm':
+		if (StrEquals(token, "ManualPlacement"))
+		{
+			ps->flags.placement_mode = PLACE_MANUAL;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "ManualPlacementHonorsStartsOnPage"))
+		{
+			ps->flags.manual_placement_honors_starts_on_page = on;
+			ps->flag_mask.manual_placement_honors_starts_on_page =
+				1;
+			ps->change_mask.manual_placement_honors_starts_on_page
+				= 1;
+		}
+		else if (StrEquals(
+				 token, "ManualPlacementIgnoresStartsOnPage"))
+		{
+			ps->flags.manual_placement_honors_starts_on_page = !on;
+			ps->flag_mask.manual_placement_honors_starts_on_page =
+				1;
+			ps->change_mask.manual_placement_honors_starts_on_page
+				= 1;
+		}
+		else if (StrEquals(token, "Maximizable"))
+		{
+			S_SET_IS_UNMAXIMIZABLE(SCF(*ps), !on);
+			S_SET_IS_UNMAXIMIZABLE(SCM(*ps), 1);
+			S_SET_IS_UNMAXIMIZABLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "MinOverlapPlacement"))
+		{
+			ps->flags.placement_mode = PLACE_MINOVERLAP;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "MinOverlapPercentPlacement"))
+		{
+			ps->flags.placement_mode = PLACE_MINOVERLAPPERCENT;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "MinOverlapPlacementPenalties"))
+		{
+			float f[6] = {-1, -1, -1, -1, -1, -1};
+			Bool bad = False;
+
+			num = 0;
+			if (rest != NULL)
+			{
+				num = sscanf(
+					rest, "%f %f %f %f %f %f", &f[0],
+					&f[1], &f[2], &f[3], &f[4], &f[5]);
+				for (i=0; i < num; i++)
+				{
+					PeekToken(rest,&rest);
+					if (f[i] < 0)
+						bad = True;
+				}
+			}
+			if (bad)
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"Bad argument to MinOverlap"
+					"PlacementPenalties: %s", rest);
+				break;
+			}
+			SSET_NORMAL_PLACEMENT_PENALTY(*ps, 1);
+			SSET_ONTOP_PLACEMENT_PENALTY(
+				*ps, PLACEMENT_AVOID_ONTOP);
+			SSET_ICON_PLACEMENT_PENALTY(*ps, PLACEMENT_AVOID_ICON);
+			SSET_STICKY_PLACEMENT_PENALTY(
+				*ps, PLACEMENT_AVOID_STICKY);
+			SSET_BELOW_PLACEMENT_PENALTY(
+				*ps, PLACEMENT_AVOID_BELOW);
+			SSET_EWMH_STRUT_PLACEMENT_PENALTY(
+				*ps, PLACEMENT_AVOID_EWMH_STRUT);
+			for (i=0; i < num; i++)
+			{
+				(*ps).placement_penalty[i] = f[i];
+			}
+			ps->flags.has_placement_penalty = 1;
+			ps->flag_mask.has_placement_penalty = 1;
+			ps->change_mask.has_placement_penalty = 1;
+		}
+		else if (StrEquals(
+				 token, "MinOverlapPercentPlacementPenalties"))
+		{
+			Bool bad = False;
+
+			num = GetIntegerArguments(rest, &rest, val, 4);
+			for (i=0; i < num; i++)
+			{
+				if (val[i] < 0)
+					bad = True;
+			}
+			if (bad)
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"Bad argument to MinOverlapPercent"
+					"PlacementPenalties: %s", rest);
+				break;
+			}
+			SSET_99_PLACEMENT_PERCENTAGE_PENALTY(
+				*ps, PLACEMENT_AVOID_COVER_99);
+			SSET_95_PLACEMENT_PERCENTAGE_PENALTY(
+				*ps, PLACEMENT_AVOID_COVER_95);
+			SSET_85_PLACEMENT_PERCENTAGE_PENALTY(
+				*ps, PLACEMENT_AVOID_COVER_85);
+			SSET_75_PLACEMENT_PERCENTAGE_PENALTY(
+				*ps, PLACEMENT_AVOID_COVER_75);
+			for (i=0; i < num; i++)
+			{
+				(*ps).placement_percentage_penalty[i] = val[i];
+			}
+			ps->flags.has_placement_percentage_penalty = 1;
+			ps->flag_mask.has_placement_percentage_penalty = 1;
+			ps->change_mask.has_placement_percentage_penalty = 1;
+		}
+		else if (StrEquals(token, "MwmButtons"))
+		{
+			S_SET_HAS_MWM_BUTTONS(SCF(*ps), on);
+			S_SET_HAS_MWM_BUTTONS(SCM(*ps), 1);
+			S_SET_HAS_MWM_BUTTONS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "MiniIcon"))
+		{
+			if (!FMiniIconsSupported)
+			{
+				break;
+			}
+			rest = GetNextToken(rest, &token);
+			if (token)
+			{
+				SAFEFREE(SGET_MINI_ICON_NAME(*ps));
+				SSET_MINI_ICON_NAME(*ps, token);
+				ps->flags.has_mini_icon = 1;
+				ps->flag_mask.has_mini_icon = 1;
+				ps->change_mask.has_mini_icon = 1;
+			}
+			else
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"MiniIcon Style requires an Argument");
+			}
+		}
+		else if (StrEquals(token, "MwmBorder"))
+		{
+			S_SET_HAS_MWM_BORDER(SCF(*ps), on);
+			S_SET_HAS_MWM_BORDER(SCM(*ps), 1);
+			S_SET_HAS_MWM_BORDER(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "MwmDecor"))
+		{
+			ps->flags.has_mwm_decor = on;
+			ps->flag_mask.has_mwm_decor = 1;
+			ps->change_mask.has_mwm_decor = 1;
+		}
+		else if (StrEquals(token, "MwmFunctions"))
+		{
+			ps->flags.has_mwm_functions = on;
+			ps->flag_mask.has_mwm_functions = 1;
+			ps->change_mask.has_mwm_functions = 1;
+		}
+		else if (StrEquals(token, "MouseFocus"))
+		{
+			style_set_old_focus_policy(ps, 1);
+		}
+		else if (StrEquals(token, "MouseFocusClickRaises"))
+		{
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), on);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "MouseFocusClickRaisesOff"))
+		{
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_FOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_RAISE_UNFOCUSED_CLIENT_CLICK(
+				S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "MaxWindowSize"))
+		{
+			int val1;
+			int val2;
+			int val1_unit;
+			int val2_unit;
+
+			num = GetTwoArguments(
+				rest, &val1, &val2, &val1_unit, &val2_unit);
+			rest = SkipNTokens(rest, num);
+			if (num != 2)
+			{
+				val1 = DEFAULT_MAX_MAX_WINDOW_WIDTH;
+				val2 = DEFAULT_MAX_MAX_WINDOW_HEIGHT;
+			}
+			else
+			{
+				val1 = val1 * val1_unit / 100;
+				val2 = val2 * val2_unit / 100;
+			}
+			if (val1 < DEFAULT_MIN_MAX_WINDOW_WIDTH)
+			{
+				val1 = DEFAULT_MIN_MAX_WINDOW_WIDTH;
+			}
+			if (val1 > DEFAULT_MAX_MAX_WINDOW_WIDTH || val1 <= 0)
+			{
+				val1 = DEFAULT_MAX_MAX_WINDOW_WIDTH;
+			}
+			if (val2 < DEFAULT_MIN_MAX_WINDOW_HEIGHT)
+			{
+				val2 = DEFAULT_MIN_MAX_WINDOW_HEIGHT;
+			}
+			if (val2 > DEFAULT_MAX_MAX_WINDOW_HEIGHT || val2 <= 0)
+			{
+				val2 = DEFAULT_MAX_MAX_WINDOW_HEIGHT;
+			}
+			SSET_MAX_WINDOW_WIDTH(*ps, val1);
+			SSET_MAX_WINDOW_HEIGHT(*ps, val2);
+			ps->flags.has_max_window_size = 1;
+			ps->flag_mask.has_max_window_size = 1;
+			ps->change_mask.has_max_window_size = 1;
+		}
+		else if (StrEquals(token, "MoveByProgramMethod"))
+		{
+			int i;
+			char *methodlist[] = {
+				"AutoDetect",
+				"UseGravity",
+				"IgnoreGravity",
+				NULL
+			};
+
+			i = GetTokenIndex(rest, methodlist, 0, &rest);
+			if (i == -1)
+			{
+				i = WS_CR_MOTION_METHOD_AUTO;
+			}
+			SCR_MOTION_METHOD(&ps->flags) = i;
+			SCR_MOTION_METHOD(&ps->flag_mask) =
+				WS_CR_MOTION_METHOD_MASK;
+			SCR_MOTION_METHOD(&ps->change_mask) =
+				WS_CR_MOTION_METHOD_MASK;
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'n':
+		if (StrEquals(token, "NoActiveIconOverride"))
+		{
+			S_SET_ICON_OVERRIDE(SCF(*ps), NO_ACTIVE_ICON_OVERRIDE);
+			S_SET_ICON_OVERRIDE(SCM(*ps), ICON_OVERRIDE_MASK);
+			S_SET_ICON_OVERRIDE(SCC(*ps), ICON_OVERRIDE_MASK);
+		}
+		else if (StrEquals(token, "NoIconOverride"))
+		{
+			S_SET_ICON_OVERRIDE(SCF(*ps), NO_ICON_OVERRIDE);
+			S_SET_ICON_OVERRIDE(SCM(*ps), ICON_OVERRIDE_MASK);
+			S_SET_ICON_OVERRIDE(SCC(*ps), ICON_OVERRIDE_MASK);
+		}
+		else if (StrEquals(token, "NoIconTitle"))
+		{
+			S_SET_HAS_NO_ICON_TITLE(SCF(*ps), on);
+			S_SET_HAS_NO_ICON_TITLE(SCM(*ps), 1);
+			S_SET_HAS_NO_ICON_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "NOICON"))
+		{
+			S_SET_IS_ICON_SUPPRESSED(SCF(*ps), on);
+			S_SET_IS_ICON_SUPPRESSED(SCM(*ps), 1);
+			S_SET_IS_ICON_SUPPRESSED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "NOTITLE"))
+		{
+			ps->flags.has_no_title = on;
+			ps->flag_mask.has_no_title = 1;
+			ps->change_mask.has_no_title = 1;
+		}
+		else if (StrEquals(token, "NoPPosition"))
+		{
+			ps->flags.use_no_pposition = on;
+			ps->flag_mask.use_no_pposition = 1;
+			ps->change_mask.use_no_pposition = 1;
+		}
+		else if (StrEquals(token, "NoUSPosition"))
+		{
+			ps->flags.use_no_usposition = on;
+			ps->flag_mask.use_no_usposition = 1;
+			ps->change_mask.use_no_usposition = 1;
+		}
+		else if (StrEquals(token, "NoTransientPPosition"))
+		{
+			ps->flags.use_no_transient_pposition = on;
+			ps->flag_mask.use_no_transient_pposition = 1;
+			ps->change_mask.use_no_transient_pposition = 1;
+		}
+		else if (StrEquals(token, "NoTransientUSPosition"))
+		{
+			ps->flags.use_no_transient_usposition = on;
+			ps->flag_mask.use_no_transient_usposition = 1;
+			ps->change_mask.use_no_transient_usposition = 1;
+		}
+		else if (StrEquals(token, "NoIconPosition"))
+		{
+			S_SET_USE_ICON_POSITION_HINT(SCF(*ps), !on);
+			S_SET_USE_ICON_POSITION_HINT(SCM(*ps), 1);
+			S_SET_USE_ICON_POSITION_HINT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "NakedTransient"))
+		{
+			ps->flags.do_decorate_transient = !on;
+			ps->flag_mask.do_decorate_transient = 1;
+			ps->change_mask.do_decorate_transient = 1;
+		}
+		else if (StrEquals(token, "NODECORHINT"))
+		{
+			ps->flags.has_mwm_decor = !on;
+			ps->flag_mask.has_mwm_decor = 1;
+			ps->change_mask.has_mwm_decor = 1;
+		}
+		else if (StrEquals(token, "NOFUNCHINT"))
+		{
+			ps->flags.has_mwm_functions = !on;
+			ps->flag_mask.has_mwm_functions = 1;
+			ps->change_mask.has_mwm_functions = 1;
+		}
+		else if (StrEquals(token, "NOOVERRIDE"))
+		{
+			S_SET_HAS_MWM_OVERRIDE(SCF(*ps), !on);
+			S_SET_HAS_MWM_OVERRIDE(SCM(*ps), 1);
+			S_SET_HAS_MWM_OVERRIDE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "NORESIZEOVERRIDE") ||
+			 StrEquals(token, "NORESIZEHINTOVERRIDE"))
+		{
+			S_SET_HAS_OVERRIDE_SIZE(SCF(*ps), !on);
+			S_SET_HAS_OVERRIDE_SIZE(SCM(*ps), 1);
+			S_SET_HAS_OVERRIDE_SIZE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "NOHANDLES"))
+		{
+			ps->flags.has_no_handles = on;
+			ps->flag_mask.has_no_handles = 1;
+			ps->change_mask.has_no_handles = 1;
+		}
+		else if (StrEquals(token, "NOLENIENCE"))
+		{
+			FPS_LENIENT(S_FOCUS_POLICY(SCF(*ps)), !on);
+			FPS_LENIENT(S_FOCUS_POLICY(SCM(*ps)), 1);
+			FPS_LENIENT(S_FOCUS_POLICY(SCC(*ps)), 1);
+		}
+		else if (StrEquals(token, "NoButton"))
+		{
+			rest = style_parse_button_style(ps, rest, !on);
+		}
+		else if (StrEquals(token, "NOOLDECOR"))
+		{
+			ps->flags.has_ol_decor = !on;
+			ps->flag_mask.has_ol_decor = 1;
+			ps->change_mask.has_ol_decor = 1;
+		}
+		else if (StrEquals(token, "NeverFocus"))
+		{
+			style_set_old_focus_policy(ps, 3);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'o':
+		if (StrEquals(token, "OLDECOR"))
+		{
+			ps->flags.has_ol_decor = on;
+			ps->flag_mask.has_ol_decor = 1;
+			ps->change_mask.has_ol_decor = 1;
+		}
+		else if (StrEquals(token, "Opacity"))
+		{
+			ps->flags.use_parent_relative = !on;
+			ps->flag_mask.use_parent_relative = 1;
+			ps->change_mask.use_parent_relative = 1;
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'p':
+		if (StrEquals(token, "ParentalRelativity"))
+		{
+			ps->flags.use_parent_relative = on;
+			ps->flag_mask.use_parent_relative = 1;
+			ps->change_mask.use_parent_relative = 1;
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'q':
+		if (0)
+		{
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'r':
+		if (StrEquals(token, "RAISETRANSIENT"))
+		{
+			S_SET_DO_RAISE_TRANSIENT(SCF(*ps), on);
+			S_SET_DO_RAISE_TRANSIENT(SCM(*ps), 1);
+			S_SET_DO_RAISE_TRANSIENT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "RANDOMPLACEMENT"))
+		{
+			ps->flags.placement_mode |= PLACE_RANDOM;
+			ps->flag_mask.placement_mode |= PLACE_RANDOM;
+			ps->change_mask.placement_mode |= PLACE_RANDOM;
+		}
+		else if (StrEquals(token, "RECAPTUREHONORSSTARTSONPAGE"))
+		{
+			ps->flags.recapture_honors_starts_on_page = on;
+			ps->flag_mask.recapture_honors_starts_on_page = 1;
+			ps->change_mask.recapture_honors_starts_on_page = 1;
+		}
+		else if (StrEquals(token, "RECAPTUREIGNORESSTARTSONPAGE"))
+		{
+			ps->flags.recapture_honors_starts_on_page = !on;
+			ps->flag_mask.recapture_honors_starts_on_page = 1;
+			ps->change_mask.recapture_honors_starts_on_page = 1;
+		}
+		else if (StrEquals(token, "RESIZEHINTOVERRIDE"))
+		{
+			S_SET_HAS_OVERRIDE_SIZE(SCF(*ps), on);
+			S_SET_HAS_OVERRIDE_SIZE(SCM(*ps), 1);
+			S_SET_HAS_OVERRIDE_SIZE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ResizeOpaque"))
+		{
+			S_SET_DO_RESIZE_OPAQUE(SCF(*ps), on);
+			S_SET_DO_RESIZE_OPAQUE(SCM(*ps), 1);
+			S_SET_DO_RESIZE_OPAQUE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ResizeOutline"))
+		{
+			S_SET_DO_RESIZE_OPAQUE(SCF(*ps), !on);
+			S_SET_DO_RESIZE_OPAQUE(SCM(*ps), 1);
+			S_SET_DO_RESIZE_OPAQUE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ResizeOutlineThin"))
+		{
+			S_SET_DO_RESIZE_OUTLINE_THIN(SCF(*ps), on);
+			S_SET_DO_RESIZE_OUTLINE_THIN(SCM(*ps), 1);
+			S_SET_DO_RESIZE_OUTLINE_THIN(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "RightTitleRotatedCW"))
+		{
+			S_SET_IS_RIGHT_TITLE_ROTATED_CW(SCF(*ps), on);
+			S_SET_IS_RIGHT_TITLE_ROTATED_CW(SCM(*ps), 1);
+			S_SET_IS_RIGHT_TITLE_ROTATED_CW(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "RightTitleRotatedCCW"))
+		{
+			S_SET_IS_RIGHT_TITLE_ROTATED_CW(SCF(*ps), !on);
+			S_SET_IS_RIGHT_TITLE_ROTATED_CW(SCM(*ps), 1);
+			S_SET_IS_RIGHT_TITLE_ROTATED_CW(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 's':
+		if (StrEquals(token, "SMARTPLACEMENT"))
+		{
+			ps->flags.placement_mode |= PLACE_SMART;
+			ps->flag_mask.placement_mode |= PLACE_SMART;
+			ps->change_mask.placement_mode |= PLACE_SMART;
+		}
+		else if (StrEquals(token, "SkipMapping"))
+		{
+			S_SET_DO_NOT_SHOW_ON_MAP(SCF(*ps), on);
+			S_SET_DO_NOT_SHOW_ON_MAP(SCM(*ps), 1);
+			S_SET_DO_NOT_SHOW_ON_MAP(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ShowMapping"))
+		{
+			S_SET_DO_NOT_SHOW_ON_MAP(SCF(*ps), !on);
+			S_SET_DO_NOT_SHOW_ON_MAP(SCM(*ps), 1);
+			S_SET_DO_NOT_SHOW_ON_MAP(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StackTransientParent"))
+		{
+			S_SET_DO_STACK_TRANSIENT_PARENT(SCF(*ps), on);
+			S_SET_DO_STACK_TRANSIENT_PARENT(SCM(*ps), 1);
+			S_SET_DO_STACK_TRANSIENT_PARENT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyIcon"))
+		{
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCF(*ps), on);
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCM(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCC(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCF(*ps), on);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCM(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyAcrossPagesIcon"))
+		{
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCF(*ps), on);
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCM(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyAcrossDesksIcon"))
+		{
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCF(*ps), on);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCM(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "SlipperyIcon"))
+		{
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCF(*ps), !on);
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCM(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_PAGES(SCC(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCF(*ps), !on);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCM(*ps), 1);
+			S_SET_IS_ICON_STICKY_ACROSS_DESKS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "SloppyFocus"))
+		{
+			style_set_old_focus_policy(ps, 2);
+		}
+		else if (StrEquals(token, "StartIconic"))
+		{
+			ps->flags.do_start_iconic = on;
+			ps->flag_mask.do_start_iconic = 1;
+			ps->change_mask.do_start_iconic = 1;
+		}
+		else if (StrEquals(token, "StartNormal"))
+		{
+			ps->flags.do_start_iconic = !on;
+			ps->flag_mask.do_start_iconic = 1;
+			ps->change_mask.do_start_iconic = 1;
+		}
+		else if (StrEquals(token, "StaysOnBottom"))
+		{
+			SSET_LAYER(
+				*ps, (on) ? Scr.BottomLayer : Scr.DefaultLayer);
+			ps->flags.use_layer = 1;
+			ps->flag_mask.use_layer = 1;
+			ps->change_mask.use_layer = 1;
+		}
+		else if (StrEquals(token, "StaysOnTop"))
+		{
+			SSET_LAYER(
+				*ps, (on) ? Scr.BottomLayer : Scr.DefaultLayer);
+			SSET_LAYER(*ps, Scr.TopLayer);
+			ps->flags.use_layer = 1;
+			ps->flag_mask.use_layer = 1;
+			ps->change_mask.use_layer = 1;
+		}
+		else if (StrEquals(token, "StaysPut"))
+		{
+			SSET_LAYER(*ps, Scr.DefaultLayer);
+			ps->flags.use_layer = 1;
+			ps->flag_mask.use_layer = 1;
+			ps->change_mask.use_layer = 1;
+		}
+		else if (StrEquals(token, "Sticky"))
+		{
+			S_SET_IS_STICKY_ACROSS_PAGES(SCF(*ps), on);
+			S_SET_IS_STICKY_ACROSS_PAGES(SCM(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_PAGES(SCC(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCF(*ps), on);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCM(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyAcrossPages"))
+		{
+			S_SET_IS_STICKY_ACROSS_PAGES(SCF(*ps), on);
+			S_SET_IS_STICKY_ACROSS_PAGES(SCM(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_PAGES(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyAcrossDesks"))
+		{
+			S_SET_IS_STICKY_ACROSS_DESKS(SCF(*ps), on);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCM(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyStippledTitle"))
+		{
+			S_SET_HAS_NO_STICKY_STIPPLED_TITLE(SCF(*ps), !on);
+			S_SET_HAS_NO_STICKY_STIPPLED_TITLE(SCM(*ps), 1);
+			S_SET_HAS_NO_STICKY_STIPPLED_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StickyStippledIconTitle"))
+		{
+			S_SET_HAS_NO_STICKY_STIPPLED_ICON_TITLE(SCF(*ps), !on);
+			S_SET_HAS_NO_STICKY_STIPPLED_ICON_TITLE(SCM(*ps), 1);
+			S_SET_HAS_NO_STICKY_STIPPLED_ICON_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "Slippery"))
+		{
+			S_SET_IS_STICKY_ACROSS_PAGES(SCF(*ps), !on);
+			S_SET_IS_STICKY_ACROSS_PAGES(SCM(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_PAGES(SCC(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCF(*ps), !on);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCM(*ps), 1);
+			S_SET_IS_STICKY_ACROSS_DESKS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "STARTSONDESK"))
+		{
+			spargs = GetIntegerArguments(rest, NULL, tmpno, 1);
+			if (spargs == 1)
+			{
+				PeekToken(rest,&rest);
+				ps->flags.use_start_on_desk = 1;
+				ps->flag_mask.use_start_on_desk = 1;
+				ps->change_mask.use_start_on_desk = 1;
+				/*  RBW - 11/20/1998 - allow for the special
+				 * case of -1  */
+				SSET_START_DESK(
+					*ps, (tmpno[0] > -1) ?
+					tmpno[0] + 1 : tmpno[0]);
+			}
+			else
+			{
+				fvwm_msg(ERR,"style_parse_one_style_option",
+					 "bad StartsOnDesk arg: %s", rest);
+			}
+		}
+		/* StartsOnPage is like StartsOnDesk-Plus */
+		else if (StrEquals(token, "STARTSONPAGE"))
+		{
+			char *ret_rest;
+			spargs = GetIntegerArguments(rest, &ret_rest,
+						     tmpno, 3);
+			if (spargs == 1 || spargs == 3)
+			{
+				/* We have a desk no., with or without page. */
+				/* RBW - 11/20/1998 - allow for the special
+				 * case of -1 */
+				/* Desk is now actual + 1 */
+				SSET_START_DESK(
+					*ps, (tmpno[0] > -1) ?
+					tmpno[0] + 1 : tmpno[0]);
+			}
+			if (spargs == 2 || spargs == 3)
+			{
+				if (spargs == 3)
+				{
+					/*  RBW - 11/20/1998 - allow for the
+					 * special case of -1  */
+					SSET_START_PAGE_X(
+						*ps, (tmpno[1] > -1) ?
+						tmpno[1] + 1 : tmpno[1]);
+					SSET_START_PAGE_Y(
+						*ps, (tmpno[2] > -1) ?
+						tmpno[2] + 1 : tmpno[2]);
+				}
+				else
+				{
+					SSET_START_PAGE_X(
+						*ps, (tmpno[0] > -1) ?
+						tmpno[0] + 1 : tmpno[0]);
+					SSET_START_PAGE_Y(
+						*ps, (tmpno[1] > -1) ?
+						tmpno[1] + 1 : tmpno[1]);
+				}
+			}
+			if (spargs < 1 || spargs > 3)
+			{
+				fvwm_msg(ERR, "style_parse_one_style_option",
+					 "bad StartsOnPage args: %s", rest);
+			}
+			else
+			{
+				ps->flags.use_start_on_desk = 1;
+				ps->flag_mask.use_start_on_desk = 1;
+				ps->change_mask.use_start_on_desk = 1;
+			}
+			rest = ret_rest;
+		}
+		else if (StrEquals(token, "STARTSONPAGEINCLUDESTRANSIENTS"))
+		{
+			ps->flags.use_start_on_page_for_transient = on;
+			ps->flag_mask.use_start_on_page_for_transient = 1;
+			ps->change_mask.use_start_on_page_for_transient = 1;
+		}
+		else if (StrEquals(token, "STARTSONPAGEIGNORESTRANSIENTS"))
+		{
+			ps->flags.use_start_on_page_for_transient = !on;
+			ps->flag_mask.use_start_on_page_for_transient = 1;
+			ps->change_mask.use_start_on_page_for_transient = 1;
+		}
+		else if (StrEquals(token, "StartsOnScreen"))
+		{
+			if (rest)
+			{
+				tmpno[0] = FScreenGetScreenArgument(rest, 'c');
+				PeekToken(rest,&rest);
+				ps->flags.use_start_on_screen = 1;
+				ps->flag_mask.use_start_on_screen = 1;
+				ps->change_mask.use_start_on_screen = 1;
+				SSET_START_SCREEN(*ps, tmpno[0]);
+			}
+			else
+			{
+				ps->flags.use_start_on_screen = 0;
+				ps->flag_mask.use_start_on_screen = 1;
+				ps->change_mask.use_start_on_screen = 1;
+			}
+		}
+		else if (StrEquals(token, "STARTSANYWHERE"))
+		{
+			ps->flags.use_start_on_desk = 0;
+			ps->flag_mask.use_start_on_desk = 1;
+			ps->change_mask.use_start_on_desk = 1;
+		}
+		else if (StrEquals(token, "STARTSLOWERED"))
+		{
+			ps->flags.do_start_lowered = on;
+			ps->flag_mask.do_start_lowered = 1;
+			ps->change_mask.do_start_lowered = 1;
+		}
+		else if (StrEquals(token, "STARTSRAISED"))
+		{
+			ps->flags.do_start_lowered = !on;
+			ps->flag_mask.do_start_lowered = 1;
+			ps->change_mask.do_start_lowered = 1;
+		}
+		else if (StrEquals(token, "SaveUnder"))
+		{
+			ps->flags.do_save_under = on;
+			ps->flag_mask.do_save_under = 1;
+			ps->change_mask.do_save_under = 1;
+		}
+		else if (StrEquals(token, "SaveUnderOff"))
+		{
+			ps->flags.do_save_under = !on;
+			ps->flag_mask.do_save_under = 1;
+			ps->change_mask.do_save_under = 1;
+		}
+		else if (StrEquals(token, "StippledTitle"))
+		{
+			S_SET_HAS_STIPPLED_TITLE(SCF(*ps), on);
+			S_SET_HAS_STIPPLED_TITLE(SCM(*ps), 1);
+			S_SET_HAS_STIPPLED_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StippledTitleOff"))
+		{
+			S_SET_HAS_STIPPLED_TITLE(SCF(*ps), !on);
+			S_SET_HAS_STIPPLED_TITLE(SCM(*ps), 1);
+			S_SET_HAS_STIPPLED_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "StippledIconTitle"))
+		{
+			S_SET_HAS_STIPPLED_ICON_TITLE(SCF(*ps), on);
+			S_SET_HAS_STIPPLED_ICON_TITLE(SCM(*ps), 1);
+			S_SET_HAS_STIPPLED_ICON_TITLE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "ScatterWindowGroups"))
+		{
+			S_SET_DO_USE_WINDOW_GROUP_HINT(SCF(*ps), !on);
+			S_SET_DO_USE_WINDOW_GROUP_HINT(SCM(*ps), 1);
+			S_SET_DO_USE_WINDOW_GROUP_HINT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "State"))
+		{
+			unsigned int mask;
+			unsigned int states;
+
+			spargs = GetIntegerArguments(rest, NULL, tmpno, 1);
+			if (spargs == 1 && tmpno[0] >= 0 && tmpno[0] <= 31)
+			{
+				PeekToken(rest,&rest);
+				states = S_USER_STATES(SCF(*ps));
+				mask = (1 << tmpno[0]);
+				if (on)
+				{
+					states |= mask;
+				}
+				else
+				{
+					states &= ~mask;
+				}
+				S_SET_USER_STATES(SCF(*ps), states);
+				S_ADD_USER_STATES(SCM(*ps), mask);
+				S_ADD_USER_STATES(SCC(*ps), mask);
+			}
+			else
+			{
+				fvwm_msg(
+					ERR,"style_parse_one_style_option",
+					"bad State arg: %s", rest);
+			}
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 't':
+		if (StrEquals(token, "TileCascadePlacement"))
+		{
+			ps->flags.placement_mode = PLACE_TILECASCADE;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "TileManualPlacement"))
+		{
+			ps->flags.placement_mode = PLACE_TILEMANUAL;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "Title"))
+		{
+			ps->flags.has_no_title = !on;
+			ps->flag_mask.has_no_title = 1;
+			ps->change_mask.has_no_title = 1;
+		}
+		else if (StrEquals(token, "TitleAtBottom"))
+		{
+			S_SET_TITLE_DIR(SCF(*ps), DIR_S);
+			S_SET_TITLE_DIR(SCM(*ps), DIR_MAJOR_MASK);
+			S_SET_TITLE_DIR(SCC(*ps), DIR_MAJOR_MASK);
+		}
+		else if (StrEquals(token, "TitleAtTop"))
+		{
+			S_SET_TITLE_DIR(SCF(*ps), DIR_N);
+			S_SET_TITLE_DIR(SCM(*ps), DIR_MAJOR_MASK);
+			S_SET_TITLE_DIR(SCC(*ps), DIR_MAJOR_MASK);
+		}
+		else if (StrEquals(token, "TitleAtLeft"))
+		{
+			S_SET_TITLE_DIR(SCF(*ps), DIR_W);
+			S_SET_TITLE_DIR(SCM(*ps), DIR_MAJOR_MASK);
+			S_SET_TITLE_DIR(SCC(*ps), DIR_MAJOR_MASK);
+		}
+		else if (StrEquals(token, "TitleAtRight"))
+		{
+			S_SET_TITLE_DIR(SCF(*ps), DIR_E);
+			S_SET_TITLE_DIR(SCM(*ps), DIR_MAJOR_MASK);
+			S_SET_TITLE_DIR(SCC(*ps), DIR_MAJOR_MASK);
+		}
+		else if (StrEquals(token, "TopTitleRotated"))
+		{
+			S_SET_IS_TOP_TITLE_ROTATED(SCF(*ps), on);
+			S_SET_IS_TOP_TITLE_ROTATED(SCM(*ps), 1);
+			S_SET_IS_TOP_TITLE_ROTATED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "TopTitleNotRotated"))
+		{
+			S_SET_IS_TOP_TITLE_ROTATED(SCF(*ps), !on);
+			S_SET_IS_TOP_TITLE_ROTATED(SCM(*ps), 1);
+			S_SET_IS_TOP_TITLE_ROTATED(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'u':
+		if (StrEquals(token, "UnderMousePlacement"))
+		{
+			ps->flags.placement_mode = PLACE_UNDERMOUSE;
+			ps->flag_mask.placement_mode = PLACE_MASK;
+			ps->change_mask.placement_mode = PLACE_MASK;
+		}
+		else if (StrEquals(token, "UsePPosition"))
+		{
+			ps->flags.use_no_pposition = !on;
+			ps->flag_mask.use_no_pposition = 1;
+			ps->change_mask.use_no_pposition = 1;
+		}
+		else if (StrEquals(token, "UseUSPosition"))
+		{
+			ps->flags.use_no_usposition = !on;
+			ps->flag_mask.use_no_usposition = 1;
+			ps->change_mask.use_no_usposition = 1;
+		}
+		else if (StrEquals(token, "UseTransientPPosition"))
+		{
+			ps->flags.use_no_transient_pposition = !on;
+			ps->flag_mask.use_no_transient_pposition = 1;
+			ps->change_mask.use_no_transient_pposition = 1;
+		}
+		else if (StrEquals(token, "UseTransientUSPosition"))
+		{
+			ps->flags.use_no_transient_usposition = !on;
+			ps->flag_mask.use_no_transient_usposition = 1;
+			ps->change_mask.use_no_transient_usposition = 1;
+		}
+		else if (StrEquals(token, "UseIconPosition"))
+		{
+			S_SET_USE_ICON_POSITION_HINT(SCF(*ps), on);
+			S_SET_USE_ICON_POSITION_HINT(SCM(*ps), 1);
+			S_SET_USE_ICON_POSITION_HINT(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "UseTitleDecorRotation"))
+		{
+			S_SET_USE_TITLE_DECOR_ROTATION(SCF(*ps), on);
+			S_SET_USE_TITLE_DECOR_ROTATION(SCM(*ps), 1);
+			S_SET_USE_TITLE_DECOR_ROTATION(SCC(*ps), 1);
+		}
+#ifdef USEDECOR
+		else if (StrEquals(token, "UseDecor"))
+		{
+			SAFEFREE(SGET_DECOR_NAME(*ps));
+			rest = GetNextToken(rest, &token);
+			SSET_DECOR_NAME(*ps, token);
+			ps->flags.has_decor = (token != NULL);
+			ps->flag_mask.has_decor = 1;
+			ps->change_mask.has_decor = 1;
+		}
+#endif
+		else if (StrEquals(token, "UseStyle"))
+		{
+			int hit;
+
+			token = PeekToken(rest, &rest);
+			if (!token)
+			{
+				fvwm_msg(ERR, "style_parse_one_style_option",
+					 "UseStyle needs an argument");
+				break;
+			}
+			hit = 0;
+			/* changed to accum multiple Style definitions
+			 * (veliaa@rpi.edu) */
+			for (add_style = all_styles; add_style;
+			     add_style = SGET_NEXT_STYLE(*add_style))
+			{
+				if (SGET_ID_HAS_NAME(*add_style) &&
+				    StrEquals(token, SGET_NAME(*add_style)))
+				{
+					/* match style */
+					hit = 1;
+					merge_styles(ps, add_style, True);
+				} /* end found matching style */
+			} /* end looking at all styles */
+			/* move forward one word */
+			if (!hit)
+			{
+				fvwm_msg(
+					ERR, "style_parse_one_style_option",
+					"UseStyle: %s style not found", token);
+			}
+		}
+		else if (StrEquals(token, "Unmanaged"))
+		{
+			ps->flags.is_unmanaged = on;
+			ps->flag_mask.is_unmanaged = 1;
+			ps->change_mask.is_unmanaged = 1;
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'v':
+		if (StrEquals(token, "VariablePosition") ||
+		    StrEquals(token, "VariableUSPosition"))
+		{
+			S_SET_IS_FIXED(SCF(*ps), !on);
+			S_SET_IS_FIXED(SCM(*ps), 1);
+			S_SET_IS_FIXED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "VariablePPosition"))
+		{
+			S_SET_IS_FIXED_PPOS(SCF(*ps), !on);
+			S_SET_IS_FIXED_PPOS(SCM(*ps), 1);
+			S_SET_IS_FIXED_PPOS(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "VariableSize") ||
+			 StrEquals(token, "VariableUSSize"))
+		{
+			S_SET_IS_SIZE_FIXED(SCF(*ps), !on);
+			S_SET_IS_SIZE_FIXED(SCM(*ps), 1);
+			S_SET_IS_SIZE_FIXED(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "VariablePSize"))
+		{
+			S_SET_IS_PSIZE_FIXED(SCF(*ps), !on);
+			S_SET_IS_PSIZE_FIXED(SCM(*ps), 1);
+			S_SET_IS_PSIZE_FIXED(SCC(*ps), 1);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'w':
+		if (StrEquals(token, "WindowListSkip"))
+		{
+			S_SET_DO_WINDOW_LIST_SKIP(SCF(*ps), on);
+			S_SET_DO_WINDOW_LIST_SKIP(SCM(*ps), 1);
+			S_SET_DO_WINDOW_LIST_SKIP(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "WindowListHit"))
+		{
+			S_SET_DO_WINDOW_LIST_SKIP(SCF(*ps), !on);
+			S_SET_DO_WINDOW_LIST_SKIP(SCM(*ps), 1);
+			S_SET_DO_WINDOW_LIST_SKIP(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "WindowShadeSteps"))
+		{
+			int n = 0;
+			int val = 0;
+			int unit = 0;
+
+			n = GetOnePercentArgument(rest, &val, &unit);
+			if (n != 1)
+			{
+				val = 0;
+			}
+			else
+			{
+				PeekToken(rest,&rest);
+			}
+			/* we have a 'pixel' suffix if unit != 0; negative
+			 * values mean pixels */
+			val = (unit != 0) ? -val : val;
+			ps->flags.has_window_shade_steps = 1;
+			ps->flag_mask.has_window_shade_steps = 1;
+			ps->change_mask.has_window_shade_steps = 1;
+			SSET_WINDOW_SHADE_STEPS(*ps, val);
+		}
+		else if (StrEquals(token, "WindowShadeScrolls"))
+		{
+			S_SET_DO_SHRINK_WINDOWSHADE(SCF(*ps), !on);
+			S_SET_DO_SHRINK_WINDOWSHADE(SCM(*ps), 1);
+			S_SET_DO_SHRINK_WINDOWSHADE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "WindowShadeShrinks"))
+		{
+			S_SET_DO_SHRINK_WINDOWSHADE(SCF(*ps), on);
+			S_SET_DO_SHRINK_WINDOWSHADE(SCM(*ps), 1);
+			S_SET_DO_SHRINK_WINDOWSHADE(SCC(*ps), 1);
+		}
+		else if (StrEquals(token, "WindowShadeLazy"))
+		{
+			S_SET_WINDOWSHADE_LAZINESS(SCF(*ps), WINDOWSHADE_LAZY);
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCM(*ps), WINDOWSHADE_LAZY_MASK);
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCC(*ps), WINDOWSHADE_LAZY_MASK);
+		}
+		else if (StrEquals(token, "WindowShadeAlwaysLazy"))
+		{
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCF(*ps), WINDOWSHADE_ALWAYS_LAZY);
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCM(*ps), WINDOWSHADE_LAZY_MASK);
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCC(*ps), WINDOWSHADE_LAZY_MASK);
+		}
+		else if (StrEquals(token, "WindowShadeBusy"))
+		{
+			S_SET_WINDOWSHADE_LAZINESS(SCF(*ps), WINDOWSHADE_BUSY);
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCM(*ps), WINDOWSHADE_LAZY_MASK);
+			S_SET_WINDOWSHADE_LAZINESS(
+				SCC(*ps), WINDOWSHADE_LAZY_MASK);
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	case 'x':
+	case 'y':
+	case 'z':
+		if (0)
+		{
+		}
+		else
+		{
+			found = False;
+		}
+		break;
+
+	default:
+		found = False;
+		break;
+	}
+	if (ret_rest)
+	{
+		*ret_rest = rest;
+	}
+	if (token_l != NULL)
+	{
+		free(token_l);
+	}
+
+	return found;
+}
+
+static
+void parse_and_set_window_style(char *action, char *prefix, window_style *ps)
+{
+	char *line;
+	char *option;
+	char *token;
+	char *rest;
+	Bool found;
+	/* which current boxes to chain to */
+	icon_boxes *cur_ib = NULL;
+
+	while (isspace((unsigned char)*action))
+	{
+		action++;
+	}
+	line = action;
+	while (action && *action && *action != '\n')
+	{
+		action = GetNextFullOption(action, &option);
+		if (!option)
+		{
+			break;
+		}
+		token = PeekToken(option, &rest);
+		if (!token)
+		{
+			free(option);
+			break;
+		}
+
+		/* It might make more sense to capture the whole word, fix its
+		 * case, and use strcmp, but there aren't many caseless compares
+		 * because of this "switch" on the first letter. */
+		found = style_parse_one_style_option(
+			token, rest, &rest, prefix, ps, &cur_ib);
+
+		if (found == False)
+		{
+			fvwm_msg(
+				ERR, "style_parse_and_set_window_style",
+				"Bad style option: %s", option);
+			/* Can't return here since all malloced memory will be
+			 * lost. Ignore rest of line instead. */
+			/* No, I think we /can/ return here. In fact, /not/
+			 * bombing out leaves a half-done style in the list!
+			 * N.Bird 07-Sep-1999 */
+			/* domivogt (01-Oct-1999): Which is exactly what we
+			 * want! Why should all the styles be thrown away if a
+			 * single one is mis-spelled? Let's just continue
+			 * parsing styles. */
+		}
+		else
+		{
+			rest = SkipSpaces(rest,NULL,0);
+			if (*rest)
+			{
+				fvwm_msg(WARN,
+					 "style_parse_and_set_window_style",
+					 "Unconsumed argument in %s: %s",
+					 option, rest);
+			}
+		}
+		free(option);
+	} /* end while still stuff on command */
+
+	return;
+}
+
+/* Process a style command.  First built up in a temp area.
+ * If valid, added to the list in a malloced area.
+ *
+ *		      *** Important note ***
+ *
+ * Remember that *all* styles need a flag, flag_mask and change_mask.
+ * It is not enough to add the code for new styles in this function.
+ * There *must* be corresponding code in handle_new_window_style()
+ * and merge_styles() too.  And don't forget that allocated memory
+ * must be freed in ProcessDestroyStyle().
+ */
+
+static void __style_command(F_CMD_ARGS, char *prefix, Bool is_window_style)
+{
+	/* temp area to build name list */
+	window_style *ps;
+
+	ps = (window_style *)safemalloc(sizeof(window_style));
+	/* init temp window_style area */
+	memset(ps, 0, sizeof(window_style));
+	/* init default focus policy */
+	fpol_init_default_fp(&S_FOCUS_POLICY(SCF(*ps)));
+	/* mark style as changed */
+	ps->has_style_changed = 1;
+	/* set global flag */
+	Scr.flags.do_need_window_update = 1;
+	/* default StartsOnPage behavior for initial capture */
+	ps->flags.capture_honors_starts_on_page = 1;
+
+	if (!is_window_style)
+	{
+		/* parse style name */
+		action = GetNextToken(action, &SGET_NAME(*ps));
+		/* in case there was no argument! */
+		if (SGET_NAME(*ps) == NULL)
+		{
+			free(ps);
+			return;
+		}
+		SSET_ID_HAS_NAME(*ps, True);
+	}
+	else
+	{
+		SSET_WINDOW_ID(*ps, (XID)FW_W(exc->w.fw));
+		SSET_ID_HAS_WINDOW_ID(*ps, True);
+		CopyString(&SGET_NAME(*ps), ""); /* safe */
+	}
+
+	if (action == NULL)
+	{
+		free(SGET_NAME(*ps));
+		free(ps);
+		return;
+	}
+
+	parse_and_set_window_style(action, prefix, ps);
+
+	/* capture default icons */
+	if (SGET_ID_HAS_NAME(*ps) && StrEquals(SGET_NAME(*ps), "*"))
+	{
+		if (ps->flags.has_icon == 1)
+		{
+			if (Scr.DefaultIcon)
+			{
+				free(Scr.DefaultIcon);
+			}
+			Scr.DefaultIcon = SGET_ICON_NAME(*ps);
+			ps->flags.has_icon = 0;
+			ps->flag_mask.has_icon = 0;
+			ps->change_mask.has_icon = 1;
+			SSET_ICON_NAME(*ps, NULL);
+		}
+	}
+	if (last_style_in_list && styles_have_same_id(ps, last_style_in_list))
+	{
+		/* merge with previous style */
+		merge_styles(last_style_in_list, ps, True);
+		free_style(ps);
+		free(ps);
+	}
+	else
+	{
+		/* add temp name list to list */
+		add_style_to_list(ps);
+		cleanup_style_defaults(ps);
+	}
+
+	return;
+}
+
+/* ---------------------------- interface functions ------------------------ */
+
+/* Compare two flag structures passed as byte arrays. Only compare bits set in
+ * the mask.
+ *
+ *  Returned Value:
+ *	zero if the flags are the same
+ *	non-zero otherwise
+ *
+ *  Inputs:
+ *	flags1 - first byte array of flags to compare
+ *	flags2 - second byte array of flags to compare
+ *	mask   - byte array of flags to be considered for the comparison
+ *	len    - number of bytes to compare */
+Bool blockcmpmask(char *blk1, char *blk2, char *mask, int length)
+{
+	int i;
+
+	for (i = 0; i < length; i++)
+	{
+		if ((blk1[i] & mask[i]) != (blk2[i] & mask[i]))
+		{
+			/* flags are not the same, return 1 */
+			return False;
+		}
+	}
+	return True;
+}
+
+void free_icon_boxes(icon_boxes *ib)
+{
+	icon_boxes *temp;
+
+	for ( ; ib != NULL; ib = temp)
+	{
+		temp = ib->next;
+		if (ib->use_count == 0)
+		{
+			free(ib);
+		}
+		else
+		{
+			/* we can't delete the icon box yet, it is still in use
+			 */
+			ib->is_orphan = True;
+		}
+	}
+
+	return;
+}
+
+void simplify_style_list(void)
+{
+	/* one pass through the style list, then process other events first */
+	Scr.flags.do_need_style_list_update = __simplify_style_list();
+
+	return;
+}
+
+/* lookup_style - look through a list for a window name, or class
+ *
+ *  Returned Value:
+ *	merged matching styles in callers window_style.
+ *
+ *  Inputs:
+ *	fw     - FvwmWindow structure to match against
+ *	styles - callers return area
+ */
+void lookup_style(FvwmWindow *fw, window_style *styles)
+{
+	window_style *nptr;
+
+	/* clear callers return area */
+	memset(styles, 0, sizeof(window_style));
+
+	/* look thru all styles in order defined. */
+	for (nptr = all_styles; nptr != NULL; nptr = SGET_NEXT_STYLE(*nptr))
+	{
+		if (fw_match_style_id(fw, SGET_ID(*nptr)))
+		{
+			merge_styles(styles, nptr, False);
+		}
+	}
+	if (!DO_IGNORE_GNOME_HINTS(fw))
+	{
+		window_style gnome_style;
+
+		/* use GNOME hints if not overridden by user with
+		 * GNOMEIgnoreHitns */
+		memset(&gnome_style, 0, sizeof(window_style));
+		GNOME_GetStyle(fw, &gnome_style);
+		merge_styles(&gnome_style, styles, False);
+		memcpy(styles, &gnome_style, sizeof(window_style));
+	}
+	EWMH_GetStyle(fw, styles);
+
+	return;
+}
+
+/* This function sets the style update flags as necessary */
+void check_window_style_change(
+	FvwmWindow *t, update_win *flags, window_style *ret_style)
+{
+	int i;
+	char *wf;
+	char *sf;
+	char *sc;
+
+	lookup_style(t, ret_style);
+	if (!ret_style->has_style_changed && !IS_STYLE_DELETED(t))
+	{
+		/* nothing to do */
+		return;
+	}
+
+	/* do_ignore_gnome_hints
+	 *
+	 * must handle these first because they may alter the style */
+	if (S_DO_IGNORE_GNOME_HINTS(SCC(*ret_style)) &&
+	    !S_DO_IGNORE_GNOME_HINTS(SCF(*ret_style)))
+	{
+		GNOME_GetStyle(t, ret_style);
+		/* may need further treatment for some styles */
+		flags->do_update_gnome_styles = 1;
+	}
+
+	/*** common style flags ***/
+
+	wf = (char *)(&FW_COMMON_STATIC_FLAGS(t));
+	sf = (char *)(&SCFS(*ret_style));
+	if (IS_STYLE_DELETED(t))
+	{
+		/* update all styles */
+		memset(flags, 0xff, sizeof(*flags));
+		SET_STYLE_DELETED(t, 0);
+		/* copy the static common window flags */
+		for (i = 0; i < sizeof(SCFS(*ret_style)); i++)
+		{
+			wf[i] = sf[i];
+		}
+
+		return;
+	}
+	/* All static common styles can simply be copied. For some there is
+	 * additional work to be done below. */
+	sc = (char *)(&SCCS(*ret_style));
+	for (i = 0; i < sizeof(SCFS(*ret_style)); i++)
+	{
+		wf[i] = (wf[i] & ~sc[i]) | (sf[i] & sc[i]);
+		sf[i] = wf[i];
+	}
+
+	/* is_sticky
+	 * is_icon_sticky */
+	if (S_IS_STICKY_ACROSS_PAGES(SCC(*ret_style)) ||
+	    S_IS_STICKY_ACROSS_DESKS(SCC(*ret_style)))
+	{
+		flags->do_update_stick = 1;
+	}
+	else if (S_IS_ICON_STICKY_ACROSS_PAGES(SCC(*ret_style)) &&
+		 IS_ICONIFIED(t) && !IS_STICKY_ACROSS_PAGES(t))
+	{
+		flags->do_update_stick_icon = 1;
+	}
+	else if (S_IS_ICON_STICKY_ACROSS_DESKS(SCC(*ret_style)) &&
+		 IS_ICONIFIED(t) && !IS_STICKY_ACROSS_DESKS(t))
+	{
+		flags->do_update_stick_icon = 1;
+	}
+
+	/* focus policy */
+	if (fpol_is_policy_changed(&S_FOCUS_POLICY(SCC(*ret_style))))
+	{
+		flags->do_setup_focus_policy = 1;
+	}
+
+	/* is_left_title_rotated_cw
+	 * is_right_title_rotated_cw
+	 * is_top_title_rotated
+	 * is_bottom_title_rotated */
+	if (S_IS_LEFT_TITLE_ROTATED_CW(SCC(*ret_style)) ||
+	    S_IS_RIGHT_TITLE_ROTATED_CW(SCC(*ret_style)) ||
+	    S_IS_TOP_TITLE_ROTATED(SCC(*ret_style)) ||
+	    S_IS_BOTTOM_TITLE_ROTATED(SCC(*ret_style)))
+	{
+		flags->do_update_title_text_dir = 1;
+	}
+
+	/* title_dir */
+	if (S_TITLE_DIR(SCC(*ret_style)))
+	{
+		flags->do_update_title_dir = 1;
+	}
+
+	/* use_title_decor_rotation */
+	if (S_USE_TITLE_DECOR_ROTATION(SCC(*ret_style)))
+	{
+		flags->do_update_rotated_title = 1;
+	}
+
+	/* has_mwm_border
+	 * has_mwm_buttons */
+	if (S_HAS_MWM_BORDER(SCC(*ret_style)) ||
+	    S_HAS_MWM_BUTTONS(SCC(*ret_style)))
+	{
+		flags->do_redecorate = 1;
+	}
+
+	/* has_icon_font */
+	if (S_HAS_ICON_FONT(SCC(*ret_style)))
+	{
+		flags->do_update_icon_font = 1;
+	}
+
+	/* has_window_font */
+	if (S_HAS_WINDOW_FONT(SCC(*ret_style)))
+	{
+		flags->do_update_window_font = 1;
+	}
+
+	/* has_stippled_title */
+	if (S_HAS_STIPPLED_TITLE(SCC(*ret_style)) ||
+	    S_HAS_NO_STICKY_STIPPLED_TITLE(SCC(*ret_style)) ||
+	    S_HAS_STIPPLED_ICON_TITLE(SCC(*ret_style)) ||
+	    S_HAS_NO_STICKY_STIPPLED_ICON_TITLE(SCC(*ret_style)))
+	{
+		flags->do_redraw_decoration = 1;
+	}
+
+	/* has_no_icon_title
+	 * is_icon_suppressed
+	 *
+	 * handled below */
+
+	/*** private style flags ***/
+
+	/* nothing to do for these flags (only used when mapping new windows):
+	 *
+	 *   do_place_random
+	 *   do_place_smart
+	 *   do_start_lowered
+	 *   use_no_pposition
+	 *   use_no_usposition
+	 *   use_no_transient_pposition
+	 *   use_no_transient_usposition
+	 *   use_start_on_desk
+	 *   use_start_on_page_for_transient
+	 *   use_start_on_screen
+	 *   manual_placement_honors_starts_on_page
+	 *   capture_honors_starts_on_page
+	 *   recapture_honors_starts_on_page
+	 *   use_layer
+	 *   ewmh_placement_mode
+	 */
+
+	/* not implemented yet:
+	 *
+	 *   handling the 'usestyle' style
+	 */
+
+	/* do_window_list_skip */
+	if (S_DO_WINDOW_LIST_SKIP(SCC(*ret_style)))
+	{
+		flags->do_update_modules_flags = 1;
+		flags->do_update_ewmh_state_hints = 1;
+	}
+
+	/* has_icon
+	 * icon_override */
+	if (ret_style->change_mask.has_icon ||
+	    S_ICON_OVERRIDE(SCC(*ret_style)))
+	{
+		flags->do_update_icon_font = 1;
+		flags->do_update_icon = 1;
+	}
+
+	/* has_icon_background_padding
+	 * has_icon_background_relief
+	 * has_icon_title_relief */
+	if (ret_style->change_mask.has_icon_background_padding ||
+	    ret_style->change_mask.has_icon_background_relief ||
+	    ret_style->change_mask.has_icon_title_relief)
+	{
+		flags->do_update_icon = 1;
+	}
+
+	/* has_no_icon_title
+	 * is_icon_suppressed */
+	if (S_HAS_NO_ICON_TITLE(SCC(*ret_style)) ||
+	    S_IS_ICON_SUPPRESSED(SCC(*ret_style)))
+	{
+		flags->do_update_icon_font = 1;
+		flags->do_update_icon_title = 1;
+		flags->do_update_icon = 1;
+		flags->do_update_modules_flags = 1;
+	}
+
+	/* has_icon_size_limits */
+	if (ret_style->change_mask.has_icon_size_limits)
+	{
+		flags->do_update_icon_size_limits = 1;
+		flags->do_update_icon = 1;
+	}
+
+	/*   has_icon_boxes */
+	if (ret_style->change_mask.has_icon_boxes)
+	{
+		flags->do_update_icon_boxes = 1;
+		flags->do_update_icon = 1;
+	}
+
+	/* do_ewmh_donate_icon */
+	if (S_DO_EWMH_DONATE_ICON(SCC(*ret_style)))
+	{
+		flags->do_update_ewmh_icon = 1;
+	}
+
+	/* has_mini_icon
+	 * do_ewmh_mini_icon_override */
+	if (FMiniIconsSupported && (ret_style->change_mask.has_mini_icon ||
+	    S_DO_EWMH_MINI_ICON_OVERRIDE(SCC(*ret_style))))
+	{
+		flags->do_update_mini_icon = 1;
+		flags->do_update_ewmh_mini_icon = 1;
+		flags->do_redecorate = 1;
+	}
+
+	/* do_ewmh_donate_mini_icon */
+	if (FMiniIconsSupported && S_DO_EWMH_DONATE_MINI_ICON(SCC(*ret_style)))
+	{
+		flags->do_update_ewmh_mini_icon = 1;
+	}
+
+	/* has_max_window_size */
+	if (ret_style->change_mask.has_max_window_size)
+	{
+		flags->do_resize_window = 1;
+		flags->do_update_ewmh_allowed_actions = 1;
+		flags->do_update_modules_flags = 1;
+	}
+
+	/* has_color_back
+	 * has_color_fore
+	 * use_colorset
+	 * use_border_colorset */
+	if (ret_style->change_mask.has_color_fore ||
+	    ret_style->change_mask.has_color_back ||
+	    ret_style->change_mask.use_colorset ||
+	    ret_style->change_mask.use_border_colorset)
+	{
+		flags->do_update_window_color = 1;
+	}
+	/* has_color_back_hi
+	 * has_color_fore_hi
+	 * use_colorset_hi
+	 * use_border_colorset_hi */
+	if (ret_style->change_mask.has_color_fore_hi ||
+	    ret_style->change_mask.has_color_back_hi ||
+	    ret_style->change_mask.use_colorset_hi ||
+	    ret_style->change_mask.use_border_colorset_hi)
+	{
+		flags->do_update_window_color_hi = 1;
+	}
+
+	/* use_icon_title_colorset */
+	if (ret_style->change_mask.use_icon_title_colorset)
+	{
+		flags->do_update_icon_title_cs = 1;
+	}
+
+	/* use_icon_title_colorset_hi */
+	if (ret_style->change_mask.use_icon_title_colorset_hi)
+	{
+		flags->do_update_icon_title_cs_hi = 1;
+	}
+
+	/* use_icon_title_colorset */
+	if (ret_style->change_mask.use_icon_title_colorset)
+	{
+		flags->do_update_icon_title_cs = 1;
+	}
+
+	/* use_icon_background_colorset */
+	if (ret_style->change_mask.use_icon_background_colorset)
+	{
+		flags->do_update_icon_background_cs = 1;
+	}
+
+	/* has_decor */
+	if (ret_style->change_mask.has_decor)
+	{
+		flags->do_redecorate = 1;
+		flags->do_update_window_font_height = 1;
+	}
+
+	/* has_no_title */
+	if (ret_style->change_mask.has_no_title)
+	{
+		flags->do_redecorate = 1;
+		flags->do_update_window_font = 1;
+	}
+
+	/* do_decorate_transient */
+	if (ret_style->change_mask.do_decorate_transient)
+	{
+		flags->do_redecorate_transient = 1;
+	}
+
+	/* has_ol_decor */
+	if (ret_style->change_mask.has_ol_decor)
+	{
+		/* old decor overrides 'has_no_icon_title'! */
+		flags->do_update_icon_font = 1;
+		flags->do_update_icon_title = 1;
+		flags->do_update_icon = 1;
+		flags->do_redecorate = 1;
+	}
+
+	/* has_no_border
+	 * has_border_width
+	 * has_handle_width
+	 * has_mwm_decor
+	 * has_mwm_functions
+	 * has_no_handles
+	 * is_button_disabled */
+	if (S_HAS_NO_BORDER(SCC(*ret_style)) ||
+	    ret_style->change_mask.has_border_width ||
+	    ret_style->change_mask.has_handle_width ||
+	    ret_style->change_mask.has_mwm_decor ||
+	    ret_style->change_mask.has_mwm_functions ||
+	    ret_style->change_mask.has_no_handles ||
+	    ret_style->change_mask.is_button_disabled)
+	{
+		flags->do_redecorate = 1;
+		flags->do_update_ewmh_allowed_actions = 1;
+		flags->do_update_modules_flags = 1;
+	}
+
+	if (ret_style->change_mask.do_save_under ||
+	    ret_style->change_mask.use_backing_store ||
+	    ret_style->change_mask.use_parent_relative)
+	{
+		flags->do_update_frame_attributes = 1;
+	}
+
+	if (ret_style->change_mask.use_parent_relative &&
+	    ret_style->flags.use_parent_relative)
+	{
+		/* needed only for Opacity -> ParentalRelativity */
+		flags->do_refresh = 1;
+	}
+
+	/* has_placement_penalty
+	 * has_placement_percentage_penalty */
+	if (ret_style->change_mask.has_placement_penalty ||
+	    ret_style->change_mask.has_placement_percentage_penalty)
+	{
+		flags->do_update_placement_penalty = 1;
+	}
+
+	/* do_ewmh_ignore_strut_hints */
+	if (S_DO_EWMH_IGNORE_STRUT_HINTS(SCC(*ret_style)))
+	{
+		flags->do_update_working_area = 1;
+	}
+
+	/* do_ewmh_ignore_state_hints */
+	if (S_DO_EWMH_IGNORE_STATE_HINTS(SCC(*ret_style)))
+	{
+		flags->do_update_ewmh_state_hints = 1;
+		flags->do_update_modules_flags = 1;
+	}
+
+	/* do_ewmh_use_staking_hints */
+	if (S_DO_EWMH_USE_STACKING_HINTS(SCC(*ret_style)))
+	{
+		flags->do_update_ewmh_stacking_hints = 1;
+	}
+
+	/*  use_indexed_window_name */
+	if (S_USE_INDEXED_WINDOW_NAME(SCC(*ret_style)))
+	{
+		flags->do_update_visible_window_name = 1;
+		flags->do_redecorate = 1;
+	}
+
+	/*  use_indexed_icon_name */
+	if (S_USE_INDEXED_ICON_NAME(SCC(*ret_style)))
+	{
+		flags->do_update_visible_icon_name = 1;
+		flags->do_update_icon_title = 1;
+	}
+
+	/*  is_fixed */
+	if (S_IS_FIXED(SCC(*ret_style)) ||
+	    S_IS_FIXED_PPOS(SCC(*ret_style)) ||
+	    S_IS_SIZE_FIXED(SCC(*ret_style)) ||
+	    S_IS_PSIZE_FIXED(SCC(*ret_style)) ||
+	    S_HAS_OVERRIDE_SIZE(SCC(*ret_style)))
+	{
+		flags->do_update_ewmh_allowed_actions = 1;
+		flags->do_update_modules_flags = 1;
+	}
+
+	/* cr_motion_method */
+	if (SCR_MOTION_METHOD(&ret_style->change_mask))
+	{
+		flags->do_update_cr_motion_method = 1;
+	}
+
+	return;
+}
+
+/* Mark all styles as unchanged. */
+void reset_style_changes(void)
+{
+	window_style *temp;
+
+	for (temp = all_styles; temp != NULL; temp = SGET_NEXT_STYLE(*temp))
+	{
+		temp->has_style_changed = 0;
+		memset(&SCCS(*temp), 0, sizeof(SCCS(*temp)));
+		memset(&(temp->change_mask), 0, sizeof(temp->change_mask));
+	}
+
+	return;
+}
+
+/* Mark styles as updated if their colorset changed. */
+void update_style_colorset(int colorset)
+{
+	window_style *temp;
+
+	for (temp = all_styles; temp != NULL; temp = SGET_NEXT_STYLE(*temp))
+	{
+		if (SUSE_COLORSET(&temp->flags) &&
+		    SGET_COLORSET(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_colorset = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+		if (SUSE_COLORSET_HI(&temp->flags) &&
+		    SGET_COLORSET_HI(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_colorset_hi = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+		if (SUSE_BORDER_COLORSET(&temp->flags) &&
+		    SGET_BORDER_COLORSET(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_border_colorset = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+		if (SUSE_BORDER_COLORSET_HI(&temp->flags) &&
+		    SGET_BORDER_COLORSET_HI(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_border_colorset_hi = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+		if (SUSE_ICON_TITLE_COLORSET(&temp->flags) &&
+		    SGET_ICON_TITLE_COLORSET(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_icon_title_colorset = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+		if (SUSE_ICON_TITLE_COLORSET_HI(&temp->flags) &&
+		    SGET_ICON_TITLE_COLORSET_HI(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_icon_title_colorset_hi = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+		if (SUSE_ICON_BACKGROUND_COLORSET(&temp->flags) &&
+		    SGET_ICON_BACKGROUND_COLORSET(*temp) == colorset)
+		{
+			temp->has_style_changed = 1;
+			temp->change_mask.use_icon_background_colorset = 1;
+			Scr.flags.do_need_window_update = 1;
+		}
+	}
+
+	return;
+}
+
+/* Update fore and back colours for a specific window */
+void update_window_color_style(FvwmWindow *fw, window_style *pstyle)
+{
+	int cs = Scr.DefaultColorset;
+
+	if (SUSE_COLORSET(&pstyle->flags))
+	{
+		cs = SGET_COLORSET(*pstyle);
+		fw->cs = cs;
+	}
+	else
+	{
+		fw->cs = -1;
+	}
+	if (SGET_FORE_COLOR_NAME(*pstyle) != NULL &&
+	   !SUSE_COLORSET(&pstyle->flags))
+	{
+		fw->colors.fore = GetColor(SGET_FORE_COLOR_NAME(*pstyle));
+	}
+	else
+	{
+		fw->colors.fore = Colorset[cs].fg;
+	}
+	if (SGET_BACK_COLOR_NAME(*pstyle) != NULL &&
+	   !SUSE_COLORSET(&pstyle->flags))
+	{
+		fw->colors.back = GetColor(SGET_BACK_COLOR_NAME(*pstyle));
+		fw->colors.shadow = GetShadow(fw->colors.back);
+		fw->colors.hilight = GetHilite(fw->colors.back);
+	}
+	else
+	{
+		fw->colors.hilight = Colorset[cs].hilite;
+		fw->colors.shadow = Colorset[cs].shadow;
+		fw->colors.back = Colorset[cs].bg;
+	}
+	if (SUSE_BORDER_COLORSET(&pstyle->flags))
+	{
+		cs = SGET_BORDER_COLORSET(*pstyle);
+		fw->border_cs = cs;
+		fw->border_colors.hilight = Colorset[cs].hilite;
+		fw->border_colors.shadow = Colorset[cs].shadow;
+		fw->border_colors.back = Colorset[cs].bg;
+	}
+	else
+	{
+		fw->border_cs = -1;
+		fw->border_colors.hilight = fw->colors.hilight;
+		fw->border_colors.shadow = fw->colors.shadow;
+		fw->border_colors.back = fw->colors.back;
+	}
+}
+
+void update_window_color_hi_style(FvwmWindow *fw, window_style *pstyle)
+{
+	int cs = Scr.DefaultColorset;
+
+	if (SUSE_COLORSET_HI(&pstyle->flags))
+	{
+		cs = SGET_COLORSET_HI(*pstyle);
+		fw->cs_hi = cs;
+	}
+	else
+	{
+		fw->cs_hi = -1;
+	}
+	if (SGET_FORE_COLOR_NAME_HI(*pstyle) != NULL &&
+	   !SUSE_COLORSET_HI(&pstyle->flags))
+	{
+		fw->hicolors.fore = GetColor(SGET_FORE_COLOR_NAME_HI(*pstyle));
+	}
+	else
+	{
+		fw->hicolors.fore = Colorset[cs].fg;
+	}
+	if (SGET_BACK_COLOR_NAME_HI(*pstyle) != NULL &&
+	   !SUSE_COLORSET_HI(&pstyle->flags))
+	{
+		fw->hicolors.back = GetColor(SGET_BACK_COLOR_NAME_HI(*pstyle));
+		fw->hicolors.shadow = GetShadow(fw->hicolors.back);
+		fw->hicolors.hilight = GetHilite(fw->hicolors.back);
+	}
+	else
+	{
+		fw->hicolors.hilight = Colorset[cs].hilite;
+		fw->hicolors.shadow = Colorset[cs].shadow;
+		fw->hicolors.back = Colorset[cs].bg;
+	}
+	if (SUSE_BORDER_COLORSET_HI(&pstyle->flags))
+	{
+		cs = SGET_BORDER_COLORSET_HI(*pstyle);
+		fw->border_cs_hi = cs;
+		fw->border_hicolors.hilight = Colorset[cs].hilite;
+		fw->border_hicolors.shadow = Colorset[cs].shadow;
+		fw->border_hicolors.back = Colorset[cs].bg;
+	}
+	else
+	{
+		fw->border_cs_hi = -1;
+		fw->border_hicolors.hilight = fw->hicolors.hilight;
+		fw->border_hicolors.shadow = fw->hicolors.shadow;
+		fw->border_hicolors.back = fw->hicolors.back;
+	}
+}
+
+void update_icon_title_cs_style(FvwmWindow *fw, window_style *pstyle)
+{
+	if (SUSE_ICON_TITLE_COLORSET(&pstyle->flags))
+	{
+		fw->icon_title_cs = SGET_ICON_TITLE_COLORSET(*pstyle);
+	}
+	else
+	{
+		fw->icon_title_cs = -1;
+	}
+}
+
+void update_icon_title_cs_hi_style(FvwmWindow *fw, window_style *pstyle)
+{
+	if (SUSE_ICON_TITLE_COLORSET_HI(&pstyle->flags))
+	{
+		fw->icon_title_cs_hi = SGET_ICON_TITLE_COLORSET_HI(*pstyle);
+	}
+	else
+	{
+		fw->icon_title_cs_hi = -1;
+	}
+}
+
+void update_icon_background_cs_style(FvwmWindow *fw, window_style *pstyle)
+{
+	if (SUSE_ICON_BACKGROUND_COLORSET(&pstyle->flags))
+	{
+		fw->icon_background_cs =
+			SGET_ICON_BACKGROUND_COLORSET(*pstyle);
+	}
+	else
+	{
+		fw->icon_background_cs = -1;
+	}
+}
+
+void style_destroy_style(style_id_t s_id)
+{
+	FvwmWindow *t;
+
+	if (remove_all_of_style_from_list(s_id))
+	{
+		/* compact the current list of styles */
+		Scr.flags.do_need_style_list_update = 1;
+	}
+	else
+	{
+		return;
+	}
+	/* mark windows for update */
+	for (t = Scr.FvwmRoot.next; t != NULL; t = t->next)
+	{
+		if (fw_match_style_id(t, s_id))
+		{
+			SET_STYLE_DELETED(t, 1);
+			Scr.flags.do_need_window_update = 1;
+		}
+	}
+
+	return;
+}
+
+void print_styles(int verbose)
+{
+	window_style *nptr;
+	int count = 0;
+	int mem = 0;
+
+	fprintf(stderr,"Info on fvwm Styles:\n");
+	if (verbose)
+	{
+		fprintf(stderr,"  List of Styles Names:\n");
+	}
+	for (nptr = all_styles; nptr != NULL; nptr = SGET_NEXT_STYLE(*nptr))
+	{
+		count++;
+		if (SGET_ID_HAS_NAME(*nptr))
+		{
+			mem += strlen(SGET_NAME(*nptr));
+			if (verbose)
+			{
+				fprintf(stderr,"    * %s\n", SGET_NAME(*nptr));
+			}
+		}
+		else
+		{
+			mem++;
+			if (verbose)
+			{
+				fprintf(stderr,"    * 0x%lx\n",
+					(unsigned long)SGET_WINDOW_ID(*nptr));
+			}
+		}
+		if (SGET_BACK_COLOR_NAME(*nptr))
+		{
+			mem += strlen(SGET_BACK_COLOR_NAME(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Back Color: %s\n",
+					SGET_BACK_COLOR_NAME(*nptr));
+			}
+		}
+		if (SGET_FORE_COLOR_NAME(*nptr))
+		{
+			mem += strlen(SGET_FORE_COLOR_NAME(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Fore Color: %s\n",
+					SGET_FORE_COLOR_NAME(*nptr));
+			}
+		}
+		if (SGET_BACK_COLOR_NAME_HI(*nptr))
+		{
+			mem += strlen(SGET_BACK_COLOR_NAME_HI(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Back Color hi: %s\n",
+					SGET_BACK_COLOR_NAME_HI(*nptr));
+			}
+		}
+		if (SGET_FORE_COLOR_NAME_HI(*nptr))
+		{
+			mem += strlen(SGET_FORE_COLOR_NAME_HI(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Fore Color hi: %s\n",
+					SGET_FORE_COLOR_NAME_HI(*nptr));
+			}
+		}
+		if (SGET_DECOR_NAME(*nptr))
+		{
+			mem += strlen(SGET_DECOR_NAME(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Decor: %s\n",
+					SGET_DECOR_NAME(*nptr));
+			}
+		}
+		if (SGET_WINDOW_FONT(*nptr))
+		{
+			mem += strlen(SGET_WINDOW_FONT(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Window Font: %s\n",
+					SGET_WINDOW_FONT(*nptr));
+			}
+		}
+		if (SGET_ICON_FONT(*nptr))
+		{
+			mem += strlen(SGET_ICON_FONT(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Icon Font: %s\n",
+					SGET_ICON_FONT(*nptr));
+			}
+		}
+		if (SGET_ICON_NAME(*nptr))
+		{
+			mem += strlen(SGET_ICON_NAME(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        Icon Name: %s\n",
+					SGET_ICON_NAME(*nptr));
+			}
+		}
+		if (SGET_MINI_ICON_NAME(*nptr))
+		{
+			mem += strlen(SGET_MINI_ICON_NAME(*nptr));
+			if (verbose > 1)
+			{
+				fprintf(
+					stderr,"        MiniIcon Name: %s\n",
+					SGET_MINI_ICON_NAME(*nptr));
+			}
+		}
+		if (SGET_ICON_BOXES(*nptr))
+		{
+			mem += sizeof(icon_boxes);
+		}
+	}
+	fprintf(stderr,"  Number of styles: %d, Memory Used: %d bits\n",
+		count, (int)(count*sizeof(window_style) + mem));
+
+	return;
+}
+
+/* ---------------------------- builtin commands --------------------------- */
+
+void CMD_Style(F_CMD_ARGS)
+{
+	__style_command(F_PASS_ARGS, NULL, False);
+
+	return;
+}
+
+void CMD_WindowStyle(F_CMD_ARGS)
+{
+	__style_command(F_PASS_ARGS, NULL, True);
+
+	return;
+}
+
+void CMD_FocusStyle(F_CMD_ARGS)
+{
+	__style_command(F_PASS_ARGS, "FP", False);
+
+	return;
+}
+
+void CMD_DestroyStyle(F_CMD_ARGS)
+{
+	char *name;
+	style_id_t s_id;
+
+	/* parse style name */
+	name = PeekToken(action, &action);
+
+	/* in case there was no argument! */
+	if (name == NULL)
+		return;
+
+	memset(&s_id, 0, sizeof(style_id_t));
+	SID_SET_NAME(s_id, name);
+	SID_SET_HAS_NAME(s_id, True);
+
+	/* Do it */
+	style_destroy_style(s_id);
+	return;
+}
+
+void CMD_DestroyWindowStyle(F_CMD_ARGS)
+{
+	style_id_t s_id;
+
+	memset(&s_id, 0, sizeof(style_id_t));
+	SID_SET_WINDOW_ID(s_id, (XID)FW_W(exc->w.fw));
+	SID_SET_HAS_WINDOW_ID(s_id, True);
+
+	/* Do it */
+	style_destroy_style(s_id);
+	return;
+}
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/style.h fvwm-2.5.21-05/fvwm/style.h
--- fvwm-2.5.21-04/fvwm/style.h	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/style.h	2007-03-03 13:18:49.000000000 +0100
@@ -328,20 +328,24 @@
 #define S_SET_USE_INDEXED_ICON_NAME(c,x) \
 	((c).s.use_indexed_icon_name = !!(x))
 #define S_WINDOWSHADE_LAZINESS(c) \
 	((c).s.windowshade_laziness)
 #define S_SET_WINDOWSHADE_LAZINESS(c,x) \
 	((c).s.windowshade_laziness = (x))
 #define S_USE_TITLE_DECOR_ROTATION(c) \
 	((c).s.use_title_decor_rotation)
 #define S_SET_USE_TITLE_DECOR_ROTATION(c,x) \
 	((c).s.use_title_decor_rotation = !!(x))
+#define S_HAS_BORDER_UNDER_TITLE(c) \
+	((c).s.has_border_under_title)
+#define S_SET_HAS_BORDER_UNDER_TITLE(c,x) \
+	((c).s.has_border_under_title = !!(x))
 #define S_DO_EWMH_MINI_ICON_OVERRIDE(c) \
 	((c).s.do_ewmh_mini_icon_override)
 #define S_SET_DO_EWMH_MINI_ICON_OVERRIDE(c,x) \
 	((c).s.do_ewmh_mini_icon_override = !!(x))
 #define S_DO_EWMH_DONATE_ICON(c) \
 	((c).s.do_ewmh_donate_icon)
 #define S_SET_DO_EWMH_DONATE_ICON(c,x) \
 	((c).s.do_ewmh_donate_icon = !!(x))
 #define S_DO_EWMH_DONATE_MINI_ICON(c) \
 	((c).s.do_ewmh_donate_mini_icon)
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/style.h~ fvwm-2.5.21-05/fvwm/style.h~
--- fvwm-2.5.21-04/fvwm/style.h~	1970-01-01 01:00:00.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/style.h~	2007-03-03 13:18:42.000000000 +0100
@@ -0,0 +1,617 @@
+/* -*-c-*- */
+
+#ifndef _STYLE_
+#define _STYLE_
+
+/* access to the special flags of a style */
+/* call these with a pointer to a style_flags struct */
+#define SDO_DECORATE_TRANSIENT(sf) \
+	((sf)->do_decorate_transient)
+#define SDO_SAVE_UNDER(sf) \
+	((sf)->do_save_under)
+#define SDO_START_LOWERED(sf) \
+	((sf)->do_start_lowered)
+#define SHAS_BORDER_WIDTH(sf) \
+	((sf)->has_border_width)
+#define SHAS_COLOR_BACK(sf) \
+	((sf)->has_color_back)
+#define SHAS_COLOR_FORE(sf) \
+	((sf)->has_color_fore)
+#define SHAS_HANDLE_WIDTH(sf) \
+	((sf)->has_handle_width)
+#define SHAS_ICON(sf) \
+	((sf)->has_icon)
+#define SHAS_ICON_BOXES(sf) \
+	((sf)->has_icon_boxes)
+#define SHAS_ICON_SIZE_LIMITS(sf) \
+	((sf)->has_icon_size_limits)
+#define SHAS_ICON_BACKGROUND_PADDING(sf) \
+	((sf)->has_icon_background_padding)
+#define SHAS_ICON_BACKGROUND_RELIEF(sf) \
+	((sf)->has_icon_background_relief)
+#define SHAS_ICON_TITLE_RELIEF(sf) \
+	((sf)->has_icon_title_relief)
+#define SHAS_MAX_WINDOW_SIZE(sf) \
+	((sf)->has_max_window_size)
+#define SHAS_WINDOW_SHADE_STEPS(sf) \
+	((sf)->has_window_shade_steps)
+#define SHAS_MINI_ICON(sf) \
+	((sf)->has_mini_icon)
+#define SHAS_MWM_DECOR(sf) \
+	((sf)->has_mwm_decor)
+#define SHAS_MWM_FUNCTIONS(sf) \
+	((sf)->has_mwm_functions)
+#define SHAS_NO_HANDLES(sf) \
+	((sf)->has_no_handles)
+#define SHAS_NO_TITLE(sf) \
+	((sf)->has_no_title)
+#define SHAS_OL_DECOR(sf) \
+	((sf)->has_ol_decor)
+#define SIS_BUTTON_DISABLED(sf) \
+	((sf)->is_button_disabled)
+#define SIS_UNMANAGED(sf) \
+	((sf)->is_unmanaged)
+#define SPLACEMENT_MODE(sf) \
+	((sf)->placement_mode)
+#define SEWMH_PLACEMENT_MODE(sf) \
+	((sf)->ewmh_placement_mode)
+#define SUSE_BACKING_STORE(sf) \
+	((sf)->use_backing_store)
+#define SUSE_PARENT_RELATIVE(sf) \
+	((sf)->use_parent_relative)
+#define SUSE_COLORSET(sf) \
+	((sf)->use_colorset)
+#define SUSE_COLORSET_HI(sf) \
+	((sf)->use_colorset_hi)
+#define SUSE_BORDER_COLORSET(sf) \
+	((sf)->use_border_colorset)
+#define SUSE_BORDER_COLORSET_HI(sf) \
+	((sf)->use_border_colorset_hi)
+#define SUSE_ICON_TITLE_COLORSET(sf) \
+	((sf)->use_icon_title_colorset)
+#define SUSE_ICON_TITLE_COLORSET_HI(sf) \
+	((sf)->use_icon_title_colorset_hi)
+#define SUSE_ICON_BACKGROUND_COLORSET(sf) \
+	((sf)->use_icon_background_colorset)
+#define SUSE_LAYER(sf) \
+	((sf)->use_layer)
+#define SUSE_NO_PPOSITION(sf) \
+	((sf)->use_no_pposition)
+#define SUSE_NO_USPOSITION(sf) \
+	((sf)->use_no_usposition)
+#define SUSE_NO_TRANSIENT_PPOSITION(sf) \
+	((sf)->use_no_transient_pposition)
+#define SUSE_NO_TRANSIENT_USPOSITION(sf) \
+	((sf)->use_no_transient_usposition)
+#define SUSE_START_ON_DESK(sf) \
+	((sf)->use_start_on_desk)
+#define SUSE_START_ON_PAGE_FOR_TRANSIENT(sf) \
+	((sf)->use_start_on_page_for_transient)
+#define SUSE_START_ON_SCREEN(sf) \
+	((sf)->use_start_on_screen)
+#define SMANUAL_PLACEMENT_HONORS_STARTS_ON_PAGE(sf) \
+	((sf)->manual_placement_honors_starts_on_page)
+#define SCAPTURE_HONORS_STARTS_ON_PAGE(sf) \
+	((sf)->capture_honors_starts_on_page)
+#define SRECAPTURE_HONORS_STARTS_ON_PAGE(sf) \
+	((sf)->recapture_honors_starts_on_page)
+#define SHAS_PLACEMENT_PENALTY(sf) \
+	((sf)->has_placement_penalty)
+#define SHAS_PLACEMENT_PERCENTAGE_PENALTY(sf) \
+	((sf)->has_placement_percentage_penalty)
+#define SCR_MOTION_METHOD(sf) \
+	((sf)->ws_cr_motion_method)
+
+/* access the various copies of the common flags structure. */
+#define SCF(st) \
+	((st).flags.common)
+#define SCFS(st) \
+	((st).flags.common.s)
+#define SCM(st) \
+	((st).flag_mask.common)
+#define SCMS(st) \
+	((st).flag_mask.common.s)
+#define SCD(st) \
+	((st).flag_default.common)
+#define SCDS(st) \
+	((st).flag_default.common.s)
+#define SCC(st) \
+	((st).change_mask.common)
+#define SCCS(st) \
+	((st).change_mask.common.s)
+#define SFC(sf) \
+	((sf).common)
+
+/* access to common flags */
+#define S_FOCUS_POLICY(c) \
+	((c).s.focus_policy)
+#define S_TITLE_DIR(c) \
+	((c).title_dir)
+#define S_SET_TITLE_DIR(c,x) \
+	((c).title_dir = (x))
+#define S_USER_STATES(c) \
+	((c).user_states)
+#define S_SET_USER_STATES(c,x) \
+	((c).user_states = (x))
+#define S_ADD_USER_STATES(c,x) \
+	((c).user_states = ((c).user_states | (x)))
+#define S_IS_STICKY_ACROSS_PAGES(c) \
+	((c).is_sticky_across_pages)
+#define S_SET_IS_STICKY_ACROSS_PAGES(c,x) \
+	((c).is_sticky_across_pages = !!(x))
+#define S_IS_STICKY_ACROSS_DESKS(c) \
+	((c).is_sticky_across_desks)
+#define S_SET_IS_STICKY_ACROSS_DESKS(c,x) \
+	((c).is_sticky_across_desks = !!(x))
+#define S_DO_CIRCULATE_SKIP(c) \
+	((c).s.do_circulate_skip)
+#define S_SET_DO_CIRCULATE_SKIP(c,x) \
+	((c).s.do_circulate_skip = !!(x))
+#define S_DO_CIRCULATE_SKIP_ICON(c) \
+	((c).s.do_circulate_skip_icon)
+#define S_SET_DO_CIRCULATE_SKIP_ICON(c,x) \
+	((c).s.do_circulate_skip_icon = !!(x))
+#define S_DO_CIRCULATE_SKIP_SHADED(c) \
+	((c).s.do_circulate_skip_shaded)
+#define S_SET_DO_CIRCULATE_SKIP_SHADED(c,x) \
+	((c).s.do_circulate_skip_shaded = !!(x))
+#define S_DO_ICONIFY_WINDOW_GROUPS(c) \
+	((c).s.do_iconify_window_groups)
+#define S_SET_DO_ICONIFY_WINDOW_GROUPS(c,x) \
+	((c).s.do_iconify_window_groups = !!(x))
+#define S_DO_IGNORE_GNOME_HINTS(c) \
+	((c).s.do_ignore_gnome_hints)
+#define S_SET_DO_IGNORE_GNOME_HINTS(c,x) \
+	((c).s.do_ignore_gnome_hints = !!(x))
+#define S_DO_IGNORE_ICON_BOXES(c) \
+	((c).s.do_ignore_icon_boxes)
+#define S_SET_DO_IGNORE_ICON_BOXES(c,x) \
+	((c).s.do_ignore_icon_boxes = !!(x))
+#define S_DO_IGNORE_RESTACK(c) \
+	((c).s.do_ignore_restack)
+#define S_SET_DO_IGNORE_RESTACK(c,x) \
+	((c).s.do_ignore_restack = !!(x))
+#define S_DO_USE_WINDOW_GROUP_HINT(c) \
+	((c).s.do_use_window_group_hint)
+#define S_SET_DO_USE_WINDOW_GROUP_HINT(c,x) \
+	((c).s.do_use_window_group_hint = !!(x))
+#define S_DO_LOWER_TRANSIENT(c) \
+	((c).s.do_lower_transient)
+#define S_SET_DO_LOWER_TRANSIENT(c,x) \
+	((c).s.do_lower_transient = !!(x))
+#define S_DO_NOT_SHOW_ON_MAP(c) \
+	((c).s.do_not_show_on_map)
+#define S_SET_DO_NOT_SHOW_ON_MAP(c,x) \
+	((c).s.do_not_show_on_map = !!(x))
+#define S_DO_RAISE_TRANSIENT(c) \
+	((c).s.do_raise_transient)
+#define S_SET_DO_RAISE_TRANSIENT(c,x) \
+	((c).s.do_raise_transient = !!(x))
+#define S_DO_RESIZE_OPAQUE(c) \
+	((c).s.do_resize_opaque)
+#define S_SET_DO_RESIZE_OPAQUE(c,x) \
+	((c).s.do_resize_opaque = !!(x))
+#define S_DO_RESIZE_OUTLINE_THIN(c) \
+	((c).s.do_resize_outline_thin)
+#define S_SET_DO_RESIZE_OUTLINE_THIN(c,x) \
+	((c).s.do_resize_outline_thin = !!(x))
+#define S_DO_SHRINK_WINDOWSHADE(c) \
+	((c).s.do_shrink_windowshade)
+#define S_SET_DO_SHRINK_WINDOWSHADE(c,x) \
+	((c).s.do_shrink_windowshade = !!(x))
+#define S_DO_STACK_TRANSIENT_PARENT(c) \
+	((c).s.do_stack_transient_parent)
+#define S_SET_DO_STACK_TRANSIENT_PARENT(c,x) \
+	((c).s.do_stack_transient_parent = !!(x))
+#define S_DO_WINDOW_LIST_SKIP(c) \
+	((c).s.do_window_list_skip)
+#define S_SET_DO_WINDOW_LIST_SKIP(c,x) \
+	((c).s.do_window_list_skip = !!(x))
+#define S_HAS_NO_BORDER(c) \
+	((c).has_no_border)
+#define S_SET_HAS_NO_BORDER(c,x) \
+	((c).has_no_border = !!(x))
+#define S_HAS_DEPRESSABLE_BORDER(c) \
+	((c).s.has_depressable_border)
+#define S_SET_HAS_DEPRESSABLE_BORDER(c,x) \
+	((c).s.has_depressable_border = !!(x))
+#define S_HAS_ICON_FONT(c) \
+	((c).has_icon_font)
+#define S_SET_HAS_ICON_FONT(c,x) \
+	((c).has_icon_font = !!(x))
+#define S_HAS_MWM_BORDER(c) \
+	((c).s.has_mwm_border)
+#define S_SET_HAS_MWM_BORDER(c,x) \
+	((c).s.has_mwm_border = !!(x))
+#define S_HAS_MWM_BUTTONS(c) \
+	((c).s.has_mwm_buttons)
+#define S_SET_HAS_MWM_BUTTONS(c,x) \
+	((c).s.has_mwm_buttons = !!(x))
+#define S_HAS_MWM_OVERRIDE(c) \
+	((c).s.has_mwm_override)
+#define S_SET_HAS_MWM_OVERRIDE(c,x) \
+	((c).s.has_mwm_override = !!(x))
+#define S_HAS_NO_STICKY_STIPPLED_ICON_TITLE(c) \
+	((c).s.has_no_sticky_stippled_icon_title)
+#define S_SET_HAS_NO_STICKY_STIPPLED_ICON_TITLE(c,x) \
+	((c).s.has_no_sticky_stippled_icon_title = !!(x))
+#define S_HAS_NO_ICON_TITLE(c) \
+	((c).s.has_no_icon_title)
+#define S_SET_HAS_NO_ICON_TITLE(c,x) \
+	((c).s.has_no_icon_title = !!(x))
+#define S_HAS_OVERRIDE_SIZE(c) \
+	((c).s.has_override_size)
+#define S_SET_HAS_OVERRIDE_SIZE(c,x) \
+	((c).s.has_override_size = !!(x))
+#define S_HAS_STIPPLED_TITLE(c) \
+	((c).s.has_stippled_title)
+#define S_SET_HAS_STIPPLED_TITLE(c,x) \
+	((c).s.has_stippled_title = !!(x))
+#define S_HAS_NO_STICKY_STIPPLED_TITLE(c) \
+	((c).s.has_no_sticky_stippled_title)
+#define S_SET_HAS_NO_STICKY_STIPPLED_TITLE(c,x) \
+	((c).s.has_no_sticky_stippled_title = !!(x))
+#define S_HAS_STIPPLED_ICON_TITLE(c) \
+	((c).s.has_stippled_icon_title)
+#define S_SET_HAS_STIPPLED_ICON_TITLE(c,x) \
+	((c).s.has_stippled_icon_title = !!(x))
+#define S_HAS_WINDOW_FONT(c) \
+	((c).has_window_font)
+#define S_SET_HAS_WINDOW_FONT(c,x) \
+	((c).has_window_font = !!(x))
+#define S_ICON_OVERRIDE(c) \
+	((c).s.icon_override)
+#define S_SET_ICON_OVERRIDE(c,x) \
+	((c).s.icon_override = (x))
+#define S_IS_BOTTOM_TITLE_ROTATED(c) \
+	((c).s.is_bottom_title_rotated)
+#define S_SET_IS_BOTTOM_TITLE_ROTATED(c,x) \
+	((c).s.is_bottom_title_rotated = !!(x))
+#define S_IS_FIXED(c) \
+	((c).s.is_fixed)
+#define S_SET_IS_FIXED(c,x) \
+	((c).s.is_fixed = !!(x))
+#define S_IS_FIXED_PPOS(c) \
+	((c).s.is_fixed_ppos)
+#define S_SET_IS_FIXED_PPOS(c,x) \
+	((c).s.is_fixed_ppos = !!(x))
+#define S_SET_IS_UNICONIFIABLE(c,x) \
+	((c).s.is_uniconifiable = !!(x))
+#define S_SET_IS_UNMAXIMIZABLE(c,x) \
+	((c).s.is_unmaximizable = !!(x))
+#define S_SET_IS_UNCLOSABLE(c,x) \
+	((c).s.is_unclosable = !!(x))
+#define S_SET_MAXIMIZE_FIXED_SIZE_DISALLOWED(c,x) \
+	((c).s.is_maximize_fixed_size_disallowed = !!(x))
+#define S_IS_ICON_STICKY_ACROSS_PAGES(c) \
+	((c).s.is_icon_sticky_across_pages)
+#define S_SET_IS_ICON_STICKY_ACROSS_PAGES(c,x) \
+	((c).s.is_icon_sticky_across_pages = !!(x))
+#define S_IS_ICON_STICKY_ACROSS_DESKS(c) \
+	((c).s.is_icon_sticky_across_desks)
+#define S_SET_IS_ICON_STICKY_ACROSS_DESKS(c,x) \
+	((c).s.is_icon_sticky_across_desks = !!(x))
+#define S_IS_ICON_SUPPRESSED(c) \
+	((c).s.is_icon_suppressed)
+#define S_SET_IS_ICON_SUPPRESSED(c,x) \
+	((c).s.is_icon_suppressed = !!(x))
+#define S_IS_LEFT_TITLE_ROTATED_CW(c) \
+	((c).s.is_left_title_rotated_cw)
+#define S_SET_IS_LEFT_TITLE_ROTATED_CW(c,x) \
+	((c).s.is_left_title_rotated_cw = !!(x))
+#define S_IS_SIZE_FIXED(c) \
+	((c).s.is_size_fixed)
+#define S_SET_IS_SIZE_FIXED(c,x) \
+	((c).s.is_size_fixed = !!(x))
+#define S_IS_PSIZE_FIXED(c) \
+	((c).s.is_psize_fixed)
+#define S_SET_IS_PSIZE_FIXED(c,x) \
+	((c).s.is_psize_fixed = !!(x))
+#define S_IS_RIGHT_TITLE_ROTATED_CW(c) \
+	((c).s.is_right_title_rotated_cw)
+#define S_SET_IS_RIGHT_TITLE_ROTATED_CW(c,x) \
+	((c).s.is_right_title_rotated_cw = !!(x))
+#define S_IS_TOP_TITLE_ROTATED(c) \
+	((c).s.is_top_title_rotated)
+#define S_SET_IS_TOP_TITLE_ROTATED(c,x) \
+	((c).s.is_top_title_rotated = !!(x))
+#define S_USE_ICON_POSITION_HINT(c) \
+	((c).s.use_icon_position_hint)
+#define S_SET_USE_ICON_POSITION_HINT(c,x) \
+	((c).s.use_icon_position_hint = !!(x))
+#define S_USE_INDEXED_WINDOW_NAME(c) \
+	((c).s.use_indexed_window_name)
+#define S_SET_USE_INDEXED_WINDOW_NAME(c,x) \
+	((c).s.use_indexed_window_name = !!(x))
+#define S_USE_INDEXED_ICON_NAME(c) \
+	((c).s.use_indexed_icon_name)
+#define S_SET_USE_INDEXED_ICON_NAME(c,x) \
+	((c).s.use_indexed_icon_name = !!(x))
+#define S_WINDOWSHADE_LAZINESS(c) \
+	((c).s.windowshade_laziness)
+#define S_SET_WINDOWSHADE_LAZINESS(c,x) \
+	((c).s.windowshade_laziness = (x))
+#define S_USE_TITLE_DECOR_ROTATION(c) \
+	((c).s.use_title_decor_rotation)
+#define S_SET_USE_TITLE_DECOR_ROTATION(c,x) \
+	((c).s.use_title_decor_rotation = !!(x))
+#define S_DO_EWMH_MINI_ICON_OVERRIDE(c) \
+	((c).s.do_ewmh_mini_icon_override)
+#define S_SET_DO_EWMH_MINI_ICON_OVERRIDE(c,x) \
+	((c).s.do_ewmh_mini_icon_override = !!(x))
+#define S_DO_EWMH_DONATE_ICON(c) \
+	((c).s.do_ewmh_donate_icon)
+#define S_SET_DO_EWMH_DONATE_ICON(c,x) \
+	((c).s.do_ewmh_donate_icon = !!(x))
+#define S_DO_EWMH_DONATE_MINI_ICON(c) \
+	((c).s.do_ewmh_donate_mini_icon)
+#define S_SET_DO_EWMH_DONATE_MINI_ICON(c,x) \
+	((c).s.do_ewmh_donate_mini_icon = !!(x))
+#define S_DO_EWMH_USE_STACKING_HINTS(c) \
+	((c).s.do_ewmh_use_stacking_hints)
+#define S_SET_DO_EWMH_USE_STACKING_HINTS(c,x) \
+	((c).s.do_ewmh_use_stacking_hints = !!(x))
+#define S_DO_EWMH_IGNORE_STRUT_HINTS(c) \
+	((c).s.do_ewmh_ignore_strut_hints)
+#define S_SET_DO_EWMH_IGNORE_STRUT_HINTS(c,x) \
+	((c).s.do_ewmh_ignore_strut_hints = !!(x))
+#define S_DO_EWMH_IGNORE_STATE_HINTS(c) \
+	((c).s.do_ewmh_ignore_state_hints)
+#define S_SET_DO_EWMH_IGNORE_STATE_HINTS(c,x) \
+	((c).s.do_ewmh_ignore_state_hints = !!(x))
+#define S_DO_EWMH_IGNORE_WINDOW_TYPE(c) \
+	((c).s.do_ewmh_ignore_window_type)
+#define S_SET_DO_EWMH_IGNORE_WINDOW_TYPE(c,x) \
+	((c).s.do_ewmh_ignore_window_type = !!(x))
+#define S_EWMH_MAXIMIZE_MODE(c) \
+	((c).s.ewmh_maximize_mode)
+#define S_SET_EWMH_MAXIMIZE_MODE(c,x) \
+	((c).s.ewmh_maximize_mode = (x))
+
+/* access to style_id */
+#define SID_GET_NAME(id) \
+	((id).name)
+#define SID_SET_NAME(id,x) \
+	((id).name = (x))
+#define SID_GET_WINDOW_ID(id) \
+	((id).window_id)
+#define SID_SET_WINDOW_ID(id,x) \
+	((id).window_id = (x))
+#define SID_SET_HAS_NAME(id,x) \
+	((id).flags.has_name = !!(x))
+#define SID_GET_HAS_NAME(id) \
+	((id).flags.has_name)
+#define SID_SET_HAS_WINDOW_ID(id,x) \
+	((id).flags.has_window_id = !!(x))
+#define SID_GET_HAS_WINDOW_ID(id) \
+	((id).flags.has_window_id)
+
+/* access to other parts of a style (call with the style itself) */
+#define SGET_NEXT_STYLE(s) \
+	((s).next)
+#define SSET_NEXT_STYLE(s,x) \
+	((s).next = (x))
+#define SGET_PREV_STYLE(s) \
+	((s).prev)
+#define SSET_PREV_STYLE(s,x) \
+	((s).prev = (x))
+#define SGET_ID(s) \
+	((s).id)
+#define SGET_NAME(s) \
+	SID_GET_NAME(SGET_ID(s))
+#define SSET_NAME(s,x) \
+	SID_SET_NAME(SGET_ID(s),x)
+#define SGET_WINDOW_ID(s) \
+	SID_GET_WINDOW_ID(SGET_ID(s))
+#define SSET_WINDOW_ID(s,x) \
+	SID_SET_WINDOW_ID(SGET_ID(s),x)
+#define SSET_ID_HAS_NAME(s,x) \
+        SID_SET_HAS_NAME(SGET_ID(s), x)
+#define SGET_ID_HAS_NAME(s) \
+	SID_GET_HAS_NAME(SGET_ID(s))
+#define SSET_ID_HAS_WINDOW_ID(s,x) \
+	SID_SET_HAS_WINDOW_ID(SGET_ID(s),x)
+#define SGET_ID_HAS_WINDOW_ID(s) \
+	SID_GET_HAS_WINDOW_ID(SGET_ID(s))
+#define SGET_ICON_NAME(s) \
+	((s).icon_name)
+#define SSET_ICON_NAME(s,x) \
+	((s).icon_name = (x))
+#define SGET_MINI_ICON_NAME(s) \
+	((s).mini_icon_name)
+#define SSET_MINI_ICON_NAME(s,x) \
+	((s).mini_icon_name = (x))
+#ifdef USEDECOR
+#define SGET_DECOR_NAME(s) \
+	((s).decor_name)
+#define SSET_DECOR_NAME(s,x) \
+	((s).decor_name = (x))
+#endif
+#define SGET_FORE_COLOR_NAME(s) \
+	((s).fore_color_name)
+#define SSET_FORE_COLOR_NAME(s,x) \
+	((s).fore_color_name = (x))
+#define SGET_BACK_COLOR_NAME(s) \
+	((s).back_color_name)
+#define SSET_BACK_COLOR_NAME(s,x) \
+	((s).back_color_name = (x))
+#define SGET_FORE_COLOR_NAME_HI(s) \
+	((s).fore_color_name_hi)
+#define SSET_FORE_COLOR_NAME_HI(s,x) \
+	((s).fore_color_name_hi = (x))
+#define SGET_BACK_COLOR_NAME_HI(s) \
+	((s).back_color_name_hi)
+#define SSET_BACK_COLOR_NAME_HI(s,x) \
+	((s).back_color_name_hi = (x))
+#define SGET_ICON_FONT(s) \
+	((s).icon_font)
+#define SSET_ICON_FONT(s,x) \
+	((s).icon_font = (x))
+#define SGET_WINDOW_FONT(s) \
+	((s).window_font)
+#define SSET_WINDOW_FONT(s,x) \
+	((s).window_font = (x))
+#define SGET_COLORSET(s) \
+	((s).colorset)
+#define SSET_COLORSET(s,x) \
+	((s).colorset = (x))
+#define SSET_BORDER_COLORSET(s,x) \
+	((s).border_colorset = (x))
+#define SGET_BORDER_COLORSET(s) \
+	((s).border_colorset)
+#define SGET_COLORSET_HI(s) \
+	((s).colorset_hi)
+#define SSET_COLORSET_HI(s,x) \
+	((s).colorset_hi = (x))
+#define SGET_BORDER_COLORSET_HI(s) \
+	((s).border_colorset_hi)
+#define SSET_BORDER_COLORSET_HI(s,x) \
+	((s).border_colorset_hi = (x))
+#define SSET_ICON_TITLE_COLORSET(s,x) \
+	((s).icon_title_colorset = (x))
+#define SGET_ICON_TITLE_COLORSET(s) \
+	((s).icon_title_colorset)
+#define SSET_ICON_TITLE_COLORSET_HI(s,x) \
+	((s).icon_title_colorset_hi = (x))
+#define SGET_ICON_TITLE_COLORSET_HI(s) \
+	((s).icon_title_colorset_hi)
+#define SSET_ICON_BACKGROUND_COLORSET(s,x) \
+	((s).icon_background_colorset = (x))
+#define SGET_ICON_BACKGROUND_COLORSET(s) \
+	((s).icon_background_colorset)
+#define SGET_FLAGS_POINTER(s) \
+	(&((s).flags))
+#define SGET_BORDER_WIDTH(s) \
+	((s).border_width)
+#define SSET_BORDER_WIDTH(s,x) \
+	((s).border_width = (x))
+#define SGET_HANDLE_WIDTH(s) \
+	((s).handle_width)
+#define SSET_HANDLE_WIDTH(s,x) \
+	((s).handle_width = (x))
+#define SGET_LAYER(s) \
+	((s).layer)
+#define SSET_LAYER(s,x) \
+	((s).layer = (x))
+#define SGET_START_DESK(s) \
+	((s).start_desk)
+#define SSET_START_DESK(s,x) \
+	((s).start_desk = (x))
+#define SGET_START_PAGE_X(s) \
+	((s).start_page_x)
+#define SSET_START_PAGE_X(s,x) \
+	((s).start_page_x = (x))
+#define SGET_START_PAGE_Y(s) \
+	((s).start_page_y)
+#define SSET_START_PAGE_Y(s,x) \
+	((s).start_page_y = (x))
+#define SGET_START_SCREEN(s) \
+	((s).start_screen)
+#define SSET_START_SCREEN(s,x) \
+	((s).start_screen = (x))
+#define SGET_MIN_ICON_WIDTH(s) \
+	((s).min_icon_width)
+#define SSET_MIN_ICON_WIDTH(s,x) \
+	((s).min_icon_width = (x))
+#define SGET_MIN_ICON_HEIGHT(s) \
+	((s).min_icon_height)
+#define SSET_MIN_ICON_HEIGHT(s,x) \
+	((s).min_icon_height = (x))
+#define SGET_MAX_ICON_WIDTH(s) \
+	((s).max_icon_width)
+#define SSET_MAX_ICON_WIDTH(s,x) \
+	((s).max_icon_width = (x))
+#define SGET_MAX_ICON_HEIGHT(s) \
+	((s).max_icon_height)
+#define SSET_MAX_ICON_HEIGHT(s,x) \
+	((s).max_icon_height = (x))
+#define SGET_ICON_RESIZE_TYPE(s) \
+	((s).icon_resize_type)
+#define SSET_ICON_RESIZE_TYPE(s,x) \
+	((s).icon_resize_type = (x))
+#define SGET_ICON_BACKGROUND_RELIEF(s) \
+	((s).icon_background_relief)
+#define SSET_ICON_BACKGROUND_RELIEF(s,x) \
+	((s).icon_background_relief = (x))
+#define SGET_ICON_BACKGROUND_PADDING(s) \
+	((s).icon_background_padding)
+#define SSET_ICON_BACKGROUND_PADDING(s,x) \
+	((s).icon_background_padding = (x))
+#define SGET_ICON_TITLE_RELIEF(s) \
+	((s).icon_title_relief)
+#define SSET_ICON_TITLE_RELIEF(s,x) \
+	((s).icon_title_relief = (x))
+#define SGET_MAX_WINDOW_WIDTH(s) \
+	((s).max_window_width)
+#define SSET_MAX_WINDOW_WIDTH(s,x) \
+	((s).max_window_width = (x))
+#define SGET_MAX_WINDOW_HEIGHT(s) \
+	((s).max_window_height)
+#define SSET_MAX_WINDOW_HEIGHT(s,x) \
+	((s).max_window_height = (x))
+#define SGET_WINDOW_SHADE_STEPS(s) \
+	((s).shade_anim_steps)
+#define SSET_WINDOW_SHADE_STEPS(s,x) \
+	((s).shade_anim_steps = (x))
+#define SGET_ICON_BOXES(s) \
+	((s).icon_boxes)
+#define SSET_ICON_BOXES(s,x) \
+	((s).icon_boxes = (x))
+#define SGET_NORMAL_PLACEMENT_PENALTY(s) \
+	((s).placement_penalty[0])
+#define SGET_ONTOP_PLACEMENT_PENALTY(s) \
+	((s).placement_penalty[1])
+#define SGET_ICON_PLACEMENT_PENALTY(s) \
+	((s).placement_penalty[2])
+#define SGET_STICKY_PLACEMENT_PENALTY(s) \
+	((s).placement_penalty[3])
+#define SGET_BELOW_PLACEMENT_PENALTY(s) \
+	((s).placement_penalty[4])
+#define SGET_EWMH_STRUT_PLACEMENT_PENALTY(s) \
+	((s).placement_penalty[5])
+#define SSET_NORMAL_PLACEMENT_PENALTY(s,x) \
+	((s).placement_penalty[0] = (x))
+#define SSET_ONTOP_PLACEMENT_PENALTY(s,x) \
+	((s).placement_penalty[1] = (x))
+#define SSET_ICON_PLACEMENT_PENALTY(s,x) \
+	((s).placement_penalty[2] = (x))
+#define SSET_STICKY_PLACEMENT_PENALTY(s,x) \
+	((s).placement_penalty[3] = (x))
+#define SSET_BELOW_PLACEMENT_PENALTY(s,x) \
+	((s).placement_penalty[4] = (x))
+#define SSET_EWMH_STRUT_PLACEMENT_PENALTY(s,x) \
+	((s).placement_penalty[5] = (x))
+#define SGET_99_PLACEMENT_PERCENTAGE_PENALTY(s) \
+	((s).placement_percentage_penalty[0])
+#define SGET_95_PLACEMENT_PERCENTAGE_PENALTY(s) \
+	((s).placement_percentage_penalty[1])
+#define SGET_85_PLACEMENT_PERCENTAGE_PENALTY(s) \
+	((s).placement_percentage_penalty[2])
+#define SGET_75_PLACEMENT_PERCENTAGE_PENALTY(s) \
+	((s).placement_percentage_penalty[3])
+#define SSET_99_PLACEMENT_PERCENTAGE_PENALTY(s,x) \
+	((s).placement_percentage_penalty[0] = (x))
+#define SSET_95_PLACEMENT_PERCENTAGE_PENALTY(s,x) \
+	((s).placement_percentage_penalty[1] = (x))
+#define SSET_85_PLACEMENT_PERCENTAGE_PENALTY(s,x) \
+	((s).placement_percentage_penalty[2] = (x))
+#define SSET_75_PLACEMENT_PERCENTAGE_PENALTY(s,x) \
+	((s).placement_percentage_penalty[3] = (x))
+
+/* function prototypes */
+void lookup_style(FvwmWindow *fw, window_style *styles);
+Bool blockcmpmask(char *blk1, char *blk2, char *mask, int length);
+void check_window_style_change(
+	FvwmWindow *t, update_win *flags, window_style *ret_style);
+void reset_style_changes(void);
+void update_style_colorset(int colorset);
+void update_window_color_style(FvwmWindow *fw, window_style *style);
+void update_window_color_hi_style(FvwmWindow *fw, window_style *style);
+void update_icon_title_cs_style(FvwmWindow *fw, window_style *pstyle);
+void update_icon_title_cs_hi_style(FvwmWindow *fw, window_style *pstyle);
+void update_icon_background_cs_style(FvwmWindow *fw, window_style *pstyle);
+void free_icon_boxes(icon_boxes *ib);
+void style_destroy_style(style_id_t s_id);
+void print_styles(int verbose);
+
+#endif /* _STYLE_ */
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/window_flags.h fvwm-2.5.21-05/fvwm/window_flags.h
--- fvwm-2.5.21-04/fvwm/window_flags.h	2007-03-03 13:18:21.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/window_flags.h	2007-03-03 13:18:49.000000000 +0100
@@ -321,20 +321,26 @@
 #define SET_IS_BOTTOM_TITLE_ROTATED(fw,x) \
 	(fw)->flags.common.s.is_bottom_title_rotated = !!(x)
 #define SETM_IS_BOTTOM_TITLE_ROTATED(fw,x) \
 	(fw)->flag_mask.common.s.is_bottom_title_rotated = !!(x)
 #define USE_TITLE_DECOR_ROTATION(fw) \
 	((fw)->flags.common.s.use_title_decor_rotation)
 #define SET_USE_TITLE_DECOR_ROTATION(fw,x) \
 	(fw)->flags.common.s.use_title_decor_rotation = !!(x)
 #define SETM_USE_TITLE_DECOR_ROTATION(fw,x) \
 	(fw)->flag_mask.common.s.use_title_decor_rotation = !!(x)
+#define HAS_BORDER_UNDER_TITLE(fw) \
+	((fw)->flags.common.s.has_border_under_title)
+#define SET_HAS_BORDER_UNDER_TITLE(fw,x) \
+	(fw)->flags.common.s.has_border_under_title = !!(x)
+#define SETM_HAS_BORDER_UNDER_TITLE(fw,x) \
+	(fw)->flag_mask.common.s.has_border_under_title = !!(x)
 
 /* access to the special flags of a window */
 #define DO_REUSE_DESTROYED(fw) \
 	((fw)->flags.do_reuse_destroyed)
 #define SET_DO_REUSE_DESTROYED(fw,x) \
 	(fw)->flags.do_reuse_destroyed = !!(x)
 #define SETM_DO_REUSE_DESTROYED(fw,x) \
 	(fw)->flag_mask.do_reuse_destroyed = !!(x)
 #define HAS_NO_BORDER(fw) \
 	((fw)->flags.common.has_no_border)
diff -U10 -Naupr fvwm-2.5.21-04/fvwm/window_flags.h~ fvwm-2.5.21-05/fvwm/window_flags.h~
--- fvwm-2.5.21-04/fvwm/window_flags.h~	1970-01-01 01:00:00.000000000 +0100
+++ fvwm-2.5.21-05/fvwm/window_flags.h~	2007-03-03 13:18:42.000000000 +0100
@@ -0,0 +1,752 @@
+/* -*-c-*- */
+
+#ifndef _WINDOW_FLAGS_
+#define _WINDOW_FLAGS_
+
+#include "focus_policy.h"
+
+/* access to the common flags of a window */
+#define FW_COMMON_FLAGS(fw) \
+	((fw)->flags.common)
+#define FW_COMMON_STATIC_FLAGS(fw) \
+	((fw)->flags.common.s)
+#define FW_FOCUS_POLICY(fw) \
+	((fw)->flags.common.s.focus_policy)
+
+#define DO_LOWER_TRANSIENT(fw) \
+	((fw)->flags.common.s.do_lower_transient)
+#define DO_NOT_SHOW_ON_MAP(fw) \
+	((fw)->flags.common.s.do_not_show_on_map)
+#define DO_RAISE_TRANSIENT(fw) \
+	((fw)->flags.common.s.do_raise_transient)
+#define DO_RESIZE_OPAQUE(fw) \
+	((fw)->flags.common.s.do_resize_opaque)
+#define DO_RESIZE_OUTLINE_THIN(fw) \
+	((fw)->flags.common.s.do_resize_outline_thin)
+#define DO_SHRINK_WINDOWSHADE(fw) \
+	((fw)->flags.common.s.do_shrink_windowshade)
+#define SET_DO_SHRINK_WINDOWSHADE(fw,x) \
+	(fw)->flags.common.s.do_shrink_windowshade = !!(x)
+#define SETM_DO_SHRINK_WINDOWSHADE(fw,x) \
+	(fw)->flag_mask.common.s.do_shrink_windowshade = !!(x)
+#define DO_SKIP_CIRCULATE(fw) \
+	((fw)->flags.common.s.do_circulate_skip)
+#define SET_DO_SKIP_CIRCULATE(fw,x) \
+	(fw)->flags.common.s.do_circulate_skip = !!(x)
+#define SETM_DO_SKIP_CIRCULATE(fw,x) \
+	(fw)->flag_mask.common.s.do_circulate_skip = !!(x)
+#define DO_SKIP_ICON_CIRCULATE(fw) \
+	((fw)->flags.common.s.do_circulate_skip_icon)
+#define SET_DO_SKIP_ICON_CIRCULATE(fw,x) \
+	(fw)->flags.common.s.do_circulate_skip_icon = !!(x)
+#define SETM_DO_SKIP_ICON_CIRCULATE(fw,x) \
+	(fw)->flag_mask.common.s.do_circulate_skip_icon = !!(x)
+#define DO_SKIP_SHADED_CIRCULATE(fw) \
+	((fw)->flags.common.s.do_circulate_skip_shaded)
+#define SET_DO_SKIP_SHADED_CIRCULATE(fw,x) \
+	(fw)->flags.common.s.do_circulate_skip_shaded = !!(x)
+#define SETM_DO_SKIP_SHADED_CIRCULATE(fw,x) \
+	(fw)->flag_mask.common.s.do_circulate_skip_shaded = !!(x)
+#define DO_SKIP_WINDOW_LIST(fw) \
+	((fw)->flags.common.s.do_window_list_skip)
+#define SET_DO_SKIP_WINDOW_LIST(fw,x) \
+	(fw)->flags.common.s.do_window_list_skip = !!(x)
+#define SETM_DO_SKIP_WINDOW_LIST(fw,x) \
+	(fw)->flag_mask.common.s.do_window_list_skip = !!(x)
+#define DO_STACK_TRANSIENT_PARENT(fw) \
+	((fw)->flags.common.s.do_stack_transient_parent)
+#define GET_TITLE_DIR(fw) \
+	((fw)->flags.common.title_dir)
+#define HAS_TITLE_DIR(fw,x) \
+	((fw)->flags.common.title_dir == x)
+#define SET_TITLE_DIR(fw,x) \
+	((fw)->flags.common.title_dir = x)
+#define SETM_TITLE_DIR(fw,x) \
+	((fw)->flag_mask.common.title_dir = ((x) ? DIR_MAJOR_MASK : 0))
+#define SET_USER_STATES(fw, mask) \
+	((fw)->flags.common.user_states |= (mask))
+#define CLEAR_USER_STATES(fw, mask) \
+	((fw)->flags.common.user_states &= ~(mask))
+#define TOGGLE_USER_STATES(fw, mask) \
+	((fw)->flags.common.user_states ^= (mask))
+#define SETM_USER_STATES(fw, mask) \
+	((fw)->flag_mask.common.user_states |= (mask))
+#define GET_USER_STATES(fw) \
+	((fw)->flags.common.user_states)
+#define GETM_USER_STATES(fw) \
+	((fw)->flag_mask.common.user_states)
+#define HAS_VERTICAL_TITLE(fw) \
+	((HAS_TITLE_DIR(fw,DIR_W) || HAS_TITLE_DIR(fw,DIR_E)))
+#define HAS_STIPPLED_TITLE(fw) \
+	((fw)->flags.common.s.has_stippled_title)
+#define SET_HAS_STIPPLED_TITLE(fw,x) \
+	(fw)->flags.common.s.has_stippled_title = !!(x)
+#define SETM_HAS_STIPPLED_TITLE(fw,x) \
+	(fw)->flag_mask.common.s.has_stippled_title = !!(x)
+#define HAS_STICKY_STIPPLED_TITLE(fw) \
+	!((fw)->flags.common.s.has_no_sticky_stippled_title)
+#define SET_HAS_STICKY_STIPPLED_TITLE(fw,x) \
+	(fw)->flags.common.s.has_no_sticky_stippled_title = !(x)
+#define SETM_HAS_STICKY_STIPPLED_TITLE(fw,x) \
+	(fw)->flag_mask.common.s.has_no_sticky_stippled_title = !!(x)
+#define HAS_STICKY_STIPPLED_ICON_TITLE(fw) \
+	!((fw)->flags.common.s.has_no_sticky_stippled_icon_title)
+#define SET_HAS_STICKY_STIPPLED_ICON_TITLE(fw,x) \
+	(fw)->flags.common.s.has_no_sticky_stippled_icon_title = !(x)
+#define SETM_HAS_STICKY_STIPPLED_ICON_TITLE(fw,x) \
+	(fw)->flag_mask.common.s.has_no_sticky_stippled_icon_title = !!(x)
+#define HAS_STIPPLED_ICON_TITLE(fw) \
+	((fw)->flags.common.s.has_stippled_icon_title)
+#define SET_HAS_STIPPLED_ICON_TITLE(fw,x) \
+	(fw)->flags.common.s.has_stippled_icon_title = !!(x)
+#define SETM_HAS_STIPPLED_ICON_TITLE(fw,x) \
+	(fw)->flag_mask.common.s.has_stippled_icon_title = !!(x)
+#define ICON_OVERRIDE_MODE(fw) \
+	((fw)->flags.common.s.icon_override)
+#define SET_ICON_OVERRIDE_MODE(fw,x) \
+	(fw)->flags.common.s.icon_override = ((x) & ICON_OVERRIDE_MASK)
+#define SETM_ICON_OVERRIDE_MODE(fw,x) \
+	(fw)->flag_mask.common.s.icon_override = ((x) ? ICON_OVERRIDE_MASK : 0)
+#define IS_ICON_STICKY_ACROSS_PAGES(fw) \
+	((fw)->flags.common.s.is_icon_sticky_across_pages)
+#define SET_ICON_STICKY_ACROSS_PAGES(fw,x) \
+	(fw)->flags.common.s.is_icon_sticky_across_pages = !!(x)
+#define SETM_ICON_STICKY_ACROSS_PAGES(fw,x) \
+	(fw)->flag_mask.common.s.is_icon_sticky_across_pages = !!(x)
+#define IS_ICON_STICKY_ACROSS_DESKS(fw) \
+	((fw)->flags.common.s.is_icon_sticky_across_desks)
+#define SET_ICON_STICKY_ACROSS_DESKS(fw,x) \
+	(fw)->flags.common.s.is_icon_sticky_across_desks = !!(x)
+#define SETM_ICON_STICKY_ACROSS_DESKS(fw,x) \
+	(fw)->flag_mask.common.s.is_icon_sticky_across_desks = !!(x)
+#define USE_ICON_POSITION_HINT(fw) \
+	((fw)->flags.common.s.use_icon_position_hint)
+#define SET_USE_ICON_POSITION_HINT(fw,x) \
+	(fw)->flags.common.s.use_icon_position_hint = !!(x)
+#define SETM_USE_ICON_POSITION_HINT(fw,x) \
+	(fw)->flag_mask.common.s.use_icon_position_hint = !!(x)
+#define USE_INDEXED_WINDOW_NAME(fw) \
+	((fw)->flags.common.s.use_indexed_window_name)
+#define SET_USE_INDEXED_WINDOW_NAME(fw,x) \
+	(fw)->flags.common.s.use_indexed_window_name = !!(x)
+#define SETM_USE_INDEXED_WINDOW_NAME(fw,x) \
+	(fw)->flag_mask.common.s.use_indexed_window_name = !!(x)
+#define USE_INDEXED_ICON_NAME(fw) \
+	((fw)->flags.common.s.use_indexed_icon_name)
+#define SET_USE_INDEXED_ICON_NAME(fw,x) \
+	(fw)->flags.common.s.use_indexed_icon_name = !!(x)
+#define SETM_USE_INDEXED_ICON_NAME(fw,x) \
+	(fw)->flag_mask.common.s.use_indexed_icon_name = !!(x)
+#define WINDOWSHADE_LAZINESS(fw) \
+	((fw)->flags.common.s.windowshade_laziness)
+#define SET_WINDOWSHADE_LAZINESS(fw,x) \
+	(fw)->flags.common.s.windowshade_laziness = \
+	((x) & WINDOWSHADE_LAZY_MASK)
+#define SETM_WINDOWSHADE_LAZINESS(fw,x) \
+	(fw)->flag_mask.common.s.windowshade_laziness = \
+	((x) ? WINDOWSHADE_LAZY_MASK : 0)
+#define DO_EWMH_MINI_ICON_OVERRIDE(fw) \
+	((fw)->flags.common.s.do_ewmh_mini_icon_override)
+#define SET_DO_EWMH_MINI_ICON_OVERRIDE(fw,x) \
+	(fw)->flags.common.s.do_ewmh_mini_icon_override = !!(x)
+#define SETM_DO_EWMH_MINI_ICON_OVERRIDE(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_mini_icon_override = !!(x)
+#define DO_EWMH_DONATE_ICON(fw) \
+	((fw)->flags.common.s.do_ewmh_donate_icon)
+#define SET_DO_EWMH_DONATE_ICON(fw,x) \
+	(fw)->flags.common.s.do_ewmh_donate_icon = !!(x)
+#define SETM_DO_EWMH_DONATE_ICON(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_donate_icon = !!(x)
+#define DO_EWMH_DONATE_MINI_ICON(fw) \
+	((fw)->flags.common.s.do_ewmh_donate_mini_icon)
+#define SET_DO_EWMH_DONATE_MINI_ICON(fw,x) \
+	(fw)->flags.common.s.do_ewmh_donate_mini_icon = !!(x)
+#define SETM_DO_EWMH_DONATE_MINI_ICON(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_donate_mini_icon = !!(x)
+#define DO_EWMH_USE_STACKING_HINTS(fw) \
+	((fw)->flags.common.s.do_ewmh_use_stacking_hints)
+#define SET_DO_EWMH_USE_STACKING_HINTS(fw,x) \
+	(fw)->flags.common.s.do_ewmh_use_stacking_hints = !!(x)
+#define SETM_DO_EWMH_USE_STACKING_HINTS(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_use_stacking_hints = !!(x)
+#define DO_EWMH_IGNORE_STRUT_HINTS(fw) \
+	((fw)->flags.common.s.do_ewmh_ignore_strut_hints)
+#define SET_DO_EWMH_IGNORE_STRUT_HINTS(fw,x) \
+	(fw)->flags.common.s.do_ewmh_ignore_strut_hints = !!(x)
+#define SETM_DO_EWMH_IGNORE_STRUT_HINTS(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_ignore_strut_hints = !!(x)
+#define DO_EWMH_IGNORE_STATE_HINTS(fw) \
+	((fw)->flags.common.s.do_ewmh_ignore_state_hints)
+#define SET_DO_EWMH_IGNORE_STATE_HINTS(fw,x) \
+	(fw)->flags.common.s.do_ewmh_ignore_state_hints = !!(x)
+#define SETM_DO_EWMH_IGNORE_STATE_HINTS(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_ignore_state_hints = !!(x)
+#define DO_EWMH_IGNORE_WINDOW_TYPE(fw) \
+	((fw)->flags.common.s.do_ewmh_ignore_window_type)
+#define SET_DO_EWMH_IGNORE_WINDOW_TYPE(fw,x) \
+	(fw)->flags.common.s.do_ewmh_ignore_window_type = !!(x)
+#define SETM_DO_EWMH_IGNORE_WINDOW_TYPE(fw,x) \
+	(fw)->flag_mask.common.s.do_ewmh_ignore_window_type = !!(x)
+#define EWMH_MAXIMIZE_MODE(fw) \
+	((fw)->flags.common.s.ewmh_maximize_mode)
+#define SET_EWMH_MAXIMIZE_MODE(fw,x) \
+	(fw)->flags.common.s.ewmh_maximize_mode = (x)
+#define SETM_EWMH_MAXIMIZE_MODE(fw,x) \
+	(fw)->flag_mask.common.s.ewmh_maximize_mode = (x)
+#define IS_ICON_SUPPRESSED(fw) \
+	((fw)->flags.common.s.is_icon_suppressed)
+#define SET_ICON_SUPPRESSED(fw,x) \
+	(fw)->flags.common.s.is_icon_suppressed = !!(x)
+#define SETM_ICON_SUPPRESSED(fw,x) \
+	(fw)->flag_mask.common.s.is_icon_suppressed = !!(x)
+#define IS_STICKY_ACROSS_PAGES(fw) \
+	((fw)->flags.common.is_sticky_across_pages)
+#define SET_STICKY_ACROSS_PAGES(fw,x) \
+	(fw)->flags.common.is_sticky_across_pages = !!(x)
+#define SETM_STICKY_ACROSS_PAGES(fw,x) \
+	(fw)->flag_mask.common.is_sticky_across_pages = !!(x)
+#define IS_STICKY_ACROSS_DESKS(fw) \
+	((fw)->flags.common.is_sticky_across_desks)
+#define SET_STICKY_ACROSS_DESKS(fw,x) \
+	(fw)->flags.common.is_sticky_across_desks = !!(x)
+#define SETM_STICKY_ACROSS_DESKS(fw,x) \
+	(fw)->flag_mask.common.is_sticky_across_desks = !!(x)
+#define HAS_ICON_FONT(fw) \
+	((fw)->flags.common.has_icon_font)
+#define SET_HAS_ICON_FONT(fw,x) \
+	(fw)->flags.common.has_icon_font = !!(x)
+#define SETM_HAS_ICON_FONT(fw,x) \
+	(fw)->flag_mask.common.has_icon_font = !!(x)
+#define HAS_NO_ICON_TITLE(fw) \
+	((fw)->flags.common.s.has_no_icon_title)
+#define SET_HAS_NO_ICON_TITLE(fw,x) \
+	(fw)->flags.common.s.has_no_icon_title = !!(x)
+#define SETM_HAS_NO_ICON_TITLE(fw,x) \
+	(fw)->flag_mask.common.s.has_no_icon_title = !!(x)
+#define HAS_WINDOW_FONT(fw) \
+	((fw)->flags.common.has_window_font)
+#define SET_HAS_WINDOW_FONT(fw,x) \
+	(fw)->flags.common.has_window_font = !!(x)
+#define SETM_HAS_WINDOW_FONT(fw,x) \
+	(fw)->flag_mask.common.has_window_font = !!(x)
+#define HAS_MWM_BORDER(fw) \
+	((fw)->flags.common.s.has_mwm_border)
+#define HAS_MWM_BUTTONS(fw) \
+	((fw)->flags.common.s.has_mwm_buttons)
+#define HAS_MWM_OVERRIDE_HINTS(fw) \
+	((fw)->flags.common.s.has_mwm_override)
+#define HAS_OVERRIDE_SIZE_HINTS(fw) \
+	((fw)->flags.common.s.has_override_size)
+#define DO_ICONIFY_WINDOW_GROUPS(fw) \
+	((fw)->flags.common.s.do_iconify_window_groups)
+#define DO_IGNORE_GNOME_HINTS(fw) \
+	((fw)->flags.common.s.do_ignore_gnome_hints)
+#define DO_IGNORE_RESTACK(fw) \
+	((fw)->flags.common.s.do_ignore_restack)
+#define DO_IGNORE_ICON_BOXES(fw) \
+	((fw)->flags.common.s.do_ignore_icon_boxes)
+#define DO_USE_WINDOW_GROUP_HINT(fw) \
+	((fw)->flags.common.s.do_use_window_group_hint)
+#define IS_FIXED(fw) \
+	((fw)->flags.common.s.is_fixed)
+#define SET_FIXED(fw,x) \
+	(fw)->flags.common.s.is_fixed = !!(x)
+#define SETM_FIXED(fw,x) \
+	(fw)->flag_mask.common.s.is_fixed = !!(x)
+#define IS_FIXED_PPOS(fw) \
+	((fw)->flags.common.s.is_fixed_ppos)
+#define SET_FIXED_PPOS(fw,x) \
+	(fw)->flags.common.s.is_fixed_ppos = !!(x)
+#define SETM_FIXED_PPOS(fw,x) \
+	(fw)->flag_mask.common.s.is_fixed_ppos = !!(x)
+#define IS_SIZE_FIXED(fw) \
+	((fw)->flags.common.s.is_size_fixed)
+#define SET_SIZE_FIXED(fw,x) \
+	(fw)->flags.common.s.is_size_fixed = !!(x)
+#define SETM_SIZE_FIXED(fw,x) \
+	(fw)->flag_mask.common.s.is_size_fixed = !!(x)
+#define IS_PSIZE_FIXED(fw) \
+	((fw)->flags.common.s.is_psize_fixed)
+#define SET_PSIZE_FIXED(fw,x) \
+	(fw)->flags.common.s.is_psize_fixed = !!(x)
+#define SETM_PSIZE_FIXED(fw,x) \
+	(fw)->flag_mask.common.s.is_psize_fixed = !!(x)
+#define IS_UNICONIFIABLE(fw) \
+	((fw)->flags.common.s.is_uniconifiable)
+#define SET_IS_UNICONIFIABLE(fw,x) \
+	(fw)->flags.common.s.is_uniconifiable = !!(x)
+#define SETM_IS_UNICONIFIABLE(fw,x) \
+	(fw)->flag_mask.common.s.is_uniconifiable = !!(x)
+#define IS_UNMAXIMIZABLE(fw) \
+	((fw)->flags.common.s.is_unmaximizable)
+#define SET_IS_UNMAXIMIZABLE(fw,x) \
+	(fw)->flags.common.s.is_unmaximizable = !!(x)
+#define SETM_IS_UNMAXIMIZABLE(fw,x) \
+	(fw)->flag_mask.common.s.is_unmaximizable = !!(x)
+#define IS_UNCLOSABLE(fw) \
+	((fw)->flags.common.s.is_unclosable)
+#define SET_IS_UNCLOSABLE(fw,x) \
+	(fw)->flags.common.s.is_unclosable = !!(x)
+#define SETM_IS_UNCLOSABLE(fw,x) \
+	(fw)->flag_mask.common.s.is_unclosable = !!(x)
+#define IS_MAXIMIZE_FIXED_SIZE_DISALLOWED(fw) \
+	((fw)->flags.common.s.is_maximize_fixed_size_disallowed)
+#define SET_MAXIMIZE_FIXED_SIZE_DISALLOWED(fw,x) \
+	(fw)->flags.common.s.is_maximize_fixed_size_disallowed = !!(x)
+#define SETM_MAXIMIZE_FIXED_SIZE_DISALLOWED(fw,x) \
+	(fw)->flag_mask.common.s.is_maximize_fixed_size_disallowed = !!(x)
+#define HAS_DEPRESSABLE_BORDER(fw) \
+	((fw)->flags.common.s.has_depressable_border)
+
+#define IS_LEFT_TITLE_ROTATED_CW(fw) \
+	((fw)->flags.common.s.is_left_title_rotated_cw)
+#define SET_IS_LEFT_TITLE_ROTATED_CW(fw,x) \
+	(fw)->flags.common.s.is_left_title_rotated_cw = !!(x)
+#define SETM_IS_LEFT_TITLE_ROTATED_CW(fw,x) \
+	(fw)->flag_mask.common.s.is_left_title_rotated_cw = !!(x)
+#define IS_RIGHT_TITLE_ROTATED_CW(fw) \
+	((fw)->flags.common.s.is_right_title_rotated_cw)
+#define SET_IS_RIGHT_TITLE_ROTATED_CW(fw,x) \
+	(fw)->flags.common.s.is_right_title_rotated_cw = !!(x)
+#define SETM_IS_RIGHT_TITLE_ROTATED_CW(fw,x) \
+	(fw)->flag_mask.common.s.is_right_title_rotated_cw = !!(x)
+#define IS_BOTTOM_TITLE_ROTATED(fw) \
+	((fw)->flags.common.s.is_bottom_title_rotated)
+#define SET_IS_BOTTOM_TITLE_ROTATED(fw,x) \
+	(fw)->flags.common.s.is_bottom_title_rotated = !!(x)
+#define SETM_IS_BOTTOM_TITLE_ROTATED(fw,x) \
+	(fw)->flag_mask.common.s.is_bottom_title_rotated = !!(x)
+#define IS_BOTTOM_TITLE_ROTATED(fw) \
+	((fw)->flags.common.s.is_bottom_title_rotated)
+#define SET_IS_BOTTOM_TITLE_ROTATED(fw,x) \
+	(fw)->flags.common.s.is_bottom_title_rotated = !!(x)
+#define SETM_IS_BOTTOM_TITLE_ROTATED(fw,x) \
+	(fw)->flag_mask.common.s.is_bottom_title_rotated = !!(x)
+#define USE_TITLE_DECOR_ROTATION(fw) \
+	((fw)->flags.common.s.use_title_decor_rotation)
+#define SET_USE_TITLE_DECOR_ROTATION(fw,x) \
+	(fw)->flags.common.s.use_title_decor_rotation = !!(x)
+#define SETM_USE_TITLE_DECOR_ROTATION(fw,x) \
+	(fw)->flag_mask.common.s.use_title_decor_rotation = !!(x)
+
+/* access to the special flags of a window */
+#define DO_REUSE_DESTROYED(fw) \
+	((fw)->flags.do_reuse_destroyed)
+#define SET_DO_REUSE_DESTROYED(fw,x) \
+	(fw)->flags.do_reuse_destroyed = !!(x)
+#define SETM_DO_REUSE_DESTROYED(fw,x) \
+	(fw)->flag_mask.do_reuse_destroyed = !!(x)
+#define HAS_NO_BORDER(fw) \
+	((fw)->flags.common.has_no_border)
+#define SET_HAS_NO_BORDER(fw,x) \
+	(fw)->flags.common.has_no_border = !!(x)
+#define SETM_HAS_NO_BORDER(fw,x) \
+	(fw)->flag_mask.common.has_no_border = !!(x)
+#define HAS_HANDLES(fw) \
+	((fw)->flags.has_handles)
+#define SET_HAS_HANDLES(fw,x) \
+	(fw)->flags.has_handles = !!(x)
+#define SETM_HAS_HANDLES(fw,x) \
+	(fw)->flag_mask.has_handles = !!(x)
+#define HAS_ICON_CHANGED(fw) \
+	((fw)->flags.has_icon_changed)
+#define SET_HAS_ICON_CHANGED(fw,x) \
+	(fw)->flags.has_icon_changed = !!(x)
+#define SETM_HAS_ICON_CHANGED(fw,x) \
+	(fw)->flag_mask.has_icon_changed = !!(x)
+#define HAS_TITLE(fw) \
+	((fw)->flags.has_title)
+#define SET_HAS_TITLE(fw,x) \
+	(fw)->flags.has_title = !!(x)
+#define SETM_HAS_TITLE(fw,x) \
+	(fw)->flag_mask.has_title = !!(x)
+#define HAS_NEW_WM_NORMAL_HINTS(fw) \
+	((fw)->flags.has_new_wm_normal_hints)
+#define SET_HAS_NEW_WM_NORMAL_HINTS(fw,x) \
+	(fw)->flags.has_new_wm_normal_hints = !!(x)
+#define SETM_HAS_NEW_WM_NORMAL_HINTS(fw,x) \
+	(fw)->flag_mask.has_new_wm_normal_hints = !!(x)
+#define IS_MAPPED(fw) \
+	((fw)->flags.is_mapped)
+#define SET_MAPPED(fw,x) \
+	(fw)->flags.is_mapped = !!(x)
+#define SETM_MAPPED(fw,x) \
+	(fw)->flag_mask.is_mapped = !!(x)
+#define IS_DECOR_CHANGED(fw) \
+	((fw)->flags.is_decor_changed)
+#define SET_DECOR_CHANGED(fw,x) \
+	(fw)->flags.is_decor_changed = !!(x)
+#define SETM_DECOR_CHANGED(fw,x) \
+	(fw)->flag_mask.is_decor_changed = !!(x)
+#define IS_ICON_FONT_LOADED(fw) \
+	((fw)->flags.is_icon_font_loaded)
+#define SET_ICON_FONT_LOADED(fw,x) \
+	(fw)->flags.is_icon_font_loaded = !!(x)
+#define SETM_ICON_FONT_LOADED(fw,x) \
+	(fw)->flag_mask.is_icon_font_loaded = !!(x)
+#define IS_ICONIFIED(fw) \
+	((fw)->flags.is_iconified)
+#define SET_ICONIFIED(fw,x) \
+	(fw)->flags.is_iconified = !!(x)
+#define SETM_ICONIFIED(fw,x) \
+	(fw)->flag_mask.is_iconified = !!(x)
+#define IS_ICONIFIED_BY_PARENT(fw) \
+	((fw)->flags.is_iconified_by_parent)
+#define SET_ICONIFIED_BY_PARENT(fw,x) \
+	(fw)->flags.is_iconified_by_parent = !!(x)
+#define SETM_ICONIFIED_BY_PARENT(fw,x) \
+	(fw)->flag_mask.is_iconified_by_parent = !!(x)
+#define IS_ICON_ENTERED(fw) \
+	((fw)->flags.is_icon_entered)
+#define SET_ICON_ENTERED(fw,x) \
+	(fw)->flags.is_icon_entered = !!(x)
+#define SETM_ICON_ENTERED(fw,x) \
+	(fw)->flag_mask.is_icon_entered = !!(x)
+#define IS_ICON_OURS(fw) \
+	((fw)->flags.is_icon_ours)
+#define SET_ICON_OURS(fw,x) \
+	(fw)->flags.is_icon_ours = !!(x)
+#define SETM_ICON_OURS(fw,x) \
+	(fw)->flag_mask.is_icon_ours = !!(x)
+#define IS_ICON_SHAPED(fw) \
+	((fw)->flags.is_icon_shaped)
+#define SET_ICON_SHAPED(fw,x) \
+	(fw)->flags.is_icon_shaped = !!(x)
+#define SETM_ICON_SHAPED(fw,x) \
+	(fw)->flag_mask.is_icon_shaped = !!(x)
+#define IS_ICON_MOVED(fw) \
+	((fw)->flags.is_icon_moved)
+#define SET_ICON_MOVED(fw,x) \
+	(fw)->flags.is_icon_moved = !!(x)
+#define SETM_ICON_MOVED(fw,x) \
+	(fw)->flag_mask.is_icon_moved = !!(x)
+#define IS_ICON_UNMAPPED(fw) \
+	((fw)->flags.is_icon_unmapped)
+#define SET_ICON_UNMAPPED(fw,x) \
+	(fw)->flags.is_icon_unmapped = !!(x)
+#define SETM_ICON_UNMAPPED(fw,x) \
+	(fw)->flag_mask.is_icon_unmapped = !!(x)
+#define IS_IN_TRANSIENT_SUBTREE(fw) \
+	((fw)->flags.is_in_transient_subtree)
+#define SET_IN_TRANSIENT_SUBTREE(fw,x) \
+	(fw)->flags.is_in_transient_subtree = !!(x)
+#define IS_MAP_PENDING(fw) \
+	((fw)->flags.is_map_pending)
+#define SET_MAP_PENDING(fw,x) \
+	(fw)->flags.is_map_pending = !!(x)
+#define SETM_MAP_PENDING(fw,x) \
+	(fw)->flag_mask.is_map_pending = !!(x)
+#define IS_MAXIMIZED(fw) \
+	((fw)->flags.is_maximized)
+#define SET_MAXIMIZED(fw,x) \
+	(fw)->flags.is_maximized = !!(x)
+#define SETM_MAXIMIZED(fw,x) \
+	(fw)->flag_mask.is_maximized = !!(x)
+#define IS_NAME_CHANGED(fw) \
+	((fw)->flags.is_name_changed)
+#define SET_NAME_CHANGED(fw,x) \
+	(fw)->flags.is_name_changed = !!(x)
+#define SETM_NAME_CHANGED(fw,x) \
+	(fw)->flag_mask.is_name_changed = !!(x)
+#define IS_PIXMAP_OURS(fw) \
+	((fw)->flags.is_pixmap_ours)
+#define SET_PIXMAP_OURS(fw,x) \
+	(fw)->flags.is_pixmap_ours = !!(x)
+#define SETM_PIXMAP_OURS(fw,x) \
+	(fw)->flag_mask.is_pixmap_ours = !!(x)
+#define IS_PLACED_BY_FVWM(fw) \
+	((fw)->flags.is_placed_by_fvwm)
+#define SET_PLACED_BY_FVWM(fw,x) \
+	(fw)->flags.is_placed_by_fvwm = (x)
+#define SETM_PLACED_BY_FVWM(fw,x) \
+	(fw)->flag_mask.is_placed_by_fvwm = (x)
+#define IS_SCHEDULED_FOR_DESTROY(fw) \
+	((fw)->flags.is_scheduled_for_destroy)
+#define SET_SCHEDULED_FOR_DESTROY(fw,x) \
+	(fw)->flags.is_scheduled_for_destroy = !!(x)
+#define IS_SCHEDULED_FOR_RAISE(fw) \
+	((fw)->flags.is_scheduled_for_raise)
+#define SET_SCHEDULED_FOR_RAISE(fw,x) \
+	(fw)->flags.is_scheduled_for_raise = !!(x)
+#define IS_SHADED(fw) \
+	((fw)->flags.is_window_shaded)
+#define USED_TITLE_DIR_FOR_SHADING(fw) \
+	((fw)->flags.used_title_dir_for_shading)
+#define SET_USED_TITLE_DIR_FOR_SHADING(fw,x) \
+	((fw)->flags.used_title_dir_for_shading = !!(x))
+#define SHADED_DIR(fw) \
+	((fw)->flags.shaded_dir)
+#define SET_SHADED(fw,x) \
+	(fw)->flags.is_window_shaded = !!(x)
+#define SET_SHADED_DIR(fw,x) \
+	(fw)->flags.shaded_dir = (x)
+#define SETM_SHADED(fw,x) \
+	(fw)->flag_mask.is_window_shaded = !!(x)
+#define IS_TEAR_OFF_MENU(fw) \
+	((fw)->flags.is_tear_off_menu)
+#define SET_TEAR_OFF_MENU(fw,x) \
+	(fw)->flags.is_tear_off_menu = !!(x)
+#define SETM_TEAR_OFF_MENU(fw,x) \
+	(fw)->flag_mask.is_tear_off_menu = !!(x)
+#define IS_TRANSIENT(fw) \
+	((fw)->flags.is_transient)
+#define SET_TRANSIENT(fw,x) \
+	(fw)->flags.is_transient = !!(x)
+#define SETM_TRANSIENT(fw,x) \
+	(fw)->flag_mask.is_transient = !!(x)
+#define IS_ICONIFY_PENDING(fw) \
+	((fw)->flags.is_iconify_pending)
+#define SET_ICONIFY_PENDING(fw,x) \
+	(fw)->flags.is_iconify_pending = !!(x)
+#define SETM_ICONIFY_PENDING(fw,x) \
+	(fw)->flag_mask.is_iconify_pending = !!(x)
+#define DO_ICONIFY_AFTER_MAP(fw) \
+	((fw)->flags.do_iconify_after_map)
+#define SET_ICONIFY_AFTER_MAP(fw,x) \
+	(fw)->flags.do_iconify_after_map = !!(x)
+#define SETM_ICONIFY_AFTER_MAP(fw,x) \
+	(fw)->flag_mask.do_iconify_after_map = !!(x)
+#define DO_DISABLE_CONSTRAIN_SIZE_FULLSCREEN(fw) \
+	((fw)->flags.do_disable_constrain_size_fullscreen)
+#define SET_DISABLE_CONSTRAIN_SIZE_FULLSCREEN(fw,x) \
+	(fw)->flags.do_disable_constrain_size_fullscreen = !!(x)
+#define SETM_DISABLE_CONSTRAIN_SIZE_FULLSCREEN(fw,x) \
+	(fw)->flag_mask.do_disable_constrain_size_fullscreen = !!(x)
+#define IS_SIZE_INC_SET(fw) \
+	((fw)->flags.is_size_inc_set)
+#define SET_SIZE_INC_SET(fw,x) \
+	(fw)->flags.is_size_inc_set = !!(x)
+#define SETM_SIZE_INC_SET(fw,x) \
+	(fw)->flag_mask.is_size_inc_set = !!(x)
+#define IS_STYLE_DELETED(fw) \
+	((fw)->flags.is_style_deleted)
+#define SET_STYLE_DELETED(fw,x) \
+	(fw)->flags.is_style_deleted = !!(x)
+#define SETM_STYLE_DELETED(fw,x) \
+	(fw)->flag_mask.is_style_deleted = !!(x)
+#define IS_VIEWPORT_MOVED(fw) \
+	((fw)->flags.is_viewport_moved)
+#define SET_VIEWPORT_MOVED(fw,x) \
+	(fw)->flags.is_viewport_moved = !!(x)
+#define SETM_VIEWPORT_MOVED(fw,x) \
+	(fw)->flag_mask.is_viewport_moved = !!(x)
+#define IS_VIEWPORT_MOVED(fw) \
+	((fw)->flags.is_viewport_moved)
+#define IS_FOCUS_CHANGE_BROADCAST_PENDING(fw) \
+	((fw)->flags.is_focus_change_broadcast_pending)
+#define SET_FOCUS_CHANGE_BROADCAST_PENDING(fw,x) \
+	(fw)->flags.is_focus_change_broadcast_pending = !!(x)
+#define SETM_FOCUS_CHANGE_BROADCAST_PENDING(fw,x) \
+	(fw)->flag_mask.is_focus_change_broadcast_pending = !!(x)
+#define IS_FULLY_VISIBLE(fw) \
+	((fw)->flags.is_fully_visible)
+#define SET_FULLY_VISIBLE(fw,x) \
+	(fw)->flags.is_fully_visible = !!(x)
+#define SETM_FULLY_VISIBLE(fw,x) \
+	(fw)->flag_mask.is_fully_visible = !!(x)
+#define IS_PARTIALLY_VISIBLE(fw) \
+	((fw)->flags.is_partially_visible)
+#define SET_PARTIALLY_VISIBLE(fw,x) \
+	(fw)->flags.is_partially_visible = !!(x)
+#define SETM_PARTIALLY_VISIBLE(fw,x) \
+	(fw)->flag_mask.is_partially_visible = !!(x)
+#define IS_WINDOW_DRAWN_ONCE(fw) \
+	((fw)->flags.is_window_drawn_once)
+#define SET_WINDOW_DRAWN_ONCE(fw,x) \
+	(fw)->flags.is_window_drawn_once = !!(x)
+#define SETM_WINDOW_DRAWN_ONCE(fw,x) \
+	(fw)->flag_mask.is_window_drawn_once = !!(x)
+#define IS_WINDOW_BEING_MOVED_OPAQUE(fw) \
+	((fw)->flags.is_window_being_moved_opaque)
+#define SET_WINDOW_BEING_MOVED_OPAQUE(fw,x) \
+	(fw)->flags.is_window_being_moved_opaque = !!(x)
+#define SETM_WINDOW_BEING_MOVED_OPAQUE(fw,x) \
+	(fw)->flag_mask.is_window_being_moved_opaque = !!(x)
+#define IS_WINDOW_BORDER_DRAWN(fw) \
+	((fw)->flags.is_window_border_drawn)
+#define SET_WINDOW_BORDER_DRAWN(fw,x) \
+	(fw)->flags.is_window_border_drawn = !!(x)
+#define SETM_WINDOW_BORDER_DRAWN(fw,x) \
+	(fw)->flag_mask.is_window_border_drawn = !!(x)
+#define IS_WINDOW_FONT_LOADED(fw) \
+	((fw)->flags.is_window_font_loaded)
+#define SET_WINDOW_FONT_LOADED(fw,x) \
+	(fw)->flags.is_window_font_loaded = !!(x)
+#define SETM_WINDOW_FONT_LOADED(fw,x) \
+	(fw)->flag_mask.is_window_font_loaded = !!(x)
+#define CR_MOTION_METHOD(fw) \
+	((fw)->flags.cr_motion_method)
+#define SET_CR_MOTION_METHOD(fw,x) \
+	(fw)->flags.cr_motion_method = ((x) & CR_MOTION_METHOD_MASK)
+#define SETM_CR_MOTION_METHOD(fw,x) \
+	(fw)->flag_mask.cr_motion_method = ((x) ? CR_MOTION_METHOD_MASK : 0)
+#define WAS_CR_MOTION_METHOD_DETECTED(fw) \
+	((fw)->flags.was_cr_motion_method_detected)
+#define SET_CR_MOTION_METHOD_DETECTED(fw,x) \
+	(fw)->flags.was_cr_motion_method_detected = !!(x)
+#define SETM_CR_MOTION_METHOD_DETECTED(fw,x) \
+	(fw)->flag_mask.was_cr_motion_method_detected = !!(x)
+#define WM_DELETES_WINDOW(fw) \
+	((fw)->flags.does_wm_delete_window)
+#define SET_WM_DELETES_WINDOW(fw,x) \
+	(fw)->flags.does_wm_delete_window = !!(x)
+#define SETM_WM_DELETES_WINDOW(fw,x) \
+	(fw)->flag_mask.does_wm_delete_window = !!(x)
+#define WM_TAKES_FOCUS(fw) \
+	((fw)->flags.does_wm_take_focus)
+#define SET_WM_TAKES_FOCUS(fw,x) \
+	(fw)->flags.does_wm_take_focus = !!(x)
+#define SETM_WM_TAKES_FOCUS(fw,x) \
+	(fw)->flag_mask.does_wm_take_focus = !!(x)
+#define DO_FORCE_NEXT_CR(fw) \
+	((fw)->flags.do_force_next_cr)
+#define SET_FORCE_NEXT_CR(fw,x) \
+	(fw)->flags.do_force_next_cr = !!(x)
+#define SETM_FORCE_NEXT_CR(fw,x) \
+	(fw)->flag_mask.do_force_next_cr = !!(x)
+#define DO_FORCE_NEXT_PN(fw) \
+	((fw)->flags.do_force_next_pn)
+#define SET_FORCE_NEXT_PN(fw,x) \
+	(fw)->flags.do_force_next_pn = !!(x)
+#define SETM_FORCE_NEXT_PN(fw,x) \
+	(fw)->flag_mask.do_force_next_pn = !!(x)
+#define USING_DEFAULT_WINDOW_FONT(fw) \
+	((fw)->flags.using_default_window_font)
+#define SET_USING_DEFAULT_WINDOW_FONT(fw,x) \
+	(fw)->flags.using_default_window_font = !!(x)
+#define SETM_USING_DEFAULT_WINDOW_FONT(fw,x) \
+	(fw)->flag_mask.using_default_window_font = !!(x)
+#define USING_DEFAULT_ICON_FONT(fw) \
+	((fw)->flags.using_default_icon_font)
+#define SET_USING_DEFAULT_ICON_FONT(fw,x) \
+	(fw)->flags.using_default_icon_font = !!(x)
+#define SETM_USING_DEFAULT_ICON_FONT(fw,x) \
+	(fw)->flag_mask.using_default_icon_font = !!(x)
+#define WAS_ICON_HINT_PROVIDED(fw) \
+	((fw)->flags.was_icon_hint_provided)
+#define SET_WAS_ICON_HINT_PROVIDED(fw,x) \
+	(fw)->flags.was_icon_hint_provided = (x)
+#define SETM_WAS_ICON_HINT_PROVIDED(fw,x) \
+	(fw)->flag_mask.was_icon_hint_provided = (x)
+#define WAS_ICON_NAME_PROVIDED(fw) \
+	((fw)->flags.was_icon_name_provided)
+#define SET_WAS_ICON_NAME_PROVIDED(fw,x) \
+	(fw)->flags.was_icon_name_provided = (x)
+#define SETM_WAS_ICON_NAME_PROVIDED(fw,x) \
+	(fw)->flag_mask.was_icon_name_provided = (x)
+#define WAS_NEVER_DRAWN(fw) \
+	((fw)->flags.was_never_drawn)
+#define SET_WAS_NEVER_DRAWN(fw,x) \
+	(fw)->flags.was_never_drawn = (x)
+#define SETM_WAS_NEVER_DRAWN(fw,x) \
+	(fw)->flag_mask.was_never_drawn = (x)
+#define HAS_EWMH_WM_NAME(fw) \
+	((fw)->flags.has_ewmh_wm_name)
+#define SET_HAS_EWMH_WM_NAME(fw,x) \
+	(fw)->flags.has_ewmh_wm_name = !!(x)
+#define SETM_HAS_EWMH_WM_NAME(fw,x) \
+	(fw)->flag_mask.has_ewmh_wm_name = !!(x)
+#define HAS_EWMH_WM_ICON_NAME(fw) \
+	((fw)->flags.has_ewmh_wm_icon_name)
+#define SET_HAS_EWMH_WM_ICON_NAME(fw,x) \
+	(fw)->flags.has_ewmh_wm_icon_name = !!(x)
+#define SETM_HAS_EWMH_WM_ICON_NAME(fw,x) \
+	(fw)->flag_mask.has_ewmh_wm_icon_name = !!(x)
+#define HAS_EWMH_WM_ICON_HINT(fw) \
+	((fw)->flags.has_ewmh_wm_icon_hint)
+#define SET_HAS_EWMH_WM_ICON_HINT(fw,x) \
+	(fw)->flags.has_ewmh_wm_icon_hint = (x)
+#define SETM_HAS_EWMH_WM_ICON_HINT(fw,x) \
+	(fw)->flag_mask.has_ewmh_wm_icon_hint = (x)
+#define USE_EWMH_ICON(fw) \
+	((fw)->flags.use_ewmh_icon)
+#define SET_USE_EWMH_ICON(fw,x) \
+	(fw)->flags.use_ewmh_icon = !!(x)
+#define SETM_USE_EWMH_ICON(fw,x) \
+	(fw)->flag_mask.use_ewmh_icon = !!(x)
+#define HAS_EWMH_MINI_ICON(fw) \
+	((fw)->flags.has_ewmh_mini_icon)
+#define SET_HAS_EWMH_MINI_ICON(fw,x) \
+	(fw)->flags.has_ewmh_mini_icon = !!(x)
+#define SETM_HAS_EWMH_MINI_ICON(fw,x) \
+	(fw)->flag_mask.has_ewmh_mini_icon = !!(x)
+#define HAS_EWMH_WM_PID(fw) \
+	((fw)->flags.has_ewmh_wm_pid)
+#define SET_HAS_EWMH_WM_PID(fw,x) \
+	(fw)->flags.has_ewmh_wm_pid = !!(x)
+#define SETM_HAS_EWMH_WM_PID(fw,x) \
+	(fw)->flag_mask.has_ewmh_wm_pid = !!(x)
+#define IS_EWMH_MODAL(fw) \
+	((fw)->flags.is_ewmh_modal)
+#define SET_EWMH_MODAL(fw,x) \
+	(fw)->flags.is_ewmh_modal = !!(x)
+#define SETM_EWMH_MODAL(fw,x) \
+	(fw)->flag_mask.is_ewmh_modal = !!(x)
+#define IS_EWMH_FULLSCREEN(fw) \
+	((fw)->flags.is_ewmh_fullscreen)
+#define SET_EWMH_FULLSCREEN(fw,x) \
+	(fw)->flags.is_ewmh_fullscreen = !!(x)
+#define SETM_EWMH_FULLSCREEN(fw,x) \
+	(fw)->flag_mask.is_ewmh_fullscreen = !!(x)
+#define SET_HAS_EWMH_INIT_FULLSCREEN_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_fullscreen_state = (x)
+#define SETM_HAS_EWMH_INIT_FULLSCREEN_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_fullscreen_state = (x)
+#define HAS_EWMH_INIT_FULLSCREEN_STATE(fw) \
+	((fw)->flags.has_ewmh_init_fullscreen_state)
+#define SET_HAS_EWMH_INIT_HIDDEN_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_hidden_state = (x)
+#define SETM_HAS_EWMH_INIT_HIDDEN_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_hidden_state = (x)
+#define HAS_EWMH_INIT_HIDDEN_STATE(fw) \
+	((fw)->flags.has_ewmh_init_hidden_state)
+#define SET_HAS_EWMH_INIT_MAXHORIZ_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_maxhoriz_state = (x)
+#define SETM_HAS_EWMH_INIT_MAXHORIZ_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_maxhoriz_state = (x)
+#define HAS_EWMH_INIT_MAXHORIZ_STATE(fw) \
+	((fw)->flags.has_ewmh_init_maxhoriz_state)
+#define SET_HAS_EWMH_INIT_MAXVERT_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_maxvert_state = (x)
+#define SETM_HAS_EWMH_INIT_MAXVERT_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_maxvert_state = (x)
+#define HAS_EWMH_INIT_MAXVERT_STATE(fw) \
+	((fw)->flags.has_ewmh_init_maxvert_state)
+#define SET_HAS_EWMH_INIT_MODAL_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_modal_state = (x)
+#define SETM_HAS_EWMH_INIT_MODAL_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_modal_state = (x)
+#define HAS_EWMH_INIT_MODAL_STATE(fw) \
+	((fw)->flags.has_ewmh_init_modal_state)
+#define SET_HAS_EWMH_INIT_SHADED_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_shaded_state = (x)
+#define SETM_HAS_EWMH_INIT_SHADED_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_shaded_state = (x)
+#define HAS_EWMH_INIT_SHADED_STATE(fw) \
+	((fw)->flags.has_ewmh_init_shaded_state)
+#define SET_HAS_EWMH_INIT_SKIP_PAGER_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_skip_pager_state = (x)
+#define SETM_HAS_EWMH_INIT_SKIP_PAGER_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_skip_pager_state = (x)
+#define HAS_EWMH_INIT_SKIP_PAGER_STATE(fw) \
+	((fw)->flags.has_ewmh_init_skip_pager_state)
+#define SET_HAS_EWMH_INIT_SKIP_TASKBAR_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_skip_taskbar_state = (x)
+#define SETM_HAS_EWMH_INIT_SKIP_TASKBAR_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_skip_taskbar_state = (x)
+#define HAS_EWMH_INIT_SKIP_TASKBAR_STATE(fw) \
+	((fw)->flags.has_ewmh_init_skip_taskbar_state)
+#define SET_HAS_EWMH_INIT_STICKY_STATE(fw,x) \
+	(fw)->flags.has_ewmh_init_sticky_state = (x)
+#define SETM_HAS_EWMH_INIT_STICKY_STATE(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_sticky_state = (x)
+#define HAS_EWMH_INIT_STICKY_STATE(fw) \
+	((fw)->flags.has_ewmh_init_sticky_state)
+#define SET_HAS_EWMH_INIT_WM_DESKTOP(fw,x) \
+	(fw)->flags.has_ewmh_init_wm_desktop = (x)
+#define SETM_HAS_EWMH_INIT_WM_DESKTOP(fw,x) \
+	(fw)->flag_mask.has_ewmh_init_wm_desktop = (x)
+#define HAS_EWMH_INIT_WM_DESKTOP(fw) \
+	((fw)->flags.has_ewmh_init_wm_desktop)
+
+#endif /* _WINDOW_FLAGS_ */
