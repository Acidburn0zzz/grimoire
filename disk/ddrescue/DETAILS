           SPELL=ddrescue
         VERSION=1.14
     SOURCE_HASH=sha512:fa846b423c1309d19e0ff03bd69ba87f4df4200e7f5b8107e1fdfca2e6a7c1dc01d41ca01b92b9adc767e1d562fb4274a91d9195a1c99accf16aa01be7e4eac6
          SOURCE="$SPELL-$VERSION.tar.gz"
   SOURCE_URL[0]=http://download.savannah.gnu.org/releases/$SPELL/$SOURCE
   SOURCE_URL[1]=$GNU_URL/$SPELL/$SOURCE
SOURCE_DIRECTORY="${BUILD_DIRECTORY}/$SPELL-$VERSION"
        WEB_SITE=http://www.gnu.org/software/ddrescue/ddrescue.html
      LICENSE[0]=GPL
         ENTERED=20060827
           SHORT="a data recovery tool"
cat << EOF
It copies data from one file or block device (hard disc, cdrom, etc) to
another, trying hard to rescue data in case of read errors.

Ddrescue does not truncate the output file if not asked to. So, every time
you run it on the same output file, it tries to fill in the gaps.

The basic operation of ddrescue is fully automatic. That is, you don't have to
wait for an error, stop the program, read the log, run it in reverse mode, etc.

If you use the logfile feature of ddrescue, the data is rescued very
efficiently (only the needed blocks are read). Also you can interrupt the
rescue at any time and resume it later at the same point.

Automatic merging of backups: If you have two or more damaged copies of
a file, cdrom, etc, and run ddrescue on all of them, one at a time, with
the same output file, you will probably obtain a complete and error-free
file. This is so because the probability of having damaged areas at the
same places on different input files is very low. Using the logfile, only
the needed blocks are read from the second and successive copies.
EOF
