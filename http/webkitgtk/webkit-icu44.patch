diff -Naur webkit-1.2.0/WebCore/ChangeLog webkit-1.2.0.fixed/WebCore/ChangeLog
--- webkit-1.2.0/WebCore/ChangeLog	2010-04-05 14:51:20.000000000 +0200
+++ webkit-1.2.0.fixed/WebCore/ChangeLog	2010-04-08 15:40:42.227947390 +0200
@@ -1,3 +1,24 @@
+2010-03-20  Darin Adler  <darin@apple.com>
+
+        Reviewed by NOBODY (OOPS!).
+
+        TextBreakIteratorICU.cpp is incompatible with new UBreakIterator type in ICU 4.4
+        https://bugs.webkit.org/show_bug.cgi?id=36381
+
+        * platform/text/TextBreakIteratorICU.cpp:
+        (WebCore::setUpIterator): Use reinterpret_cast instead of static_cast or relying
+        on conversion to void*.
+        (WebCore::textBreakFirst): Ditto.
+        (WebCore::textBreakLast): Ditto.
+        (WebCore::textBreakNext): Ditto.
+        (WebCore::textBreakPrevious): Ditto.
+        (WebCore::textBreakPreceding): Ditto.
+        (WebCore::textBreakFollowing): Ditto.
+        (WebCore::textBreakCurrent): Ditto.
+        (WebCore::isTextBreak): Ditto.
+        (WebCore::setUpIteratorWithRules): Ditto.
+
+
 2010-04-01  MORITA Hajime  <morrita@google.com>
 
         Reviewed by Darin Adler.
diff -Naur webkit-1.2.0/WebCore/platform/text/TextBreakIteratorICU.cpp webkit-1.2.0.fixed/WebCore/platform/text/TextBreakIteratorICU.cpp
--- webkit-1.2.0/WebCore/platform/text/TextBreakIteratorICU.cpp	2010-04-05 14:51:20.000000000 +0200
+++ webkit-1.2.0.fixed/WebCore/platform/text/TextBreakIteratorICU.cpp	2010-04-08 15:38:04.705203914 +0200
@@ -24,7 +24,6 @@
 
 #include "PlatformString.h"
 #include "TextBreakIteratorInternalICU.h"
-
 #include <unicode/ubrk.h>
 #include <wtf/Assertions.h>
 
@@ -38,7 +37,7 @@
 
     if (!createdIterator) {
         UErrorCode openStatus = U_ZERO_ERROR;
-        iterator = static_cast<TextBreakIterator*>(ubrk_open(type, currentTextBreakLocaleID(), 0, 0, &openStatus));
+        iterator = reinterpret_cast<TextBreakIterator*>(ubrk_open(type, currentTextBreakLocaleID(), 0, 0, &openStatus));
         createdIterator = true;
         ASSERT_WITH_MESSAGE(U_SUCCESS(openStatus), "ICU could not open a break iterator: %s (%d)", u_errorName(openStatus), openStatus);
     }
@@ -46,7 +45,7 @@
         return 0;
 
     UErrorCode setTextStatus = U_ZERO_ERROR;
-    ubrk_setText(iterator, string, length, &setTextStatus);
+    ubrk_setText(reinterpret_cast<UBreakIterator*>(iterator), string, length, &setTextStatus);
     if (U_FAILURE(setTextStatus))
         return 0;
 
@@ -85,44 +84,44 @@
         staticSentenceBreakIterator, UBRK_SENTENCE, string, length);
 }
 
-int textBreakFirst(TextBreakIterator* bi)
+int textBreakFirst(TextBreakIterator* iterator)
 {
-    return ubrk_first(bi);
+    return ubrk_first(reinterpret_cast<UBreakIterator*>(iterator));
 }
 
-int textBreakLast(TextBreakIterator* bi)
+int textBreakLast(TextBreakIterator* iterator)
 {
-    return ubrk_last(bi);
+    return ubrk_last(reinterpret_cast<UBreakIterator*>(iterator));
 }
 
-int textBreakNext(TextBreakIterator* bi)
+int textBreakNext(TextBreakIterator* iterator)
 {
-    return ubrk_next(bi);
+    return ubrk_next(reinterpret_cast<UBreakIterator*>(iterator));
 }
 
-int textBreakPrevious(TextBreakIterator* bi)
+int textBreakPrevious(TextBreakIterator* iterator)
 {
-    return ubrk_previous(bi);
+    return ubrk_previous(reinterpret_cast<UBreakIterator*>(iterator));
 }
 
-int textBreakPreceding(TextBreakIterator* bi, int pos)
+int textBreakPreceding(TextBreakIterator* iterator, int pos)
 {
-    return ubrk_preceding(bi, pos);
+    return ubrk_preceding(reinterpret_cast<UBreakIterator*>(iterator), pos);
 }
 
-int textBreakFollowing(TextBreakIterator* bi, int pos)
+int textBreakFollowing(TextBreakIterator* iterator, int pos)
 {
-    return ubrk_following(bi, pos);
+    return ubrk_following(reinterpret_cast<UBreakIterator*>(iterator), pos);
 }
 
-int textBreakCurrent(TextBreakIterator* bi)
+int textBreakCurrent(TextBreakIterator* iterator)
 {
-    return ubrk_current(bi);
+    return ubrk_current(reinterpret_cast<UBreakIterator*>(iterator));
 }
 
-bool isTextBreak(TextBreakIterator* bi, int pos)
+bool isTextBreak(TextBreakIterator* iterator, int position)
 {
-    return ubrk_isBoundary(bi, pos);
+    return ubrk_isBoundary(reinterpret_cast<UBreakIterator*>(iterator), position);
 }
 
 #ifndef BUILDING_ON_TIGER
@@ -136,7 +135,7 @@
         UParseError parseStatus;
         UErrorCode openStatus = U_ZERO_ERROR;
         String rules(breakRules);
-        iterator = static_cast<TextBreakIterator*>(ubrk_openRules(rules.characters(), rules.length(), 0, 0, &parseStatus, &openStatus));
+        iterator = reinterpret_cast<TextBreakIterator*>(ubrk_openRules(rules.characters(), rules.length(), 0, 0, &parseStatus, &openStatus));
         createdIterator = true;
         ASSERT_WITH_MESSAGE(U_SUCCESS(openStatus), "ICU could not open a break iterator: %s (%d)", u_errorName(openStatus), openStatus);
     }
@@ -144,7 +143,7 @@
         return 0;
 
     UErrorCode setTextStatus = U_ZERO_ERROR;
-    ubrk_setText(iterator, string, length, &setTextStatus);
+    ubrk_setText(reinterpret_cast<UBreakIterator*>(iterator), string, length, &setTextStatus);
     if (U_FAILURE(setTextStatus))
         return 0;
 
