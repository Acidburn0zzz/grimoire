From 3acb2bea8282214f002af2c45699eeee1cdc8db5 Mon Sep 17 00:00:00 2001
From: Florian Franzmann <siflfran@hawo.stw.uni-erlangen.de>
Date: Sun, 6 Apr 2014 14:31:38 +0000
Subject: [PATCH] switch build system to cmake

- reorganize directory layout. source files go to src,
headers to include
- remove unnecessary macros from all .c files
- use the <> form of #include for the ladspa header
- remove redundant definition of f_round from ladspa-util.h
- remove redundant config.h header file; this seems to have been
an auto-generated header at some point copied from some other
project. It isn't used anywhere in this project.
- adapt the README to the new build system
- add cppcheck target
---
 CMakeLists.txt               |  21 +++
 Makefile                     |  47 ------
 README                       |   7 +-
 RTallpass1.c                 | 236 ------------------------------
 RTallpass2.c                 | 255 ---------------------------------
 RThighpass.c                 | 251 --------------------------------
 RThighshelf.c                | 269 -----------------------------------
 RTlowpass.c                  | 251 --------------------------------
 RTlowshelf.c                 | 269 -----------------------------------
 RTlr4hipass.c                | 239 -------------------------------
 RTlr4lowpass.c               | 239 -------------------------------
 RTparaeq.c                   | 269 -----------------------------------
 build/.keep                  |   0
 cmake/compilerwarnings.cmake |  37 +++++
 cmake/cppcheck.cmake         |  12 ++
 include/biquad.h             | 331 +++++++++++++++++++++++++++++++++++++++++++
 include/ladspa-util.h        | 211 +++++++++++++++++++++++++++
 src/CMakeLists.txt           |  26 ++++
 src/RTallpass1.c             | 231 ++++++++++++++++++++++++++++++
 src/RTallpass2.c             | 250 ++++++++++++++++++++++++++++++++
 src/RThighpass.c             | 246 ++++++++++++++++++++++++++++++++
 src/RThighshelf.c            | 264 ++++++++++++++++++++++++++++++++++
 src/RTlowpass.c              | 246 ++++++++++++++++++++++++++++++++
 src/RTlowshelf.c             | 264 ++++++++++++++++++++++++++++++++++
 src/RTlr4hipass.c            | 234 ++++++++++++++++++++++++++++++
 src/RTlr4lowpass.c           | 234 ++++++++++++++++++++++++++++++
 src/RTparaeq.c               | 264 ++++++++++++++++++++++++++++++++++
 util/biquad.h                | 331 -------------------------------------------
 util/config.h                |  99 -------------
 util/ladspa-util.h           | 230 ------------------------------
 30 files changed, 2877 insertions(+), 2986 deletions(-)
 create mode 100644 CMakeLists.txt
 delete mode 100644 Makefile
 delete mode 100644 RTallpass1.c
 delete mode 100644 RTallpass2.c
 delete mode 100644 RThighpass.c
 delete mode 100644 RThighshelf.c
 delete mode 100644 RTlowpass.c
 delete mode 100644 RTlowshelf.c
 delete mode 100644 RTlr4hipass.c
 delete mode 100644 RTlr4lowpass.c
 delete mode 100644 RTparaeq.c
 create mode 100644 build/.keep
 create mode 100644 cmake/compilerwarnings.cmake
 create mode 100644 cmake/cppcheck.cmake
 create mode 100644 include/biquad.h
 create mode 100644 include/ladspa-util.h
 create mode 100644 src/CMakeLists.txt
 create mode 100644 src/RTallpass1.c
 create mode 100644 src/RTallpass2.c
 create mode 100644 src/RThighpass.c
 create mode 100644 src/RThighshelf.c
 create mode 100644 src/RTlowpass.c
 create mode 100644 src/RTlowshelf.c
 create mode 100644 src/RTlr4hipass.c
 create mode 100644 src/RTlr4lowpass.c
 create mode 100644 src/RTparaeq.c
 delete mode 100644 util/biquad.h
 delete mode 100644 util/config.h
 delete mode 100644 util/ladspa-util.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..566ef09
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,21 @@
+cmake_minimum_required(VERSION 2.8)
+Project(rt-plugins)
+
+set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
+
+include(compilerwarnings)
+include(cppcheck)
+
+set(COMMONFLAGS "-pipe")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${COMMONFLAGS}")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c11")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
+
+add_definitions("-D_BSD_SOURCE -D_XOPEN_SOURCE=600")
+
+set(CMAKE_SHARED_MODULE_PREFIX "")
+
+add_subdirectory(src)
+
+file(GLOB HEADERS "${PROJECT_SOURCE_DIR}/include/*.h")
diff --git a/Makefile b/Makefile
deleted file mode 100644
index 4394311..0000000
--- a/Makefile
+++ /dev/null
@@ -1,47 +0,0 @@
-INSTALL_PLUGINS_DIR	?=	/usr/local/lib/ladspa/
-
-# rt 31.5.2013: got rid of sse2 stuff so we can build for ARM
-CPPFLAGS += -D_BSD_SOURCE -DPIC -D_XOPEN_SOURCE=600 -I.
-
-CFLAGS += -Ofast -fomit-frame-pointer -fstrength-reduce -funroll-loops -fPIC -std=c11
-
-CFLAGS += -Wall -Wextra -Werror -pedantic
-CFLAGS += -Wcast-align -Wfloat-equal -Wformat-nonliteral  -Wformat-security
-CFLAGS += -Winit-self -Wmissing-include-dirs
-CFLAGS += -Wno-suggest-attribute=noreturn -Wno-write-strings -Wpointer-arith -Wundef -Wpacked
-CFLAGS += -Wredundant-decls
-CFLAGS += -Wunreachable-code  -Wno-unused-parameter -Wconversion -Wshadow
-CFLAGS += -Wstrict-prototypes -Wbad-function-cast -Wold-style-definition -Wmissing-prototypes -Wmissing-declarations -Wnested-externs
-
-LDFLAGS += -shared
-
-PLUGINS		=	RTallpass1.so \
-				RTallpass2.so \
-				RTlowpass.so \
-				RThighpass.so \
-				RThighshelf.so \
-				RTlowshelf.so \
-				RTlr4hipass.so \
-				RTlr4lowpass.so \
-				RTparaeq.so \
-
-all: $(PLUGINS)
-
-%.o: %.c
-	@echo -e "(CC) $@"
-	@$(CC) $(CFLAGS) $(CPPFLAGS) -c -o $@ $<
-
-%.so: %.o
-	@echo -e "(LD) $@"
-	@$(LD) $(LDFLAGS) -o $@ $<
-
-install: all
-	mkdir -p $(INSTALL_PLUGINS_DIR)
-	install -m644 $(PLUGINS) $(INSTALL_PLUGINS_DIR)
-
-clean:
-	-rm -f `find . -name "*.so"`
-	-rm -f `find . -name "*.o"`
-	-rm -f `find . -name "*~"`
-
-.PHONY: install all clean
diff --git a/README b/README
index 98c6892..24ce89a 100644
--- a/README
+++ b/README
@@ -2,11 +2,14 @@ Compiling
 ~~~~~~~~~
 
 Install with
+   cd build
+   cmake ..
    make
    sudo make install
 
 By default this installs plugins in /usr/local/lib/ladspa.  If
-you want them to go somewhere else, edit the Makefile.
+you want them to go somewhere else, configure cmake accordingly
+by running 'ccmake .'
 
 You should set the environment variable LADSPA_PATH to contain the
 path to the plugins, so they can be found.  Something like this:
@@ -26,6 +29,8 @@ I know, these instruction sets are only implemented on Intel and Athlon
 processors.  Compiling for other architectures will probably require some
 changes to the source code.
 
+You can set USE_SSE2 to off using ccmake if you do not want to use SSE2.
+
 
 Bug reports
 ~~~~~~~~~~~
diff --git a/RTallpass1.c b/RTallpass1.c
deleted file mode 100644
index 4ea528b..0000000
--- a/RTallpass1.c
+++ /dev/null
@@ -1,236 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define ALLPASS1_FC                    0
-#define ALLPASS1_INPUT                 1
-#define ALLPASS1_OUTPUT                2
-
-static LADSPA_Descriptor *allPassDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *fc;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	bilin *     filter;
-	float        fs;
-} AllPass;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return allPassDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateAllPass(LADSPA_Handle instance) {
-	AllPass *plugin_data = (AllPass *)instance;
-	bilin *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	bilin_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupAllPass(LADSPA_Handle instance) {
-	AllPass *plugin_data = (AllPass *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortAllPass(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	AllPass *plugin;
-
-	plugin = (AllPass *)instance;
-	switch (port) {
-	case ALLPASS1_FC:
-		plugin->fc = data;
-		break;
-	case ALLPASS1_INPUT:
-		plugin->input = data;
-		break;
-	case ALLPASS1_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateAllPass(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	AllPass *plugin_data = (AllPass *)malloc(sizeof(AllPass));
-	bilin *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(bilin));
-	bilin_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runAllPass(LADSPA_Handle instance, unsigned long sample_count) {
-	AllPass *plugin_data = (AllPass *)instance;
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-
-	bilin * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	ap1_set_params(filter, fc, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-		// RT 2.9.2013: replace biquad_run with ap1_run to cut floating-
-		// point multiplications from 3 to 1:
-	  buffer_write(output[pos], (LADSPA_Data) ap1_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	allPassDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (allPassDescriptor) {
-		allPassDescriptor->UniqueID = 9010;
-		allPassDescriptor->Label = "RTallpass1";
-		allPassDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		allPassDescriptor->Name =
-		 D_("RT First Order Allpass");
-		allPassDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		allPassDescriptor->Copyright =
-		 "GPL";
-		allPassDescriptor->PortCount = 3;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(3,
-		 sizeof(LADSPA_PortDescriptor));
-		allPassDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(3,
-		 sizeof(LADSPA_PortRangeHint));
-		allPassDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(3, sizeof(char*));
-		allPassDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[ALLPASS1_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[ALLPASS1_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[ALLPASS1_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[ALLPASS1_FC].LowerBound = 0.0;
-		port_range_hints[ALLPASS1_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Input */
-		port_descriptors[ALLPASS1_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[ALLPASS1_INPUT] =
-		 D_("Input");
-		port_range_hints[ALLPASS1_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[ALLPASS1_INPUT].LowerBound = -1.0;
-		port_range_hints[ALLPASS1_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[ALLPASS1_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[ALLPASS1_OUTPUT] =
-		 D_("Output");
-		port_range_hints[ALLPASS1_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[ALLPASS1_OUTPUT].LowerBound = -1.0;
-		port_range_hints[ALLPASS1_OUTPUT].UpperBound = +1.0;
-
-		allPassDescriptor->activate = activateAllPass;
-		allPassDescriptor->cleanup = cleanupAllPass;
-		allPassDescriptor->connect_port = connectPortAllPass;
-		allPassDescriptor->deactivate = NULL;
-		allPassDescriptor->instantiate = instantiateAllPass;
-		allPassDescriptor->run = runAllPass;
-		allPassDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (allPassDescriptor) {
-		free((LADSPA_PortDescriptor *)allPassDescriptor->PortDescriptors);
-		free((char **)allPassDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)allPassDescriptor->PortRangeHints);
-		free(allPassDescriptor);
-	}
-
-}
-
diff --git a/RTallpass2.c b/RTallpass2.c
deleted file mode 100644
index a0bac58..0000000
--- a/RTallpass2.c
+++ /dev/null
@@ -1,255 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define ALLPASS_FC                  0
-#define ALLPASS_Q                  1
-#define ALLPASS_INPUT               2
-#define ALLPASS_OUTPUT              3
-
-static LADSPA_Descriptor *allPassDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *gain;
-	LADSPA_Data *fc;
-	LADSPA_Data *Q;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filter;
-	float        fs;
-} AllPass;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return allPassDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateAllPass(LADSPA_Handle instance) {
-	AllPass *plugin_data = (AllPass *)instance;
-	biquad *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	biquad_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupAllPass(LADSPA_Handle instance) {
-	AllPass *plugin_data = (AllPass *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortAllPass(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	AllPass *plugin;
-
-	plugin = (AllPass *)instance;
-	switch (port) {
-	case ALLPASS_FC:
-		plugin->fc = data;
-		break;
-	case ALLPASS_Q:
-		plugin->Q = data;
-		break;
-	case ALLPASS_INPUT:
-		plugin->input = data;
-		break;
-	case ALLPASS_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateAllPass(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	AllPass *plugin_data = (AllPass *)malloc(sizeof(AllPass));
-	biquad *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(biquad));
-	biquad_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runAllPass(LADSPA_Handle instance, unsigned long sample_count) {
-	AllPass *plugin_data = (AllPass *)instance;
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Bandwidth (octaves) (float value) */
-	const LADSPA_Data Q = *(plugin_data->Q);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-
-	biquad * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	ap_set_params(filter, fc, Q, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-		// RT 2.9.2013: replace biquad_run with ap2_run to cut floating-
-		// point multiplications from 5 to 2:
-	  buffer_write(output[pos], (LADSPA_Data) ap2_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	allPassDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (allPassDescriptor) {
-		allPassDescriptor->UniqueID = 9005;
-		allPassDescriptor->Label = "RTallpass2";
-		allPassDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		allPassDescriptor->Name =
-		 D_("RT Biquad Allpass");
-		allPassDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		allPassDescriptor->Copyright =
-		 "GPL";
-		allPassDescriptor->PortCount = 4;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(4,
-		 sizeof(LADSPA_PortDescriptor));
-		allPassDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(4,
-		 sizeof(LADSPA_PortRangeHint));
-		allPassDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(4, sizeof(char*));
-		allPassDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[ALLPASS_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[ALLPASS_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[ALLPASS_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[ALLPASS_FC].LowerBound = 0;
-		port_range_hints[ALLPASS_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Bandwidth (octaves) */
-		port_descriptors[ALLPASS_Q] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[ALLPASS_Q] =
-		 D_("Q");
-		port_range_hints[ALLPASS_Q].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[ALLPASS_Q].LowerBound = 0;
-		port_range_hints[ALLPASS_Q].UpperBound = 10;
-
-		/* Parameters for Input */
-		port_descriptors[ALLPASS_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[ALLPASS_INPUT] =
-		 D_("Input");
-		port_range_hints[ALLPASS_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[ALLPASS_INPUT].LowerBound = -1.0;
-		port_range_hints[ALLPASS_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[ALLPASS_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[ALLPASS_OUTPUT] =
-		 D_("Output");
-		port_range_hints[ALLPASS_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[ALLPASS_OUTPUT].LowerBound = -1.0;
-		port_range_hints[ALLPASS_OUTPUT].UpperBound = +1.0;
-
-		allPassDescriptor->activate = activateAllPass;
-		allPassDescriptor->cleanup = cleanupAllPass;
-		allPassDescriptor->connect_port = connectPortAllPass;
-		allPassDescriptor->deactivate = NULL;
-		allPassDescriptor->instantiate = instantiateAllPass;
-		allPassDescriptor->run = runAllPass;
-		allPassDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (allPassDescriptor) {
-		free((LADSPA_PortDescriptor *)allPassDescriptor->PortDescriptors);
-		free((char **)allPassDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)allPassDescriptor->PortRangeHints);
-		free(allPassDescriptor);
-	}
-
-}
-
diff --git a/RThighpass.c b/RThighpass.c
deleted file mode 100644
index 3376ad9..0000000
--- a/RThighpass.c
+++ /dev/null
@@ -1,251 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define HIGHPASS_FC                  0
-#define HIGHPASS_Q                   1
-#define HIGHPASS_INPUT               2
-#define HIGHPASS_OUTPUT              3
-
-static LADSPA_Descriptor *highPassDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *fc;
-	LADSPA_Data *Q;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filter;
-	float        fs;
-} HighPass;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return highPassDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateHighPass(LADSPA_Handle instance) {
-	HighPass *plugin_data = (HighPass *)instance;
-	biquad *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	biquad_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupHighPass(LADSPA_Handle instance) {
-	HighPass *plugin_data = (HighPass *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortHighPass(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	HighPass *plugin;
-
-	plugin = (HighPass *)instance;
-	switch (port) {
-	case HIGHPASS_FC:
-		plugin->fc = data;
-		break;
-	case HIGHPASS_Q:
-		plugin->Q = data;
-		break;
-	case HIGHPASS_INPUT:
-		plugin->input = data;
-		break;
-	case HIGHPASS_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateHighPass(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	HighPass *plugin_data = (HighPass *)malloc(sizeof(HighPass));
-	biquad *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(biquad));
-	biquad_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runHighPass(LADSPA_Handle instance, unsigned long sample_count) {
-	HighPass *plugin_data = (HighPass *)instance;
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Bandwidth (octaves) (float value) */
-	const LADSPA_Data Q = *(plugin_data->Q);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	hp_set_params(filter, fc, Q, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	highPassDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (highPassDescriptor) {
-		highPassDescriptor->UniqueID = 9007;
-		highPassDescriptor->Label = "RThighpass";
-		highPassDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		highPassDescriptor->Name =
-		 D_("RT 2nd-order highpass");
-		highPassDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		highPassDescriptor->Copyright =
-		 "GPL";
-		highPassDescriptor->PortCount = 4;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(4,
-		 sizeof(LADSPA_PortDescriptor));
-		highPassDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(4,
-		 sizeof(LADSPA_PortRangeHint));
-		highPassDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(4, sizeof(char*));
-		highPassDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[HIGHPASS_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[HIGHPASS_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[HIGHPASS_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[HIGHPASS_FC].LowerBound = 0;
-		port_range_hints[HIGHPASS_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Q */
-		port_descriptors[HIGHPASS_Q] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[HIGHPASS_Q] =
-		 D_("Q");
-		port_range_hints[HIGHPASS_Q].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[HIGHPASS_Q].LowerBound = 0;
-		port_range_hints[HIGHPASS_Q].UpperBound = 5;
-
-		/* Parameters for Input */
-		port_descriptors[HIGHPASS_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[HIGHPASS_INPUT] =
-		 D_("Input");
-		port_range_hints[HIGHPASS_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[HIGHPASS_INPUT].LowerBound = -1.0;
-		port_range_hints[HIGHPASS_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[HIGHPASS_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[HIGHPASS_OUTPUT] =
-		 D_("Output");
-		port_range_hints[HIGHPASS_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[HIGHPASS_OUTPUT].LowerBound = -1.0;
-		port_range_hints[HIGHPASS_OUTPUT].UpperBound = +1.0;
-
-		highPassDescriptor->activate = activateHighPass;
-		highPassDescriptor->cleanup = cleanupHighPass;
-		highPassDescriptor->connect_port = connectPortHighPass;
-		highPassDescriptor->deactivate = NULL;
-		highPassDescriptor->instantiate = instantiateHighPass;
-		highPassDescriptor->run = runHighPass;
-		highPassDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (highPassDescriptor) {
-		free((LADSPA_PortDescriptor *)highPassDescriptor->PortDescriptors);
-		free((char **)highPassDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)highPassDescriptor->PortRangeHints);
-		free(highPassDescriptor);
-	}
-
-}
-
diff --git a/RThighshelf.c b/RThighshelf.c
deleted file mode 100644
index 9d02d45..0000000
--- a/RThighshelf.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define HIGHSHELF_GAIN                0
-#define HIGHSHELF_FC                  1
-#define HIGHSHELF_Q               2
-#define HIGHSHELF_INPUT               3
-#define HIGHSHELF_OUTPUT              4
-
-static LADSPA_Descriptor *highShelfDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *gain;
-	LADSPA_Data *fc;
-	LADSPA_Data *Q;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filter;
-	float        fs;
-} HighShelf;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return highShelfDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateHighShelf(LADSPA_Handle instance) {
-	HighShelf *plugin_data = (HighShelf *)instance;
-	biquad *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	biquad_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupHighShelf(LADSPA_Handle instance) {
-	HighShelf *plugin_data = (HighShelf *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortHighShelf(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	HighShelf *plugin;
-
-	plugin = (HighShelf *)instance;
-	switch (port) {
-	case HIGHSHELF_GAIN:
-		plugin->gain = data;
-		break;
-	case HIGHSHELF_FC:
-		plugin->fc = data;
-		break;
-	case HIGHSHELF_Q:
-		plugin->Q = data;
-		break;
-	case HIGHSHELF_INPUT:
-		plugin->input = data;
-		break;
-	case HIGHSHELF_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateHighShelf(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	HighShelf *plugin_data = (HighShelf *)malloc(sizeof(HighShelf));
-	biquad *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(biquad));
-	biquad_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runHighShelf(LADSPA_Handle instance, unsigned long sample_count) {
-	HighShelf *plugin_data = (HighShelf *)instance;
-
-	/* Gain (dB) (float value) */
-	const LADSPA_Data gain = *(plugin_data->gain);
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Bandwidth (octaves) (float value) */
-	const LADSPA_Data Q = *(plugin_data->Q);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	hs_set_params(filter, fc, gain, Q, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	highShelfDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (highShelfDescriptor) {
-		highShelfDescriptor->UniqueID = 9003;
-		highShelfDescriptor->Label = "RThighshelf";
-		highShelfDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		highShelfDescriptor->Name =
-		 D_("RT High Shelf");
-		highShelfDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		highShelfDescriptor->Copyright =
-		 "GPL";
-		highShelfDescriptor->PortCount = 5;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(5,
-		 sizeof(LADSPA_PortDescriptor));
-		highShelfDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(5,
-		 sizeof(LADSPA_PortRangeHint));
-		highShelfDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(5, sizeof(char*));
-		highShelfDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Gain (dB) */
-		port_descriptors[HIGHSHELF_GAIN] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[HIGHSHELF_GAIN] =
-		 D_("Gain (dB)");
-		port_range_hints[HIGHSHELF_GAIN].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_0;
-		port_range_hints[HIGHSHELF_GAIN].LowerBound = -70;
-		port_range_hints[HIGHSHELF_GAIN].UpperBound = +30;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[HIGHSHELF_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[HIGHSHELF_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[HIGHSHELF_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[HIGHSHELF_FC].LowerBound = 0;
-		port_range_hints[HIGHSHELF_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Quality Factor */
-		port_descriptors[HIGHSHELF_Q] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[HIGHSHELF_Q] =
-		 D_("Q");
-		port_range_hints[HIGHSHELF_Q].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[HIGHSHELF_Q].LowerBound = 0;
-		port_range_hints[HIGHSHELF_Q].UpperBound = 5;
-
-		/* Parameters for Input */
-		port_descriptors[HIGHSHELF_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[HIGHSHELF_INPUT] =
-		 D_("Input");
-		port_range_hints[HIGHSHELF_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[HIGHSHELF_INPUT].LowerBound = -1.0;
-		port_range_hints[HIGHSHELF_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[HIGHSHELF_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[HIGHSHELF_OUTPUT] =
-		 D_("Output");
-		port_range_hints[HIGHSHELF_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[HIGHSHELF_OUTPUT].LowerBound = -1.0;
-		port_range_hints[HIGHSHELF_OUTPUT].UpperBound = +1.0;
-
-		highShelfDescriptor->activate = activateHighShelf;
-		highShelfDescriptor->cleanup = cleanupHighShelf;
-		highShelfDescriptor->connect_port = connectPortHighShelf;
-		highShelfDescriptor->deactivate = NULL;
-		highShelfDescriptor->instantiate = instantiateHighShelf;
-		highShelfDescriptor->run = runHighShelf;
-		highShelfDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (highShelfDescriptor) {
-		free((LADSPA_PortDescriptor *)highShelfDescriptor->PortDescriptors);
-		free((char **)highShelfDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)highShelfDescriptor->PortRangeHints);
-		free(highShelfDescriptor);
-	}
-
-}
-
diff --git a/RTlowpass.c b/RTlowpass.c
deleted file mode 100644
index 9ea377f..0000000
--- a/RTlowpass.c
+++ /dev/null
@@ -1,251 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define LOWPASS_FC                  0
-#define LOWPASS_Q                   1
-#define LOWPASS_INPUT               2
-#define LOWPASS_OUTPUT              3
-
-static LADSPA_Descriptor *lowPassDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *fc;
-	LADSPA_Data *Q;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filter;
-	float        fs;
-} LowPass;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return lowPassDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateLowPass(LADSPA_Handle instance) {
-	LowPass *plugin_data = (LowPass *)instance;
-	biquad *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	biquad_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupLowPass(LADSPA_Handle instance) {
-	LowPass *plugin_data = (LowPass *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortLowPass(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	LowPass *plugin;
-
-	plugin = (LowPass *)instance;
-	switch (port) {
-	case LOWPASS_FC:
-		plugin->fc = data;
-		break;
-	case LOWPASS_Q:
-		plugin->Q = data;
-		break;
-	case LOWPASS_INPUT:
-		plugin->input = data;
-		break;
-	case LOWPASS_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateLowPass(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	LowPass *plugin_data = (LowPass *)malloc(sizeof(LowPass));
-	biquad *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(biquad));
-	biquad_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runLowPass(LADSPA_Handle instance, unsigned long sample_count) {
-	LowPass *plugin_data = (LowPass *)instance;
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Bandwidth (octaves) (float value) */
-	const LADSPA_Data Q = *(plugin_data->Q);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	lp_set_params(filter, fc, Q, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	lowPassDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (lowPassDescriptor) {
-		lowPassDescriptor->UniqueID = 9006;
-		lowPassDescriptor->Label = "RTlowpass";
-		lowPassDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		lowPassDescriptor->Name =
-		 D_("RT 2nd-order lowpass");
-		lowPassDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		lowPassDescriptor->Copyright =
-		 "GPL";
-		lowPassDescriptor->PortCount = 4;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(4,
-		 sizeof(LADSPA_PortDescriptor));
-		lowPassDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(4,
-		 sizeof(LADSPA_PortRangeHint));
-		lowPassDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(4, sizeof(char*));
-		lowPassDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[LOWPASS_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LOWPASS_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[LOWPASS_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[LOWPASS_FC].LowerBound = 0;
-		port_range_hints[LOWPASS_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Q */
-		port_descriptors[LOWPASS_Q] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LOWPASS_Q] =
-		 D_("Q");
-		port_range_hints[LOWPASS_Q].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[LOWPASS_Q].LowerBound = 0;
-		port_range_hints[LOWPASS_Q].UpperBound = 5;
-
-		/* Parameters for Input */
-		port_descriptors[LOWPASS_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[LOWPASS_INPUT] =
-		 D_("Input");
-		port_range_hints[LOWPASS_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LOWPASS_INPUT].LowerBound = -1.0;
-		port_range_hints[LOWPASS_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[LOWPASS_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[LOWPASS_OUTPUT] =
-		 D_("Output");
-		port_range_hints[LOWPASS_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LOWPASS_OUTPUT].LowerBound = -1.0;
-		port_range_hints[LOWPASS_OUTPUT].UpperBound = +1.0;
-
-		lowPassDescriptor->activate = activateLowPass;
-		lowPassDescriptor->cleanup = cleanupLowPass;
-		lowPassDescriptor->connect_port = connectPortLowPass;
-		lowPassDescriptor->deactivate = NULL;
-		lowPassDescriptor->instantiate = instantiateLowPass;
-		lowPassDescriptor->run = runLowPass;
-		lowPassDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (lowPassDescriptor) {
-		free((LADSPA_PortDescriptor *)lowPassDescriptor->PortDescriptors);
-		free((char **)lowPassDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)lowPassDescriptor->PortRangeHints);
-		free(lowPassDescriptor);
-	}
-
-}
-
diff --git a/RTlowshelf.c b/RTlowshelf.c
deleted file mode 100644
index 12a2c7c..0000000
--- a/RTlowshelf.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define LOWSHELF_GAIN                0
-#define LOWSHELF_FC                  1
-#define LOWSHELF_Q                   2
-#define LOWSHELF_INPUT               3
-#define LOWSHELF_OUTPUT              4
-
-static LADSPA_Descriptor *lowShelfDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *gain;
-	LADSPA_Data *fc;
-	LADSPA_Data *Q;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filter;
-	float        fs;
-} LowShelf;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return lowShelfDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateLowShelf(LADSPA_Handle instance) {
-	LowShelf *plugin_data = (LowShelf *)instance;
-	biquad *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	biquad_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupLowShelf(LADSPA_Handle instance) {
-	LowShelf *plugin_data = (LowShelf *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortLowShelf(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	LowShelf *plugin;
-
-	plugin = (LowShelf *)instance;
-	switch (port) {
-	case LOWSHELF_GAIN:
-		plugin->gain = data;
-		break;
-	case LOWSHELF_FC:
-		plugin->fc = data;
-		break;
-	case LOWSHELF_Q:
-		plugin->Q = data;
-		break;
-	case LOWSHELF_INPUT:
-		plugin->input = data;
-		break;
-	case LOWSHELF_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateLowShelf(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	LowShelf *plugin_data = (LowShelf *)malloc(sizeof(LowShelf));
-	biquad *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(biquad));
-	biquad_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runLowShelf(LADSPA_Handle instance, unsigned long sample_count) {
-	LowShelf *plugin_data = (LowShelf *)instance;
-
-	/* Gain (dB) (float value) */
-	const LADSPA_Data gain = *(plugin_data->gain);
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Bandwidth (octaves) (float value) */
-	const LADSPA_Data Q = *(plugin_data->Q);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	ls_set_params(filter, fc, gain, Q, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	lowShelfDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (lowShelfDescriptor) {
-		lowShelfDescriptor->UniqueID = 9002;
-		lowShelfDescriptor->Label = "RTlowshelf";
-		lowShelfDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		lowShelfDescriptor->Name =
-		 D_("RT Low Shelf");
-		lowShelfDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		lowShelfDescriptor->Copyright =
-		 "GPL";
-		lowShelfDescriptor->PortCount = 5;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(5,
-		 sizeof(LADSPA_PortDescriptor));
-		lowShelfDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(5,
-		 sizeof(LADSPA_PortRangeHint));
-		lowShelfDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(5, sizeof(char*));
-		lowShelfDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Gain (dB) */
-		port_descriptors[LOWSHELF_GAIN] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LOWSHELF_GAIN] =
-		 D_("Gain (dB)");
-		port_range_hints[LOWSHELF_GAIN].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_0;
-		port_range_hints[LOWSHELF_GAIN].LowerBound = -70;
-		port_range_hints[LOWSHELF_GAIN].UpperBound = +30;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[LOWSHELF_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LOWSHELF_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[LOWSHELF_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[LOWSHELF_FC].LowerBound = 0;
-		port_range_hints[LOWSHELF_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Quality Factor */
-		port_descriptors[LOWSHELF_Q] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LOWSHELF_Q] =
-		 D_("Q");
-		port_range_hints[LOWSHELF_Q].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[LOWSHELF_Q].LowerBound = 0;
-		port_range_hints[LOWSHELF_Q].UpperBound = 5;
-
-		/* Parameters for Input */
-		port_descriptors[LOWSHELF_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[LOWSHELF_INPUT] =
-		 D_("Input");
-		port_range_hints[LOWSHELF_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LOWSHELF_INPUT].LowerBound = -1.0;
-		port_range_hints[LOWSHELF_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[LOWSHELF_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[LOWSHELF_OUTPUT] =
-		 D_("Output");
-		port_range_hints[LOWSHELF_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LOWSHELF_OUTPUT].LowerBound = -1.0;
-		port_range_hints[LOWSHELF_OUTPUT].UpperBound = +1.0;
-
-		lowShelfDescriptor->activate = activateLowShelf;
-		lowShelfDescriptor->cleanup = cleanupLowShelf;
-		lowShelfDescriptor->connect_port = connectPortLowShelf;
-		lowShelfDescriptor->deactivate = NULL;
-		lowShelfDescriptor->instantiate = instantiateLowShelf;
-		lowShelfDescriptor->run = runLowShelf;
-		lowShelfDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (lowShelfDescriptor) {
-		free((LADSPA_PortDescriptor *)lowShelfDescriptor->PortDescriptors);
-		free((char **)lowShelfDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)lowShelfDescriptor->PortRangeHints);
-		free(lowShelfDescriptor);
-	}
-
-}
-
diff --git a/RTlr4hipass.c b/RTlr4hipass.c
deleted file mode 100644
index 15d6c49..0000000
--- a/RTlr4hipass.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define LR4HIGHPASS_FC                  0
-#define LR4HIGHPASS_INPUT               1
-#define LR4HIGHPASS_OUTPUT              2
-
-static LADSPA_Descriptor *lr4highPassDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *fc;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filters;
-	float        fs;
-} LR4HighPass;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return lr4highPassDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateLR4HighPass(LADSPA_Handle instance) {
-	LR4HighPass *plugin_data = (LR4HighPass *)instance;
-	biquad *filters = plugin_data->filters;
-	float fs = plugin_data->fs;
-	biquad_init(&filters[0]);
-	biquad_init(&filters[1]);
-	plugin_data->filters = filters;
-	plugin_data->fs = fs;
-}
-
-static void cleanupLR4HighPass(LADSPA_Handle instance) {
-	LR4HighPass *plugin_data = (LR4HighPass *)instance;
-	free(plugin_data->filters);
-	free(instance);
-}
-
-static void connectPortLR4HighPass(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	LR4HighPass *plugin;
-
-	plugin = (LR4HighPass *)instance;
-	switch (port) {
-	case LR4HIGHPASS_FC:
-		plugin->fc = data;
-		break;
-	case LR4HIGHPASS_INPUT:
-		plugin->input = data;
-		break;
-	case LR4HIGHPASS_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateLR4HighPass(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	LR4HighPass *plugin_data = (LR4HighPass *)malloc(sizeof(LR4HighPass));
-	biquad *filters = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-
-	filters = calloc(2, sizeof(biquad));
-	biquad_init(&filters[0]);
-	biquad_init(&filters[1]);
-
-	plugin_data->filters = filters;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runLR4HighPass(LADSPA_Handle instance, unsigned long sample_count) {
-	LR4HighPass *plugin_data = (LR4HighPass *)instance;
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filters = plugin_data->filters;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-  bq_t in;
-
-	hp_set_params(&filters[0], fc, 0.7071068, fs);
-	hp_set_params(&filters[1], fc, 0.7071068, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-    in = biquad_run(&filters[0], input[pos]);
-    in = biquad_run(&filters[1], in);
-    buffer_write(output[pos], (LADSPA_Data) in);
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	lr4highPassDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (lr4highPassDescriptor) {
-		lr4highPassDescriptor->UniqueID = 9021;
-		lr4highPassDescriptor->Label = "RTlr4hipass";
-		lr4highPassDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		lr4highPassDescriptor->Name =
-		 D_("RT LR4 highpass");
-		lr4highPassDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		lr4highPassDescriptor->Copyright =
-		 "GPL";
-		lr4highPassDescriptor->PortCount = 3;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(3,
-		 sizeof(LADSPA_PortDescriptor));
-		lr4highPassDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(3,
-		 sizeof(LADSPA_PortRangeHint));
-		lr4highPassDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(3, sizeof(char*));
-		lr4highPassDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[LR4HIGHPASS_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LR4HIGHPASS_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[LR4HIGHPASS_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[LR4HIGHPASS_FC].LowerBound = 0;
-		port_range_hints[LR4HIGHPASS_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Input */
-		port_descriptors[LR4HIGHPASS_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[LR4HIGHPASS_INPUT] =
-		 D_("Input");
-		port_range_hints[LR4HIGHPASS_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LR4HIGHPASS_INPUT].LowerBound = -1.0;
-		port_range_hints[LR4HIGHPASS_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[LR4HIGHPASS_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[LR4HIGHPASS_OUTPUT] =
-		 D_("Output");
-		port_range_hints[LR4HIGHPASS_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LR4HIGHPASS_OUTPUT].LowerBound = -1.0;
-		port_range_hints[LR4HIGHPASS_OUTPUT].UpperBound = +1.0;
-
-		lr4highPassDescriptor->activate = activateLR4HighPass;
-		lr4highPassDescriptor->cleanup = cleanupLR4HighPass;
-		lr4highPassDescriptor->connect_port = connectPortLR4HighPass;
-		lr4highPassDescriptor->deactivate = NULL;
-		lr4highPassDescriptor->instantiate = instantiateLR4HighPass;
-		lr4highPassDescriptor->run = runLR4HighPass;
-		lr4highPassDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (lr4highPassDescriptor) {
-		free((LADSPA_PortDescriptor *)lr4highPassDescriptor->PortDescriptors);
-		free((char **)lr4highPassDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)lr4highPassDescriptor->PortRangeHints);
-		free(lr4highPassDescriptor);
-	}
-
-}
-
diff --git a/RTlr4lowpass.c b/RTlr4lowpass.c
deleted file mode 100644
index 16ad5c9..0000000
--- a/RTlr4lowpass.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define LR4LOWPASS_FC                  0
-#define LR4LOWPASS_INPUT               1
-#define LR4LOWPASS_OUTPUT              2
-
-static LADSPA_Descriptor *lr4lowPassDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *fc;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filters;
-	float        fs;
-} LR4LowPass;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return lr4lowPassDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateLR4LowPass(LADSPA_Handle instance) {
-	LR4LowPass *plugin_data = (LR4LowPass *)instance;
-	biquad *filters = plugin_data->filters;
-	float fs = plugin_data->fs;
-	biquad_init(&filters[0]);
-	biquad_init(&filters[1]);
-	plugin_data->filters = filters;
-	plugin_data->fs = fs;
-}
-
-static void cleanupLR4LowPass(LADSPA_Handle instance) {
-	LR4LowPass *plugin_data = (LR4LowPass *)instance;
-	free(plugin_data->filters);
-	free(instance);
-}
-
-static void connectPortLR4LowPass(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	LR4LowPass *plugin;
-
-	plugin = (LR4LowPass *)instance;
-	switch (port) {
-	case LR4LOWPASS_FC:
-		plugin->fc = data;
-		break;
-	case LR4LOWPASS_INPUT:
-		plugin->input = data;
-		break;
-	case LR4LOWPASS_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateLR4LowPass(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	LR4LowPass *plugin_data = (LR4LowPass *)malloc(sizeof(LR4LowPass));
-	biquad *filters = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-
-	filters = calloc(2, sizeof(biquad));
-	biquad_init(&filters[0]);
-	biquad_init(&filters[1]);
-
-	plugin_data->filters = filters;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runLR4LowPass(LADSPA_Handle instance, unsigned long sample_count) {
-	LR4LowPass *plugin_data = (LR4LowPass *)instance;
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filters = plugin_data->filters;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-  bq_t in;
-
-	lp_set_params(&filters[0], fc, 0.7071068, fs);
-	lp_set_params(&filters[1], fc, 0.7071068, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-    in = biquad_run(&filters[0], input[pos]);
-    in = biquad_run(&filters[1], in);
-    buffer_write(output[pos], (LADSPA_Data) in);
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	lr4lowPassDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (lr4lowPassDescriptor) {
-		lr4lowPassDescriptor->UniqueID = 9020;
-		lr4lowPassDescriptor->Label = "RTlr4lowpass";
-		lr4lowPassDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		lr4lowPassDescriptor->Name =
-		 D_("RT LR4 lowpass");
-		lr4lowPassDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		lr4lowPassDescriptor->Copyright =
-		 "GPL";
-		lr4lowPassDescriptor->PortCount = 3;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(3,
-		 sizeof(LADSPA_PortDescriptor));
-		lr4lowPassDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(3,
-		 sizeof(LADSPA_PortRangeHint));
-		lr4lowPassDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(3, sizeof(char*));
-		lr4lowPassDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[LR4LOWPASS_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[LR4LOWPASS_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[LR4LOWPASS_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[LR4LOWPASS_FC].LowerBound = 0;
-		port_range_hints[LR4LOWPASS_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Input */
-		port_descriptors[LR4LOWPASS_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[LR4LOWPASS_INPUT] =
-		 D_("Input");
-		port_range_hints[LR4LOWPASS_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LR4LOWPASS_INPUT].LowerBound = -1.0;
-		port_range_hints[LR4LOWPASS_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[LR4LOWPASS_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[LR4LOWPASS_OUTPUT] =
-		 D_("Output");
-		port_range_hints[LR4LOWPASS_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[LR4LOWPASS_OUTPUT].LowerBound = -1.0;
-		port_range_hints[LR4LOWPASS_OUTPUT].UpperBound = +1.0;
-
-		lr4lowPassDescriptor->activate = activateLR4LowPass;
-		lr4lowPassDescriptor->cleanup = cleanupLR4LowPass;
-		lr4lowPassDescriptor->connect_port = connectPortLR4LowPass;
-		lr4lowPassDescriptor->deactivate = NULL;
-		lr4lowPassDescriptor->instantiate = instantiateLR4LowPass;
-		lr4lowPassDescriptor->run = runLR4LowPass;
-		lr4lowPassDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (lr4lowPassDescriptor) {
-		free((LADSPA_PortDescriptor *)lr4lowPassDescriptor->PortDescriptors);
-		free((char **)lr4lowPassDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)lr4lowPassDescriptor->PortRangeHints);
-		free(lr4lowPassDescriptor);
-	}
-
-}
-
diff --git a/RTparaeq.c b/RTparaeq.c
deleted file mode 100644
index 3e77a83..0000000
--- a/RTparaeq.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/* Copyright 2013 Richard Taylor
-
-  This program is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-  CREDITS:
-
-  Much of the code here was adapted from Steve Harris's swh-plugins
-  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
-  making your code available.
-
-  The guts of the code, in util/biquad.h, is an implementation
-  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
-  formulae for audio EQ biquad filter coefficients" found here:
-  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
-*/
-
-#include <stdlib.h>
-#include <string.h>
-
-#define         _ISOC9X_SOURCE  1
-#define         _ISOC99_SOURCE  1
-#define         __USE_ISOC99    1
-#define         __USE_ISOC9X    1
-
-#include <math.h>
-
-#include "ladspa.h"
-
-#include "util/biquad.h"
-
-#define SINGLEPARA_GAIN                0
-#define SINGLEPARA_FC                  1
-#define SINGLEPARA_Q                   2
-#define SINGLEPARA_INPUT               3
-#define SINGLEPARA_OUTPUT              4
-
-static LADSPA_Descriptor *singleParaDescriptor = NULL;
-
-typedef struct {
-	LADSPA_Data *gain;
-	LADSPA_Data *fc;
-	LADSPA_Data *Q;
-	LADSPA_Data *input;
-	LADSPA_Data *output;
-	biquad *     filter;
-	float        fs;
-} SinglePara;
-
-const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
-	switch (index) {
-	case 0:
-		return singleParaDescriptor;
-	default:
-		return NULL;
-	}
-}
-
-static void activateSinglePara(LADSPA_Handle instance) {
-	SinglePara *plugin_data = (SinglePara *)instance;
-	biquad *filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-	biquad_init(filter);
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-}
-
-static void cleanupSinglePara(LADSPA_Handle instance) {
-	SinglePara *plugin_data = (SinglePara *)instance;
-	free(plugin_data->filter);
-	free(instance);
-}
-
-static void connectPortSinglePara(
- LADSPA_Handle instance,
- unsigned long port,
- LADSPA_Data *data) {
-	SinglePara *plugin;
-
-	plugin = (SinglePara *)instance;
-	switch (port) {
-	case SINGLEPARA_GAIN:
-		plugin->gain = data;
-		break;
-	case SINGLEPARA_FC:
-		plugin->fc = data;
-		break;
-	case SINGLEPARA_Q:
-		plugin->Q = data;
-		break;
-	case SINGLEPARA_INPUT:
-		plugin->input = data;
-		break;
-	case SINGLEPARA_OUTPUT:
-		plugin->output = data;
-		break;
-	}
-}
-
-static LADSPA_Handle instantiateSinglePara(
- const LADSPA_Descriptor *descriptor,
- unsigned long s_rate) {
-	SinglePara *plugin_data = (SinglePara *)malloc(sizeof(SinglePara));
-	biquad *filter = NULL;
-	float fs;
-
-	fs = (float)s_rate;
-	filter = malloc(sizeof(biquad));
-	biquad_init(filter);
-
-	plugin_data->filter = filter;
-	plugin_data->fs = fs;
-
-	return (LADSPA_Handle)plugin_data;
-}
-
-#undef buffer_write
-#define buffer_write(b, v) (b = v)
-
-static void runSinglePara(LADSPA_Handle instance, unsigned long sample_count) {
-	SinglePara *plugin_data = (SinglePara *)instance;
-
-	/* Gain (dB) (float value) */
-	const LADSPA_Data gain = *(plugin_data->gain);
-
-	/* Frequency (Hz) (float value) */
-	const LADSPA_Data fc = *(plugin_data->fc);
-
-	/* Quality factor (float value) */
-	const LADSPA_Data Q = *(plugin_data->Q);
-
-	/* Input (array of floats of length sample_count) */
-	const LADSPA_Data * const input = plugin_data->input;
-
-	/* Output (array of floats of length sample_count) */
-	LADSPA_Data * const output = plugin_data->output;
-	biquad * filter = plugin_data->filter;
-	float fs = plugin_data->fs;
-
-	unsigned long pos;
-
-	eq_set_params(filter, fc, gain, Q, fs);
-
-	for (pos = 0; pos < sample_count; pos++) {
-	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
-	}
-
-}
-
-void _init(void);
-void _init(void) {
-	char **port_names;
-	LADSPA_PortDescriptor *port_descriptors;
-	LADSPA_PortRangeHint *port_range_hints;
-
-#define D_(s) (s)
-
-	singleParaDescriptor =
-	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
-
-	if (singleParaDescriptor) {
-		singleParaDescriptor->UniqueID = 9001;
-		singleParaDescriptor->Label = "RTparaeq";
-		singleParaDescriptor->Properties =
-		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
-		singleParaDescriptor->Name =
-		 D_("RT parametric eq");
-		singleParaDescriptor->Maker =
-		 "Richard Taylor <rtaylor@tru.ca>";
-		singleParaDescriptor->Copyright =
-		 "GPL";
-		singleParaDescriptor->PortCount = 5;
-
-		port_descriptors = (LADSPA_PortDescriptor *)calloc(5,
-		 sizeof(LADSPA_PortDescriptor));
-		singleParaDescriptor->PortDescriptors =
-		 (const LADSPA_PortDescriptor *)port_descriptors;
-
-		port_range_hints = (LADSPA_PortRangeHint *)calloc(5,
-		 sizeof(LADSPA_PortRangeHint));
-		singleParaDescriptor->PortRangeHints =
-		 (const LADSPA_PortRangeHint *)port_range_hints;
-
-		port_names = (char **)calloc(5, sizeof(char*));
-		singleParaDescriptor->PortNames =
-		 (const char **)port_names;
-
-		/* Parameters for Gain (dB) */
-		port_descriptors[SINGLEPARA_GAIN] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[SINGLEPARA_GAIN] =
-		 D_("Gain (dB)");
-		port_range_hints[SINGLEPARA_GAIN].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[SINGLEPARA_GAIN].LowerBound = -70;
-		port_range_hints[SINGLEPARA_GAIN].UpperBound = +30;
-
-		/* Parameters for Frequency (Hz) */
-		port_descriptors[SINGLEPARA_FC] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[SINGLEPARA_FC] =
-		 D_("Frequency (Hz)");
-		port_range_hints[SINGLEPARA_FC].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
-		port_range_hints[SINGLEPARA_FC].LowerBound = 0;
-		port_range_hints[SINGLEPARA_FC].UpperBound = (LADSPA_Data) 0.4;
-
-		/* Parameters for Quality Factor */
-		port_descriptors[SINGLEPARA_Q] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
-		port_names[SINGLEPARA_Q] =
-		 D_("Q");
-		port_range_hints[SINGLEPARA_Q].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
-		port_range_hints[SINGLEPARA_Q].LowerBound = 0;
-		port_range_hints[SINGLEPARA_Q].UpperBound = 100;
-
-		/* Parameters for Input */
-		port_descriptors[SINGLEPARA_INPUT] =
-		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
-		port_names[SINGLEPARA_INPUT] =
-		 D_("Input");
-		port_range_hints[SINGLEPARA_INPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[SINGLEPARA_INPUT].LowerBound = -1.0;
-		port_range_hints[SINGLEPARA_INPUT].UpperBound = +1.0;
-
-		/* Parameters for Output */
-		port_descriptors[SINGLEPARA_OUTPUT] =
-		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
-		port_names[SINGLEPARA_OUTPUT] =
-		 D_("Output");
-		port_range_hints[SINGLEPARA_OUTPUT].HintDescriptor =
-		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
-		port_range_hints[SINGLEPARA_OUTPUT].LowerBound = -1.0;
-		port_range_hints[SINGLEPARA_OUTPUT].UpperBound = +1.0;
-
-		singleParaDescriptor->activate = activateSinglePara;
-		singleParaDescriptor->cleanup = cleanupSinglePara;
-		singleParaDescriptor->connect_port = connectPortSinglePara;
-		singleParaDescriptor->deactivate = NULL;
-		singleParaDescriptor->instantiate = instantiateSinglePara;
-		singleParaDescriptor->run = runSinglePara;
-		singleParaDescriptor->run_adding = NULL;
-	}
-}
-
-void _fini(void);
-void _fini(void) {
-	if (singleParaDescriptor) {
-		free((LADSPA_PortDescriptor *)singleParaDescriptor->PortDescriptors);
-		free((char **)singleParaDescriptor->PortNames);
-		free((LADSPA_PortRangeHint *)singleParaDescriptor->PortRangeHints);
-		free(singleParaDescriptor);
-	}
-
-}
-
diff --git a/build/.keep b/build/.keep
new file mode 100644
index 0000000..e69de29
diff --git a/cmake/compilerwarnings.cmake b/cmake/compilerwarnings.cmake
new file mode 100644
index 0000000..7f6f935
--- /dev/null
+++ b/cmake/compilerwarnings.cmake
@@ -0,0 +1,37 @@
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Werror" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wall" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wextra" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -pedantic" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wcast-align" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wconversion" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wformat-nonliteral" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wformat-security" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wfloat-equal" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Winit-self" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wlogical-op" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wmissing-include-dirs" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wno-write-strings" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wpointer-arith" )
+#set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wswitch-default" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wswitch-enum" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wundef" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wunused-macros" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wno-unused-parameter" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wshadow" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wpacked" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wredundant-decls" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Wunreachable-code" )
+set( WARNINGS_COMMONFLAGS "${WARNINGS_COMMONFLAGS} -Winline" )
+#
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${WARNINGS_COMMONFLAGS}")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wstrict-prototypes")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wbad-function-cast")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wold-style-definition")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wmissing-prototypes")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wmissing-declarations")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wnested-externs")
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WARNINGS_COMMONFLAGS}")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Woverloaded-virtual" )
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Weffc++" )
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wold-style-cast" )
diff --git a/cmake/cppcheck.cmake b/cmake/cppcheck.cmake
new file mode 100644
index 0000000..86d49a2
--- /dev/null
+++ b/cmake/cppcheck.cmake
@@ -0,0 +1,12 @@
+find_program(CPPCHECK_EXE "cppcheck")
+
+if(CPPCHECK_EXE)
+    message(STATUS "[CPPCHECK] at ${CPPCHECK_EXE}")
+    add_custom_target(cppcheck)
+
+    add_custom_command(TARGET cppcheck POST_BUILD
+        COMMAND ${CPPCHECK_EXE} --template=gcc -f --std=posix --std=c99 --std=c++11 --enable=all -i ${PROJECT_BINARY_DIR} -I ${PROJECT_SOURCE_DIR}/include ${PROJECT_SOURCE_DIR}
+    )
+else()
+    message(STATUS "[CPPCHECK] Could not find cppcheck executable")
+endif()
diff --git a/include/biquad.h b/include/biquad.h
new file mode 100644
index 0000000..49451d8
--- /dev/null
+++ b/include/biquad.h
@@ -0,0 +1,331 @@
+#ifndef BIQUAD_H
+#define BIQUAD_H
+
+#define LN_2_2 0.34657359f // ln(2)/2
+
+#include "ladspa-util.h"
+#include <math.h>
+
+#ifndef LIMIT
+#define LIMIT(v,l,u) (v<l?l:(v>u?u:v))
+#endif
+
+// rt 8.1.2013: store biquad coefficients and accumulators in double
+// precision, to limit effects of round-off error.  Change this to
+// float if you need more speed: it probably won't make an audible
+// difference unless you need filters with really high Q or low
+// frequency.
+#ifndef BIQUAD_TYPE
+#define BIQUAD_TYPE double
+#endif
+
+// rt 25.6.2013: amplitude of square wave (at Nyquist freq)
+// added to kill denormals ... may need to experiment with
+// this value.  NB: 1.e-18 = -360dB
+#define DENORMALKILLER 1.e-18;
+
+typedef BIQUAD_TYPE bq_t;
+
+/* Biquad filter (adapted from lisp code by Eli Brandt,
+   http://www.cs.cmu.edu/~eli/) */
+
+typedef struct {
+	bq_t a1;
+	bq_t a2;
+	bq_t b0;
+	bq_t b1;
+	bq_t b2;
+	bq_t x1;
+	bq_t x2;
+	bq_t y1;
+	bq_t y2;
+  bq_t dn;  // denormal state (rt 25.6.2013)
+} biquad;
+
+typedef struct {
+	bq_t a1;
+	bq_t b0;
+	bq_t b1;
+	bq_t x1;
+	bq_t y1;
+  bq_t dn;  // denormal state
+} bilin;
+
+
+static inline void biquad_init(biquad *f) {
+	f->x1 = 0.0f;
+	f->x2 = 0.0f;
+	f->y1 = 0.0f;
+	f->y2 = 0.0f;
+  f->dn = DENORMALKILLER;
+}
+
+static inline void bilin_init(bilin *f) {
+	f->x1 = 0.0f;
+	f->y1 = 0.0f;
+  f->dn = DENORMALKILLER;
+}
+
+//static inline void eq_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q,
+//			  bq_t fs);
+static inline void eq_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q, bq_t fs)
+{
+	bq_t w = 2.0f * M_PI * LIMIT(fc, 1.0f, fs/2.0f) / fs;
+	bq_t J = pow(10.0f, gain * 0.025f);
+	bq_t cw = cos(w);
+	bq_t sw = sin(w);
+  Q = Q / J;  // adjust so input Q is standard elec. eng. Q
+//	bq_t g = sw * sinhf(LN_2_2 * LIMIT(bw, 0.0001f, 4.0f) * w / sw); // case: bw
+  bq_t g = sw/(2.0*Q);                                        // case: Q
+//  bq_t g = sin(w0)/2.0 * sqrt( (J + 1.0/J)*(1.0/S - 1.0) + 2.0 )   // case: S
+
+  bq_t a0 = 1.0f + g / J;
+	bq_t a0r = 1.0f / a0;
+
+	f->b0 = (1.0 + (g * J)) * a0r;
+	f->b1 = (-2.0 * cw) * a0r;
+	f->b2 = (1.0 - (g * J)) * a0r;
+	f->a1 = -(f->b1);
+	f->a2 = ((g / J) - 1.0) * a0r;
+}
+
+//static inline void ls_set_params(biquad *f, bq_t fc, bq_t gain, bq_t slope,
+//			  bq_t fs);
+static inline void ls_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q,
+			  bq_t fs)
+{
+	bq_t w = 2.0f * M_PI * LIMIT(fc, 1.0, fs/2.0) / fs;
+	bq_t cw = cos(w);
+	bq_t sw = sin(w);
+	bq_t A = powf(10.0f, (float) (gain * (bq_t) 0.025));
+
+// rt 8.1.2013: increased slope limit from 1.0f to 5.0f:
+//	bq_t b = sqrt(((1.0f + A * A) / LIMIT(slope, 0.0001f, 5.0f)) - ((A -
+//					1.0f) * (A - 1.0)));
+
+//	bq_t apc = cw * (A + 1.0f);
+//	bq_t amc = cw * (A - 1.0f);
+//	bq_t bs = b * sw;
+//	bq_t a0r = 1.0f / (A + 1.0f + amc + bs);
+
+//	f->b0 = a0r * A * (A + 1.0f - amc + bs);
+//	f->b1 = a0r * 2.0f * A * (A - 1.0f - apc);
+//	f->b2 = a0r * A * (A + 1.0f - amc - bs);
+//	f->a1 = a0r * 2.0f * (A - 1.0f + apc);
+//	f->a2 = a0r * (-A - 1.0f - amc + bs);
+
+  // rt 22.1.2013 changed this to use Q instead of slope
+  bq_t alpha = sw / (2.0 * Q);
+  bq_t b = 2.0*sqrt(A)*alpha;
+  bq_t ap = A + 1.0;
+  bq_t am = A - 1.0;
+  bq_t a0 = ap + am*cw + b;
+	bq_t a0r = 1.0 / a0;
+
+	f->b0 = a0r *       A * (ap - am*cw + b);
+	f->b1 = a0r * 2.0 * A * (am - ap*cw);
+	f->b2 = a0r *       A * (ap - am*cw - b);
+	f->a1 = 2.0 * a0r *     (am + ap*cw);
+	f->a2 = -a0r *          (ap + am*cw - b);
+}
+
+//static inline void hs_set_params(biquad *f, bq_t fc, bq_t gain, bq_t slope,
+//			  bq_t fs);
+static inline void hs_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q, bq_t fs)
+{
+	bq_t w = 2.0f * M_PI * LIMIT(fc, 1.0, fs/2.0) / fs;
+	bq_t cw = cos(w);
+	bq_t sw = sin(w);
+	bq_t A = powf(10.0f, (float) (gain * (bq_t) 0.025));
+// rt 8.1.2013: increased slope limit from 1.0f to 5.0f:
+//	bq_t b = sqrt(((1.0f + A * A) / LIMIT(slope, 0.0001f, 5.0f)) - ((A -
+//					1.0f) * (A - 1.0f)));
+//	bq_t apc = cw * (A + 1.0f);
+//	bq_t amc = cw * (A - 1.0f);
+//	bq_t bs = b * sw;
+//	bq_t a0r = 1.0f / (A + 1.0f - amc + bs);
+
+//	f->b0 = a0r * A * (A + 1.0f + amc + bs);
+//	f->b1 = a0r * -2.0f * A * (A - 1.0f + apc);
+//	f->b2 = a0r * A * (A + 1.0f + amc - bs);
+//	f->a1 = a0r * -2.0f * (A - 1.0f - apc);
+//	f->a2 = a0r * (-A - 1.0f + amc + bs);
+
+  // rt 22.1.2013 changed this to use Q instead of slope
+  bq_t alpha = sw / (2.0 * Q);
+  bq_t b = 2.0*sqrt(A)*alpha;
+  bq_t ap = A + 1.0;
+  bq_t am = A - 1.0;
+  bq_t a0 = ap - am*cw + b;
+	bq_t a0r = 1.0 / a0;
+
+	f->b0 = a0r *       A * (ap + am*cw + b);
+	f->b1 = -a0r * 2.0 * A * (am + ap*cw);
+	f->b2 = a0r *       A * (ap + am*cw - b);
+	f->a1 = -2.0 * a0r *    (am - ap*cw);
+	f->a2 = -a0r *          (ap - am*cw - b);
+}
+
+static inline void lp_set_params(biquad *f, bq_t fc, bq_t Q, bq_t fs)
+{
+	bq_t omega = 2.0 * M_PI * fc/fs;
+	bq_t sn = sin(omega);
+	bq_t cs = cos(omega);
+//	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
+	bq_t alpha = sn / (2.0 * Q);
+
+        const bq_t a0r = 1.0 / (1.0 + alpha);
+        f->b0 = a0r * (1.0 - cs) * 0.5;
+	      f->b1 = a0r * (1.0 - cs);
+        f->b2 = a0r * (1.0 - cs) * 0.5;
+        f->a1 = a0r * (2.0 * cs);
+        f->a2 = a0r * (alpha - 1.0);
+}
+
+static inline void hp_set_params(biquad *f, bq_t fc, bq_t Q, bq_t fs)
+{
+	bq_t omega = 2.0 * M_PI * fc/fs;
+	bq_t sn = sin(omega);
+	bq_t cs = cos(omega);
+//	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
+	bq_t alpha = sn / (2.0 * Q);
+
+        const bq_t a0r = 1.0 / (1.0 + alpha);
+        f->b0 = a0r * (1.0 + cs) * 0.5;
+        f->b1 = a0r * -(1.0 + cs);
+        f->b2 = a0r * (1.0 + cs) * 0.5;
+        f->a1 = a0r * (2.0 * cs);
+        f->a2 = a0r * (alpha - 1.0);
+}
+
+static inline void bp_set_params(biquad *f, bq_t fc, bq_t bw, bq_t fs)
+{
+	bq_t omega = 2.0 * M_PI * fc/fs;
+	bq_t sn = sin(omega);
+	bq_t cs = cos(omega);
+	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
+
+        const bq_t a0r = 1.0 / (1.0 + alpha);
+        f->b0 = a0r * alpha;
+        f->b1 = 0.0;
+        f->b2 = a0r * -alpha;
+        f->a1 = a0r * (2.0 * cs);
+        f->a2 = a0r * (alpha - 1.0);
+}
+
+// rt 8.1.2013: allpass from biquad cookbook
+static inline void ap_set_params(biquad *f, bq_t fc, bq_t Q, bq_t fs)
+{
+	bq_t omega = 2.0 * M_PI * fc/fs;
+	bq_t sn = sin(omega);
+	bq_t cs = cos(omega);
+//	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
+	bq_t alpha = sn / (2.0 * Q);
+
+  bq_t a0 = 1.0 + alpha;
+  bq_t a0r = 1.0 / a0;
+        f->b0 = a0r * (1.0 - alpha);
+        f->b1 = a0r * (-2.0 * cs);
+        f->b2 = 1.0;
+        f->a1 = -f->b1;
+        f->a2 = -f->b0;
+}
+
+static inline void ap1_set_params(bilin *f, bq_t fc, bq_t fs)
+{
+// rt 8.1.2013: implementation of first-order digital allpass found here:
+//  https://ccrma.stanford.edu/realsimple/DelayVar/Phasing_First_Order_Allpass_Filters.html
+// see here for turning transfer function into difference equation:
+//  http://en.wikipedia.org/wiki/Digital_filter
+  bq_t tphi = tan( M_PI * fc / fs);
+  bq_t p = (1.0f - tphi) / (1.0f + tphi);
+
+        // case 1: phase varies from 0 to 180 degrees
+        f->b0 = -p;
+        f->b1 = 1.0f;
+
+        // case 2: phase varies from 180 to 360 degrees
+//        f->b0 = p;
+//        f->b1 = -1.0f;
+
+        f->a1 = p;
+}
+
+// routine that runs a biquad (i.e. 2nd-order) digital filter
+static inline bq_t biquad_run(biquad *f, const bq_t x) {
+	bq_t y;
+
+// rt 15.5.2013: add a Nyquist-frequency square-wave to kill denormals:
+	y = f->b0 * x + f->b1 * f->x1 + f->b2 * f->x2
+		      + f->a1 * f->y1 + f->a2 * f->y2 + f->dn;
+  f->dn = -f->dn;
+
+// see previous commment
+//	y = flush_to_zero(y);
+
+	f->x2 = f->x1;
+	f->x1 = x;
+	f->y2 = f->y1;
+	f->y1 = y;
+
+	return y;
+}
+
+// rt  2.9.2013: special version of biquad_run for 2nd-order
+// allpass; takes advantage of factoring to reduce floating-point
+// multiplications from 5 to 2
+static inline bq_t ap2_run(biquad *f, const bq_t x) {
+	bq_t y;
+
+// rt 15.5.2013: add a Nyquist-frequency square-wave to kill denormals:
+	y = f->b0 * (x - f->y2) + f->b1 * (f->x1 - f->y1) + f->x2 + f->dn;
+  f->dn = -f->dn;
+
+// see previous commment
+//	y = flush_to_zero(y);
+
+	f->x2 = f->x1;
+	f->x1 = x;
+	f->y2 = f->y1;
+	f->y1 = y;
+
+	return y;
+}
+
+// routine that runs a bilinear (i.e. 1st-order) digital filter
+static inline bq_t bilin_run(bilin *f, const bq_t x) {
+	bq_t y;
+
+// rt 15.5.2013: add a Nyquist-frequency square-wave to kill denormals:
+	y = f->b0 * x + f->b1 * f->x1 + f->a1 * f->y1 + f->dn;
+  f->dn = -f->dn;
+
+// see previous commment
+//	y = flush_to_zero(y);
+
+	f->x1 = x;
+	f->y1 = y;
+
+	return y;
+}
+
+// rt  2.9.2013: special version of bilin_run for 2nd-order
+// allpass; takes advantage of factoring to reduce floating-point
+// multiplications from 5 to 2
+static inline bq_t ap1_run(bilin *f, const bq_t x) {
+	bq_t y;
+
+// rt 15.5.2013: adding a Nyquist-frequency square-wave to kill denormals:
+	y = f->b0 * (x - f->y1) + f->x1 + f->dn;
+  f->dn = -f->dn;
+
+// see previous commment
+//	y = flush_to_zero(y);
+
+	f->x1 = x;
+	f->y1 = y;
+
+	return y;
+}
+
+#endif
diff --git a/include/ladspa-util.h b/include/ladspa-util.h
new file mode 100644
index 0000000..2f3264e
--- /dev/null
+++ b/include/ladspa-util.h
@@ -0,0 +1,211 @@
+/* Some misc util functions for audio DSP work, written by Steve Harris,
+ * December 2000
+ *
+ *  steve@plugin.org.uk
+ */
+
+#ifndef LADSPA_UTIL_H
+#define LADSPA_UTIL_H
+
+#include <math.h>
+#include <stdint.h>
+
+// 16.16 fixpoint
+typedef union {
+	int32_t all;
+	struct {
+#ifdef WORDS_BIGENDIAN
+		int16_t in;
+		uint16_t fr;
+#else
+		uint16_t fr;
+		int16_t in;
+#endif
+	} part;
+} fixp16;
+
+// 32.32 fixpoint
+typedef union {
+	int64_t all;
+	struct {
+#ifdef WORDS_BIGENDIAN
+		int32_t in;
+		uint32_t fr;
+#else
+		uint32_t fr;
+		int32_t in;
+#endif
+	} part;
+} fixp32;
+
+/* 32 bit "pointer cast" union */
+typedef union {
+        float f;
+        int32_t i;
+} ls_pcast32;
+
+// 1.0 / ln(2)
+#define LN2R 1.442695041f
+
+/* detet floating point denormal numbers by comparing them to the smallest
+ * normal, crap, but reliable */
+#define DN_CHECK(x, l) if (fabs(x) < 1e-38) printf("DN: "l"\n")
+
+// Denormalise floats, only actually needed for PIII and recent PowerPC
+//#define FLUSH_TO_ZERO(fv) (((*(unsigned int*)&(fv))&0x7f800000)==0)?0.0f:(fv)
+
+static inline float flush_to_zero(float f)
+{
+	ls_pcast32 v;
+
+	v.f = f;
+
+	// original: return (v.i & 0x7f800000) == 0 ? 0.0f : f;
+	// version from Tim Blechmann
+	return (v.i & 0x7f800000) < 0x08000000 ? 0.0f : f;
+}
+
+static inline void round_to_zero(volatile float *f)
+{
+	*f += 1e-18f;
+	*f -= 1e-18f;
+}
+
+/* A set of branchless clipping operations from Laurent de Soras */
+
+static inline float f_max(float x, float a)
+{
+	x -= a;
+	x += fabsf(x);
+	x *= 0.5f;
+	x += a;
+
+	return x;
+}
+
+static inline float f_min(float x, float b)
+{
+	x = b - x;
+	x += fabsf(x);
+	x *= 0.5f;
+	x = b - x;
+
+	return x;
+}
+
+static inline float f_clamp(float x, float a, float b)
+{
+	const float x1 = fabsf(x - a);
+	const float x2 = fabsf(x - b);
+
+	x = x1 + a + b;
+	x -= x2;
+	x *= 0.5f;
+
+	return x;
+}
+
+// Limit a value to be l<=v<=u
+#define LIMIT(v,l,u) ((v)<(l)?(l):((v)>(u)?(u):(v)))
+
+// Truncate-to-zero modulo (ANSI C doesn't specify) will only work
+// if -m < v < 2m
+#define MOD(v,m) (v<0?v+m:(v>=m?v-m:v))
+
+// Truncate-to-zero modulo (ANSI C doesn't specify) will only work
+// if v > -m and v < m
+#define NEG_MOD(v,m) ((v)<0?((v)+(m)):(v))
+
+// Convert a value in dB's to a coefficent
+#define DB_CO(g) ((g) > -90.0f ? powf(10.0f, (g) * 0.05f) : 0.0f)
+#define CO_DB(v) (20.0f * log10f(v))
+
+// Linearly interpolate [ = a * (1 - f) + b * f]
+#define LIN_INTERP(f,a,b) ((a) + (f) * ((b) - (a)))
+
+// Cubic interpolation function
+static inline float cube_interp(const float fr, const float inm1, const float
+                                in, const float inp1, const float inp2)
+{
+	return in + 0.5f * fr * (inp1 - inm1 +
+	 fr * (4.0f * inp1 + 2.0f * inm1 - 5.0f * in - inp2 +
+	 fr * (3.0f * (in - inp1) - inm1 + inp2)));
+}
+
+/* fast sin^2 aproxiamtion, adapted from jan AT rpgfan's posting to the
+ * music-dsp list */
+static inline float f_sin_sq(float angle)
+{
+	const float asqr = angle * angle;
+	float result = -2.39e-08f;
+
+	result *= asqr;
+	result += 2.7526e-06f;
+	result *= asqr;
+	result -= 1.98409e-04f;
+	result *= asqr;
+	result += 8.3333315e-03f;
+	result *= asqr;
+	result -= 1.666666664e-01f;
+	result *= asqr;
+	result += 1.0f;
+	result *= angle;
+
+	return result * result;
+}
+
+#define f_round(f) lrintf(f)
+
+// Truncate float to int
+static inline long int f_trunc(float f)
+{
+	return f_round(floorf(f));
+}
+
+/* Andrew Simper's pow(2, x) aproximation from the music-dsp list */
+
+#if 0
+
+/* original */
+static inline float f_pow2(float x)
+{
+	long *px = (long*)(&x); // store address of float as long pointer
+	const float tx = (x-0.5f) + (3<<22); // temporary value for truncation
+	const long  lx = *((long*)&tx) - 0x4b400000; // integer power of 2
+	const float dx = x-(float)(lx); // float remainder of power of 2
+
+	x = 1.0f + dx*(0.6960656421638072f + // cubic apporoximation of 2^x
+                   dx*(0.224494337302845f +  // for x in the range [0, 1]
+                   dx*(0.07944023841053369f)));
+	*px += (lx<<23); // add integer power of 2 to exponent
+
+	return x;
+}
+
+#else
+
+/* union version */
+static inline float f_pow2(float x)
+{
+	ls_pcast32 *px, tx, lx;
+	float dx;
+
+	px = (ls_pcast32 *)&x; // store address of float as long pointer
+	tx.f = (x-0.5f) + (3<<22); // temporary value for truncation
+	lx.i = tx.i - 0x4b400000; // integer power of 2
+	dx = x - (float)lx.i; // float remainder of power of 2
+
+	x = 1.0f + dx * (0.6960656421638072f + // cubic apporoximation of 2^x
+		   dx * (0.224494337302845f +  // for x in the range [0, 1]
+		   dx * (0.07944023841053369f)));
+	(*px).i += (lx.i << 23); // add integer power of 2 to exponent
+
+	return (*px).f;
+}
+
+#endif
+
+/* Fast exponentiation function, y = e^x */
+#define f_exp(x) f_pow2(x * LN2R)
+
+#endif
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
new file mode 100644
index 0000000..aa896e7
--- /dev/null
+++ b/src/CMakeLists.txt
@@ -0,0 +1,26 @@
+include_directories(${PROJECT_SOURCE_DIR}/include)
+
+option(USE_SSE2 "use SSE2 instructions to avoid floating point denormalization issues" on)
+
+add_library(RTallpass1 MODULE RTallpass1.c)
+add_library(RTallpass2 MODULE RTallpass2.c)
+
+add_library(RTlowpass MODULE RTlowpass.c)
+add_library(RThighpass MODULE RThighpass.c)
+
+add_library(RTlowshelf MODULE RTlowshelf.c)
+add_library(RThighshelf MODULE RThighshelf.c)
+
+add_library(RTlr4hipass MODULE RTlr4hipass.c)
+add_library(RTlr4lowpass MODULE RTlr4lowpass.c)
+
+add_library(RTparaeq MODULE RTparaeq.c)
+
+set_target_properties(RTallpass1 RTallpass2 RTlowpass RThighpass RTlowshelf RThighshelf RTlr4hipass RTlr4lowpass RTparaeq
+                      PROPERTIES LINK_FLAGS "-nostartfiles")
+if(USE_SSE2)
+  set_target_properties(RTallpass1 RTallpass2 RTlowpass RThighpass RTlowshelf RThighshelf RTlr4hipass RTlr4lowpass RTparaeq
+                        PROPERTIES COMPILE_FLAGS "-msse2 -mfpmath=sse")
+endif()
+install(TARGETS RTallpass1 RTallpass2 RTlowpass RThighpass RTlowshelf RThighshelf RTlr4hipass RTlr4lowpass RTparaeq
+        LIBRARY DESTINATION lib/ladspa)
diff --git a/src/RTallpass1.c b/src/RTallpass1.c
new file mode 100644
index 0000000..8bbae7f
--- /dev/null
+++ b/src/RTallpass1.c
@@ -0,0 +1,231 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define ALLPASS1_FC                    0
+#define ALLPASS1_INPUT                 1
+#define ALLPASS1_OUTPUT                2
+
+static LADSPA_Descriptor *allPassDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *fc;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	bilin *     filter;
+	float        fs;
+} AllPass;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return allPassDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateAllPass(LADSPA_Handle instance) {
+	AllPass *plugin_data = (AllPass *)instance;
+	bilin *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	bilin_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupAllPass(LADSPA_Handle instance) {
+	AllPass *plugin_data = (AllPass *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortAllPass(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	AllPass *plugin;
+
+	plugin = (AllPass *)instance;
+	switch (port) {
+	case ALLPASS1_FC:
+		plugin->fc = data;
+		break;
+	case ALLPASS1_INPUT:
+		plugin->input = data;
+		break;
+	case ALLPASS1_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateAllPass(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	AllPass *plugin_data = (AllPass *)malloc(sizeof(AllPass));
+	bilin *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(bilin));
+	bilin_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runAllPass(LADSPA_Handle instance, unsigned long sample_count) {
+	AllPass *plugin_data = (AllPass *)instance;
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+
+	bilin * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	ap1_set_params(filter, fc, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+		// RT 2.9.2013: replace biquad_run with ap1_run to cut floating-
+		// point multiplications from 3 to 1:
+	  buffer_write(output[pos], (LADSPA_Data) ap1_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	allPassDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (allPassDescriptor) {
+		allPassDescriptor->UniqueID = 9010;
+		allPassDescriptor->Label = "RTallpass1";
+		allPassDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		allPassDescriptor->Name =
+		 D_("RT First Order Allpass");
+		allPassDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		allPassDescriptor->Copyright =
+		 "GPL";
+		allPassDescriptor->PortCount = 3;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(3,
+		 sizeof(LADSPA_PortDescriptor));
+		allPassDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(3,
+		 sizeof(LADSPA_PortRangeHint));
+		allPassDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(3, sizeof(char*));
+		allPassDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[ALLPASS1_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[ALLPASS1_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[ALLPASS1_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[ALLPASS1_FC].LowerBound = 0.0;
+		port_range_hints[ALLPASS1_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Input */
+		port_descriptors[ALLPASS1_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[ALLPASS1_INPUT] =
+		 D_("Input");
+		port_range_hints[ALLPASS1_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[ALLPASS1_INPUT].LowerBound = -1.0;
+		port_range_hints[ALLPASS1_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[ALLPASS1_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[ALLPASS1_OUTPUT] =
+		 D_("Output");
+		port_range_hints[ALLPASS1_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[ALLPASS1_OUTPUT].LowerBound = -1.0;
+		port_range_hints[ALLPASS1_OUTPUT].UpperBound = +1.0;
+
+		allPassDescriptor->activate = activateAllPass;
+		allPassDescriptor->cleanup = cleanupAllPass;
+		allPassDescriptor->connect_port = connectPortAllPass;
+		allPassDescriptor->deactivate = NULL;
+		allPassDescriptor->instantiate = instantiateAllPass;
+		allPassDescriptor->run = runAllPass;
+		allPassDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (allPassDescriptor) {
+		free((LADSPA_PortDescriptor *)allPassDescriptor->PortDescriptors);
+		free((char **)allPassDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)allPassDescriptor->PortRangeHints);
+		free(allPassDescriptor);
+	}
+
+}
+
diff --git a/src/RTallpass2.c b/src/RTallpass2.c
new file mode 100644
index 0000000..d663b28
--- /dev/null
+++ b/src/RTallpass2.c
@@ -0,0 +1,250 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define ALLPASS_FC                  0
+#define ALLPASS_Q                   1
+#define ALLPASS_INPUT               2
+#define ALLPASS_OUTPUT              3
+
+static LADSPA_Descriptor *allPassDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *gain;
+	LADSPA_Data *fc;
+	LADSPA_Data *Q;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filter;
+	float        fs;
+} AllPass;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return allPassDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateAllPass(LADSPA_Handle instance) {
+	AllPass *plugin_data = (AllPass *)instance;
+	biquad *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	biquad_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupAllPass(LADSPA_Handle instance) {
+	AllPass *plugin_data = (AllPass *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortAllPass(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	AllPass *plugin;
+
+	plugin = (AllPass *)instance;
+	switch (port) {
+	case ALLPASS_FC:
+		plugin->fc = data;
+		break;
+	case ALLPASS_Q:
+		plugin->Q = data;
+		break;
+	case ALLPASS_INPUT:
+		plugin->input = data;
+		break;
+	case ALLPASS_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateAllPass(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	AllPass *plugin_data = (AllPass *)malloc(sizeof(AllPass));
+	biquad *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(biquad));
+	biquad_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runAllPass(LADSPA_Handle instance, unsigned long sample_count) {
+	AllPass *plugin_data = (AllPass *)instance;
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Bandwidth (octaves) (float value) */
+	const LADSPA_Data Q = *(plugin_data->Q);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+
+	biquad * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	ap_set_params(filter, fc, Q, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+		// RT 2.9.2013: replace biquad_run with ap2_run to cut floating-
+		// point multiplications from 5 to 2:
+	  buffer_write(output[pos], (LADSPA_Data) ap2_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	allPassDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (allPassDescriptor) {
+		allPassDescriptor->UniqueID = 9005;
+		allPassDescriptor->Label = "RTallpass2";
+		allPassDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		allPassDescriptor->Name =
+		 D_("RT Biquad Allpass");
+		allPassDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		allPassDescriptor->Copyright =
+		 "GPL";
+		allPassDescriptor->PortCount = 4;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(4,
+		 sizeof(LADSPA_PortDescriptor));
+		allPassDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(4,
+		 sizeof(LADSPA_PortRangeHint));
+		allPassDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(4, sizeof(char*));
+		allPassDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[ALLPASS_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[ALLPASS_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[ALLPASS_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[ALLPASS_FC].LowerBound = 0;
+		port_range_hints[ALLPASS_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Bandwidth (octaves) */
+		port_descriptors[ALLPASS_Q] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[ALLPASS_Q] =
+		 D_("Q");
+		port_range_hints[ALLPASS_Q].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[ALLPASS_Q].LowerBound = 0;
+		port_range_hints[ALLPASS_Q].UpperBound = 10;
+
+		/* Parameters for Input */
+		port_descriptors[ALLPASS_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[ALLPASS_INPUT] =
+		 D_("Input");
+		port_range_hints[ALLPASS_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[ALLPASS_INPUT].LowerBound = -1.0;
+		port_range_hints[ALLPASS_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[ALLPASS_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[ALLPASS_OUTPUT] =
+		 D_("Output");
+		port_range_hints[ALLPASS_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[ALLPASS_OUTPUT].LowerBound = -1.0;
+		port_range_hints[ALLPASS_OUTPUT].UpperBound = +1.0;
+
+		allPassDescriptor->activate = activateAllPass;
+		allPassDescriptor->cleanup = cleanupAllPass;
+		allPassDescriptor->connect_port = connectPortAllPass;
+		allPassDescriptor->deactivate = NULL;
+		allPassDescriptor->instantiate = instantiateAllPass;
+		allPassDescriptor->run = runAllPass;
+		allPassDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (allPassDescriptor) {
+		free((LADSPA_PortDescriptor *)allPassDescriptor->PortDescriptors);
+		free((char **)allPassDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)allPassDescriptor->PortRangeHints);
+		free(allPassDescriptor);
+	}
+
+}
+
diff --git a/src/RThighpass.c b/src/RThighpass.c
new file mode 100644
index 0000000..3cf29c5
--- /dev/null
+++ b/src/RThighpass.c
@@ -0,0 +1,246 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define HIGHPASS_FC                  0
+#define HIGHPASS_Q                   1
+#define HIGHPASS_INPUT               2
+#define HIGHPASS_OUTPUT              3
+
+static LADSPA_Descriptor *highPassDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *fc;
+	LADSPA_Data *Q;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filter;
+	float        fs;
+} HighPass;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return highPassDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateHighPass(LADSPA_Handle instance) {
+	HighPass *plugin_data = (HighPass *)instance;
+	biquad *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	biquad_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupHighPass(LADSPA_Handle instance) {
+	HighPass *plugin_data = (HighPass *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortHighPass(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	HighPass *plugin;
+
+	plugin = (HighPass *)instance;
+	switch (port) {
+	case HIGHPASS_FC:
+		plugin->fc = data;
+		break;
+	case HIGHPASS_Q:
+		plugin->Q = data;
+		break;
+	case HIGHPASS_INPUT:
+		plugin->input = data;
+		break;
+	case HIGHPASS_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateHighPass(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	HighPass *plugin_data = (HighPass *)malloc(sizeof(HighPass));
+	biquad *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(biquad));
+	biquad_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runHighPass(LADSPA_Handle instance, unsigned long sample_count) {
+	HighPass *plugin_data = (HighPass *)instance;
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Bandwidth (octaves) (float value) */
+	const LADSPA_Data Q = *(plugin_data->Q);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	hp_set_params(filter, fc, Q, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	highPassDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (highPassDescriptor) {
+		highPassDescriptor->UniqueID = 9007;
+		highPassDescriptor->Label = "RThighpass";
+		highPassDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		highPassDescriptor->Name =
+		 D_("RT 2nd-order highpass");
+		highPassDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		highPassDescriptor->Copyright =
+		 "GPL";
+		highPassDescriptor->PortCount = 4;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(4,
+		 sizeof(LADSPA_PortDescriptor));
+		highPassDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(4,
+		 sizeof(LADSPA_PortRangeHint));
+		highPassDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(4, sizeof(char*));
+		highPassDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[HIGHPASS_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[HIGHPASS_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[HIGHPASS_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[HIGHPASS_FC].LowerBound = 0;
+		port_range_hints[HIGHPASS_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Q */
+		port_descriptors[HIGHPASS_Q] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[HIGHPASS_Q] =
+		 D_("Q");
+		port_range_hints[HIGHPASS_Q].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[HIGHPASS_Q].LowerBound = 0;
+		port_range_hints[HIGHPASS_Q].UpperBound = 5;
+
+		/* Parameters for Input */
+		port_descriptors[HIGHPASS_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[HIGHPASS_INPUT] =
+		 D_("Input");
+		port_range_hints[HIGHPASS_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[HIGHPASS_INPUT].LowerBound = -1.0;
+		port_range_hints[HIGHPASS_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[HIGHPASS_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[HIGHPASS_OUTPUT] =
+		 D_("Output");
+		port_range_hints[HIGHPASS_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[HIGHPASS_OUTPUT].LowerBound = -1.0;
+		port_range_hints[HIGHPASS_OUTPUT].UpperBound = +1.0;
+
+		highPassDescriptor->activate = activateHighPass;
+		highPassDescriptor->cleanup = cleanupHighPass;
+		highPassDescriptor->connect_port = connectPortHighPass;
+		highPassDescriptor->deactivate = NULL;
+		highPassDescriptor->instantiate = instantiateHighPass;
+		highPassDescriptor->run = runHighPass;
+		highPassDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (highPassDescriptor) {
+		free((LADSPA_PortDescriptor *)highPassDescriptor->PortDescriptors);
+		free((char **)highPassDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)highPassDescriptor->PortRangeHints);
+		free(highPassDescriptor);
+	}
+
+}
+
diff --git a/src/RThighshelf.c b/src/RThighshelf.c
new file mode 100644
index 0000000..399aaf2
--- /dev/null
+++ b/src/RThighshelf.c
@@ -0,0 +1,264 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define HIGHSHELF_GAIN                0
+#define HIGHSHELF_FC                  1
+#define HIGHSHELF_Q                   2
+#define HIGHSHELF_INPUT               3
+#define HIGHSHELF_OUTPUT              4
+
+static LADSPA_Descriptor *highShelfDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *gain;
+	LADSPA_Data *fc;
+	LADSPA_Data *Q;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filter;
+	float        fs;
+} HighShelf;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return highShelfDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateHighShelf(LADSPA_Handle instance) {
+	HighShelf *plugin_data = (HighShelf *)instance;
+	biquad *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	biquad_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupHighShelf(LADSPA_Handle instance) {
+	HighShelf *plugin_data = (HighShelf *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortHighShelf(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	HighShelf *plugin;
+
+	plugin = (HighShelf *)instance;
+	switch (port) {
+	case HIGHSHELF_GAIN:
+		plugin->gain = data;
+		break;
+	case HIGHSHELF_FC:
+		plugin->fc = data;
+		break;
+	case HIGHSHELF_Q:
+		plugin->Q = data;
+		break;
+	case HIGHSHELF_INPUT:
+		plugin->input = data;
+		break;
+	case HIGHSHELF_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateHighShelf(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	HighShelf *plugin_data = (HighShelf *)malloc(sizeof(HighShelf));
+	biquad *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(biquad));
+	biquad_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runHighShelf(LADSPA_Handle instance, unsigned long sample_count) {
+	HighShelf *plugin_data = (HighShelf *)instance;
+
+	/* Gain (dB) (float value) */
+	const LADSPA_Data gain = *(plugin_data->gain);
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Bandwidth (octaves) (float value) */
+	const LADSPA_Data Q = *(plugin_data->Q);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	hs_set_params(filter, fc, gain, Q, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	highShelfDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (highShelfDescriptor) {
+		highShelfDescriptor->UniqueID = 9003;
+		highShelfDescriptor->Label = "RThighshelf";
+		highShelfDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		highShelfDescriptor->Name =
+		 D_("RT High Shelf");
+		highShelfDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		highShelfDescriptor->Copyright =
+		 "GPL";
+		highShelfDescriptor->PortCount = 5;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(5,
+		 sizeof(LADSPA_PortDescriptor));
+		highShelfDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(5,
+		 sizeof(LADSPA_PortRangeHint));
+		highShelfDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(5, sizeof(char*));
+		highShelfDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Gain (dB) */
+		port_descriptors[HIGHSHELF_GAIN] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[HIGHSHELF_GAIN] =
+		 D_("Gain (dB)");
+		port_range_hints[HIGHSHELF_GAIN].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_0;
+		port_range_hints[HIGHSHELF_GAIN].LowerBound = -70;
+		port_range_hints[HIGHSHELF_GAIN].UpperBound = +30;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[HIGHSHELF_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[HIGHSHELF_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[HIGHSHELF_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[HIGHSHELF_FC].LowerBound = 0;
+		port_range_hints[HIGHSHELF_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Quality Factor */
+		port_descriptors[HIGHSHELF_Q] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[HIGHSHELF_Q] =
+		 D_("Q");
+		port_range_hints[HIGHSHELF_Q].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[HIGHSHELF_Q].LowerBound = 0;
+		port_range_hints[HIGHSHELF_Q].UpperBound = 5;
+
+		/* Parameters for Input */
+		port_descriptors[HIGHSHELF_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[HIGHSHELF_INPUT] =
+		 D_("Input");
+		port_range_hints[HIGHSHELF_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[HIGHSHELF_INPUT].LowerBound = -1.0;
+		port_range_hints[HIGHSHELF_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[HIGHSHELF_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[HIGHSHELF_OUTPUT] =
+		 D_("Output");
+		port_range_hints[HIGHSHELF_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[HIGHSHELF_OUTPUT].LowerBound = -1.0;
+		port_range_hints[HIGHSHELF_OUTPUT].UpperBound = +1.0;
+
+		highShelfDescriptor->activate = activateHighShelf;
+		highShelfDescriptor->cleanup = cleanupHighShelf;
+		highShelfDescriptor->connect_port = connectPortHighShelf;
+		highShelfDescriptor->deactivate = NULL;
+		highShelfDescriptor->instantiate = instantiateHighShelf;
+		highShelfDescriptor->run = runHighShelf;
+		highShelfDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (highShelfDescriptor) {
+		free((LADSPA_PortDescriptor *)highShelfDescriptor->PortDescriptors);
+		free((char **)highShelfDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)highShelfDescriptor->PortRangeHints);
+		free(highShelfDescriptor);
+	}
+
+}
+
diff --git a/src/RTlowpass.c b/src/RTlowpass.c
new file mode 100644
index 0000000..b98a8a6
--- /dev/null
+++ b/src/RTlowpass.c
@@ -0,0 +1,246 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define LOWPASS_FC                  0
+#define LOWPASS_Q                   1
+#define LOWPASS_INPUT               2
+#define LOWPASS_OUTPUT              3
+
+static LADSPA_Descriptor *lowPassDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *fc;
+	LADSPA_Data *Q;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filter;
+	float        fs;
+} LowPass;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return lowPassDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateLowPass(LADSPA_Handle instance) {
+	LowPass *plugin_data = (LowPass *)instance;
+	biquad *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	biquad_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupLowPass(LADSPA_Handle instance) {
+	LowPass *plugin_data = (LowPass *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortLowPass(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	LowPass *plugin;
+
+	plugin = (LowPass *)instance;
+	switch (port) {
+	case LOWPASS_FC:
+		plugin->fc = data;
+		break;
+	case LOWPASS_Q:
+		plugin->Q = data;
+		break;
+	case LOWPASS_INPUT:
+		plugin->input = data;
+		break;
+	case LOWPASS_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateLowPass(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	LowPass *plugin_data = (LowPass *)malloc(sizeof(LowPass));
+	biquad *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(biquad));
+	biquad_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runLowPass(LADSPA_Handle instance, unsigned long sample_count) {
+	LowPass *plugin_data = (LowPass *)instance;
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Bandwidth (octaves) (float value) */
+	const LADSPA_Data Q = *(plugin_data->Q);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	lp_set_params(filter, fc, Q, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	lowPassDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (lowPassDescriptor) {
+		lowPassDescriptor->UniqueID = 9006;
+		lowPassDescriptor->Label = "RTlowpass";
+		lowPassDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		lowPassDescriptor->Name =
+		 D_("RT 2nd-order lowpass");
+		lowPassDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		lowPassDescriptor->Copyright =
+		 "GPL";
+		lowPassDescriptor->PortCount = 4;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(4,
+		 sizeof(LADSPA_PortDescriptor));
+		lowPassDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(4,
+		 sizeof(LADSPA_PortRangeHint));
+		lowPassDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(4, sizeof(char*));
+		lowPassDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[LOWPASS_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LOWPASS_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[LOWPASS_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[LOWPASS_FC].LowerBound = 0;
+		port_range_hints[LOWPASS_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Q */
+		port_descriptors[LOWPASS_Q] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LOWPASS_Q] =
+		 D_("Q");
+		port_range_hints[LOWPASS_Q].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[LOWPASS_Q].LowerBound = 0;
+		port_range_hints[LOWPASS_Q].UpperBound = 5;
+
+		/* Parameters for Input */
+		port_descriptors[LOWPASS_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[LOWPASS_INPUT] =
+		 D_("Input");
+		port_range_hints[LOWPASS_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LOWPASS_INPUT].LowerBound = -1.0;
+		port_range_hints[LOWPASS_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[LOWPASS_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[LOWPASS_OUTPUT] =
+		 D_("Output");
+		port_range_hints[LOWPASS_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LOWPASS_OUTPUT].LowerBound = -1.0;
+		port_range_hints[LOWPASS_OUTPUT].UpperBound = +1.0;
+
+		lowPassDescriptor->activate = activateLowPass;
+		lowPassDescriptor->cleanup = cleanupLowPass;
+		lowPassDescriptor->connect_port = connectPortLowPass;
+		lowPassDescriptor->deactivate = NULL;
+		lowPassDescriptor->instantiate = instantiateLowPass;
+		lowPassDescriptor->run = runLowPass;
+		lowPassDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (lowPassDescriptor) {
+		free((LADSPA_PortDescriptor *)lowPassDescriptor->PortDescriptors);
+		free((char **)lowPassDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)lowPassDescriptor->PortRangeHints);
+		free(lowPassDescriptor);
+	}
+
+}
+
diff --git a/src/RTlowshelf.c b/src/RTlowshelf.c
new file mode 100644
index 0000000..e6265b5
--- /dev/null
+++ b/src/RTlowshelf.c
@@ -0,0 +1,264 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define LOWSHELF_GAIN                0
+#define LOWSHELF_FC                  1
+#define LOWSHELF_Q                   2
+#define LOWSHELF_INPUT               3
+#define LOWSHELF_OUTPUT              4
+
+static LADSPA_Descriptor *lowShelfDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *gain;
+	LADSPA_Data *fc;
+	LADSPA_Data *Q;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filter;
+	float        fs;
+} LowShelf;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return lowShelfDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateLowShelf(LADSPA_Handle instance) {
+	LowShelf *plugin_data = (LowShelf *)instance;
+	biquad *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	biquad_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupLowShelf(LADSPA_Handle instance) {
+	LowShelf *plugin_data = (LowShelf *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortLowShelf(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	LowShelf *plugin;
+
+	plugin = (LowShelf *)instance;
+	switch (port) {
+	case LOWSHELF_GAIN:
+		plugin->gain = data;
+		break;
+	case LOWSHELF_FC:
+		plugin->fc = data;
+		break;
+	case LOWSHELF_Q:
+		plugin->Q = data;
+		break;
+	case LOWSHELF_INPUT:
+		plugin->input = data;
+		break;
+	case LOWSHELF_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateLowShelf(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	LowShelf *plugin_data = (LowShelf *)malloc(sizeof(LowShelf));
+	biquad *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(biquad));
+	biquad_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runLowShelf(LADSPA_Handle instance, unsigned long sample_count) {
+	LowShelf *plugin_data = (LowShelf *)instance;
+
+	/* Gain (dB) (float value) */
+	const LADSPA_Data gain = *(plugin_data->gain);
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Bandwidth (octaves) (float value) */
+	const LADSPA_Data Q = *(plugin_data->Q);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	ls_set_params(filter, fc, gain, Q, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	lowShelfDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (lowShelfDescriptor) {
+		lowShelfDescriptor->UniqueID = 9002;
+		lowShelfDescriptor->Label = "RTlowshelf";
+		lowShelfDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		lowShelfDescriptor->Name =
+		 D_("RT Low Shelf");
+		lowShelfDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		lowShelfDescriptor->Copyright =
+		 "GPL";
+		lowShelfDescriptor->PortCount = 5;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(5,
+		 sizeof(LADSPA_PortDescriptor));
+		lowShelfDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(5,
+		 sizeof(LADSPA_PortRangeHint));
+		lowShelfDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(5, sizeof(char*));
+		lowShelfDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Gain (dB) */
+		port_descriptors[LOWSHELF_GAIN] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LOWSHELF_GAIN] =
+		 D_("Gain (dB)");
+		port_range_hints[LOWSHELF_GAIN].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_0;
+		port_range_hints[LOWSHELF_GAIN].LowerBound = -70;
+		port_range_hints[LOWSHELF_GAIN].UpperBound = +30;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[LOWSHELF_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LOWSHELF_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[LOWSHELF_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[LOWSHELF_FC].LowerBound = 0;
+		port_range_hints[LOWSHELF_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Quality Factor */
+		port_descriptors[LOWSHELF_Q] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LOWSHELF_Q] =
+		 D_("Q");
+		port_range_hints[LOWSHELF_Q].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[LOWSHELF_Q].LowerBound = 0;
+		port_range_hints[LOWSHELF_Q].UpperBound = 5;
+
+		/* Parameters for Input */
+		port_descriptors[LOWSHELF_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[LOWSHELF_INPUT] =
+		 D_("Input");
+		port_range_hints[LOWSHELF_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LOWSHELF_INPUT].LowerBound = -1.0;
+		port_range_hints[LOWSHELF_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[LOWSHELF_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[LOWSHELF_OUTPUT] =
+		 D_("Output");
+		port_range_hints[LOWSHELF_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LOWSHELF_OUTPUT].LowerBound = -1.0;
+		port_range_hints[LOWSHELF_OUTPUT].UpperBound = +1.0;
+
+		lowShelfDescriptor->activate = activateLowShelf;
+		lowShelfDescriptor->cleanup = cleanupLowShelf;
+		lowShelfDescriptor->connect_port = connectPortLowShelf;
+		lowShelfDescriptor->deactivate = NULL;
+		lowShelfDescriptor->instantiate = instantiateLowShelf;
+		lowShelfDescriptor->run = runLowShelf;
+		lowShelfDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (lowShelfDescriptor) {
+		free((LADSPA_PortDescriptor *)lowShelfDescriptor->PortDescriptors);
+		free((char **)lowShelfDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)lowShelfDescriptor->PortRangeHints);
+		free(lowShelfDescriptor);
+	}
+
+}
+
diff --git a/src/RTlr4hipass.c b/src/RTlr4hipass.c
new file mode 100644
index 0000000..80dd651
--- /dev/null
+++ b/src/RTlr4hipass.c
@@ -0,0 +1,234 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define LR4HIGHPASS_FC                  0
+#define LR4HIGHPASS_INPUT               1
+#define LR4HIGHPASS_OUTPUT              2
+
+static LADSPA_Descriptor *lr4highPassDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *fc;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filters;
+	float        fs;
+} LR4HighPass;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return lr4highPassDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateLR4HighPass(LADSPA_Handle instance) {
+	LR4HighPass *plugin_data = (LR4HighPass *)instance;
+	biquad *filters = plugin_data->filters;
+	float fs = plugin_data->fs;
+	biquad_init(&filters[0]);
+	biquad_init(&filters[1]);
+	plugin_data->filters = filters;
+	plugin_data->fs = fs;
+}
+
+static void cleanupLR4HighPass(LADSPA_Handle instance) {
+	LR4HighPass *plugin_data = (LR4HighPass *)instance;
+	free(plugin_data->filters);
+	free(instance);
+}
+
+static void connectPortLR4HighPass(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	LR4HighPass *plugin;
+
+	plugin = (LR4HighPass *)instance;
+	switch (port) {
+	case LR4HIGHPASS_FC:
+		plugin->fc = data;
+		break;
+	case LR4HIGHPASS_INPUT:
+		plugin->input = data;
+		break;
+	case LR4HIGHPASS_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateLR4HighPass(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	LR4HighPass *plugin_data = (LR4HighPass *)malloc(sizeof(LR4HighPass));
+	biquad *filters = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+
+	filters = calloc(2, sizeof(biquad));
+	biquad_init(&filters[0]);
+	biquad_init(&filters[1]);
+
+	plugin_data->filters = filters;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runLR4HighPass(LADSPA_Handle instance, unsigned long sample_count) {
+	LR4HighPass *plugin_data = (LR4HighPass *)instance;
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filters = plugin_data->filters;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+  bq_t in;
+
+	hp_set_params(&filters[0], fc, 0.7071068, fs);
+	hp_set_params(&filters[1], fc, 0.7071068, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+    in = biquad_run(&filters[0], input[pos]);
+    in = biquad_run(&filters[1], in);
+    buffer_write(output[pos], (LADSPA_Data) in);
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	lr4highPassDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (lr4highPassDescriptor) {
+		lr4highPassDescriptor->UniqueID = 9021;
+		lr4highPassDescriptor->Label = "RTlr4hipass";
+		lr4highPassDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		lr4highPassDescriptor->Name =
+		 D_("RT LR4 highpass");
+		lr4highPassDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		lr4highPassDescriptor->Copyright =
+		 "GPL";
+		lr4highPassDescriptor->PortCount = 3;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(3,
+		 sizeof(LADSPA_PortDescriptor));
+		lr4highPassDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(3,
+		 sizeof(LADSPA_PortRangeHint));
+		lr4highPassDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(3, sizeof(char*));
+		lr4highPassDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[LR4HIGHPASS_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LR4HIGHPASS_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[LR4HIGHPASS_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[LR4HIGHPASS_FC].LowerBound = 0;
+		port_range_hints[LR4HIGHPASS_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Input */
+		port_descriptors[LR4HIGHPASS_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[LR4HIGHPASS_INPUT] =
+		 D_("Input");
+		port_range_hints[LR4HIGHPASS_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LR4HIGHPASS_INPUT].LowerBound = -1.0;
+		port_range_hints[LR4HIGHPASS_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[LR4HIGHPASS_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[LR4HIGHPASS_OUTPUT] =
+		 D_("Output");
+		port_range_hints[LR4HIGHPASS_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LR4HIGHPASS_OUTPUT].LowerBound = -1.0;
+		port_range_hints[LR4HIGHPASS_OUTPUT].UpperBound = +1.0;
+
+		lr4highPassDescriptor->activate = activateLR4HighPass;
+		lr4highPassDescriptor->cleanup = cleanupLR4HighPass;
+		lr4highPassDescriptor->connect_port = connectPortLR4HighPass;
+		lr4highPassDescriptor->deactivate = NULL;
+		lr4highPassDescriptor->instantiate = instantiateLR4HighPass;
+		lr4highPassDescriptor->run = runLR4HighPass;
+		lr4highPassDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (lr4highPassDescriptor) {
+		free((LADSPA_PortDescriptor *)lr4highPassDescriptor->PortDescriptors);
+		free((char **)lr4highPassDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)lr4highPassDescriptor->PortRangeHints);
+		free(lr4highPassDescriptor);
+	}
+
+}
+
diff --git a/src/RTlr4lowpass.c b/src/RTlr4lowpass.c
new file mode 100644
index 0000000..f1d269e
--- /dev/null
+++ b/src/RTlr4lowpass.c
@@ -0,0 +1,234 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define LR4LOWPASS_FC                  0
+#define LR4LOWPASS_INPUT               1
+#define LR4LOWPASS_OUTPUT              2
+
+static LADSPA_Descriptor *lr4lowPassDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *fc;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filters;
+	float        fs;
+} LR4LowPass;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return lr4lowPassDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateLR4LowPass(LADSPA_Handle instance) {
+	LR4LowPass *plugin_data = (LR4LowPass *)instance;
+	biquad *filters = plugin_data->filters;
+	float fs = plugin_data->fs;
+	biquad_init(&filters[0]);
+	biquad_init(&filters[1]);
+	plugin_data->filters = filters;
+	plugin_data->fs = fs;
+}
+
+static void cleanupLR4LowPass(LADSPA_Handle instance) {
+	LR4LowPass *plugin_data = (LR4LowPass *)instance;
+	free(plugin_data->filters);
+	free(instance);
+}
+
+static void connectPortLR4LowPass(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	LR4LowPass *plugin;
+
+	plugin = (LR4LowPass *)instance;
+	switch (port) {
+	case LR4LOWPASS_FC:
+		plugin->fc = data;
+		break;
+	case LR4LOWPASS_INPUT:
+		plugin->input = data;
+		break;
+	case LR4LOWPASS_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateLR4LowPass(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	LR4LowPass *plugin_data = (LR4LowPass *)malloc(sizeof(LR4LowPass));
+	biquad *filters = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+
+	filters = calloc(2, sizeof(biquad));
+	biquad_init(&filters[0]);
+	biquad_init(&filters[1]);
+
+	plugin_data->filters = filters;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runLR4LowPass(LADSPA_Handle instance, unsigned long sample_count) {
+	LR4LowPass *plugin_data = (LR4LowPass *)instance;
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filters = plugin_data->filters;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+  bq_t in;
+
+	lp_set_params(&filters[0], fc, 0.7071068, fs);
+	lp_set_params(&filters[1], fc, 0.7071068, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+    in = biquad_run(&filters[0], input[pos]);
+    in = biquad_run(&filters[1], in);
+    buffer_write(output[pos], (LADSPA_Data) in);
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	lr4lowPassDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (lr4lowPassDescriptor) {
+		lr4lowPassDescriptor->UniqueID = 9020;
+		lr4lowPassDescriptor->Label = "RTlr4lowpass";
+		lr4lowPassDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		lr4lowPassDescriptor->Name =
+		 D_("RT LR4 lowpass");
+		lr4lowPassDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		lr4lowPassDescriptor->Copyright =
+		 "GPL";
+		lr4lowPassDescriptor->PortCount = 3;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(3,
+		 sizeof(LADSPA_PortDescriptor));
+		lr4lowPassDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(3,
+		 sizeof(LADSPA_PortRangeHint));
+		lr4lowPassDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(3, sizeof(char*));
+		lr4lowPassDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[LR4LOWPASS_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[LR4LOWPASS_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[LR4LOWPASS_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[LR4LOWPASS_FC].LowerBound = 0;
+		port_range_hints[LR4LOWPASS_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Input */
+		port_descriptors[LR4LOWPASS_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[LR4LOWPASS_INPUT] =
+		 D_("Input");
+		port_range_hints[LR4LOWPASS_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LR4LOWPASS_INPUT].LowerBound = -1.0;
+		port_range_hints[LR4LOWPASS_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[LR4LOWPASS_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[LR4LOWPASS_OUTPUT] =
+		 D_("Output");
+		port_range_hints[LR4LOWPASS_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[LR4LOWPASS_OUTPUT].LowerBound = -1.0;
+		port_range_hints[LR4LOWPASS_OUTPUT].UpperBound = +1.0;
+
+		lr4lowPassDescriptor->activate = activateLR4LowPass;
+		lr4lowPassDescriptor->cleanup = cleanupLR4LowPass;
+		lr4lowPassDescriptor->connect_port = connectPortLR4LowPass;
+		lr4lowPassDescriptor->deactivate = NULL;
+		lr4lowPassDescriptor->instantiate = instantiateLR4LowPass;
+		lr4lowPassDescriptor->run = runLR4LowPass;
+		lr4lowPassDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (lr4lowPassDescriptor) {
+		free((LADSPA_PortDescriptor *)lr4lowPassDescriptor->PortDescriptors);
+		free((char **)lr4lowPassDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)lr4lowPassDescriptor->PortRangeHints);
+		free(lr4lowPassDescriptor);
+	}
+
+}
+
diff --git a/src/RTparaeq.c b/src/RTparaeq.c
new file mode 100644
index 0000000..5376d64
--- /dev/null
+++ b/src/RTparaeq.c
@@ -0,0 +1,264 @@
+/* Copyright 2013 Richard Taylor
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+  CREDITS:
+
+  Much of the code here was adapted from Steve Harris's swh-plugins
+  (version 0.4.15) found at http://plugin.org.uk/.  Thanks Steve for
+  making your code available.
+
+  The guts of the code, in util/biquad.h, is an implementation
+  of the biquad filters described in Robert Bristow-Johnson's "Cookbook
+  formulae for audio EQ biquad filter coefficients" found here:
+  http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <math.h>
+
+#include <ladspa.h>
+
+#include "biquad.h"
+
+#define SINGLEPARA_GAIN                0
+#define SINGLEPARA_FC                  1
+#define SINGLEPARA_Q                   2
+#define SINGLEPARA_INPUT               3
+#define SINGLEPARA_OUTPUT              4
+
+static LADSPA_Descriptor *singleParaDescriptor = NULL;
+
+typedef struct {
+	LADSPA_Data *gain;
+	LADSPA_Data *fc;
+	LADSPA_Data *Q;
+	LADSPA_Data *input;
+	LADSPA_Data *output;
+	biquad *     filter;
+	float        fs;
+} SinglePara;
+
+const LADSPA_Descriptor *ladspa_descriptor(unsigned long index) {
+	switch (index) {
+	case 0:
+		return singleParaDescriptor;
+	default:
+		return NULL;
+	}
+}
+
+static void activateSinglePara(LADSPA_Handle instance) {
+	SinglePara *plugin_data = (SinglePara *)instance;
+	biquad *filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+	biquad_init(filter);
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+}
+
+static void cleanupSinglePara(LADSPA_Handle instance) {
+	SinglePara *plugin_data = (SinglePara *)instance;
+	free(plugin_data->filter);
+	free(instance);
+}
+
+static void connectPortSinglePara(
+ LADSPA_Handle instance,
+ unsigned long port,
+ LADSPA_Data *data) {
+	SinglePara *plugin;
+
+	plugin = (SinglePara *)instance;
+	switch (port) {
+	case SINGLEPARA_GAIN:
+		plugin->gain = data;
+		break;
+	case SINGLEPARA_FC:
+		plugin->fc = data;
+		break;
+	case SINGLEPARA_Q:
+		plugin->Q = data;
+		break;
+	case SINGLEPARA_INPUT:
+		plugin->input = data;
+		break;
+	case SINGLEPARA_OUTPUT:
+		plugin->output = data;
+		break;
+	}
+}
+
+static LADSPA_Handle instantiateSinglePara(
+ const LADSPA_Descriptor *descriptor,
+ unsigned long s_rate) {
+	SinglePara *plugin_data = (SinglePara *)malloc(sizeof(SinglePara));
+	biquad *filter = NULL;
+	float fs;
+
+	fs = (float)s_rate;
+	filter = malloc(sizeof(biquad));
+	biquad_init(filter);
+
+	plugin_data->filter = filter;
+	plugin_data->fs = fs;
+
+	return (LADSPA_Handle)plugin_data;
+}
+
+#undef buffer_write
+#define buffer_write(b, v) (b = v)
+
+static void runSinglePara(LADSPA_Handle instance, unsigned long sample_count) {
+	SinglePara *plugin_data = (SinglePara *)instance;
+
+	/* Gain (dB) (float value) */
+	const LADSPA_Data gain = *(plugin_data->gain);
+
+	/* Frequency (Hz) (float value) */
+	const LADSPA_Data fc = *(plugin_data->fc);
+
+	/* Quality factor (float value) */
+	const LADSPA_Data Q = *(plugin_data->Q);
+
+	/* Input (array of floats of length sample_count) */
+	const LADSPA_Data * const input = plugin_data->input;
+
+	/* Output (array of floats of length sample_count) */
+	LADSPA_Data * const output = plugin_data->output;
+	biquad * filter = plugin_data->filter;
+	float fs = plugin_data->fs;
+
+	unsigned long pos;
+
+	eq_set_params(filter, fc, gain, Q, fs);
+
+	for (pos = 0; pos < sample_count; pos++) {
+	  buffer_write(output[pos], (LADSPA_Data) biquad_run(filter, input[pos]));
+	}
+
+}
+
+void _init(void);
+void _init(void) {
+	char **port_names;
+	LADSPA_PortDescriptor *port_descriptors;
+	LADSPA_PortRangeHint *port_range_hints;
+
+#define D_(s) (s)
+
+	singleParaDescriptor =
+	 (LADSPA_Descriptor *)malloc(sizeof(LADSPA_Descriptor));
+
+	if (singleParaDescriptor) {
+		singleParaDescriptor->UniqueID = 9001;
+		singleParaDescriptor->Label = "RTparaeq";
+		singleParaDescriptor->Properties =
+		 LADSPA_PROPERTY_HARD_RT_CAPABLE;
+		singleParaDescriptor->Name =
+		 D_("RT parametric eq");
+		singleParaDescriptor->Maker =
+		 "Richard Taylor <rtaylor@tru.ca>";
+		singleParaDescriptor->Copyright =
+		 "GPL";
+		singleParaDescriptor->PortCount = 5;
+
+		port_descriptors = (LADSPA_PortDescriptor *)calloc(5,
+		 sizeof(LADSPA_PortDescriptor));
+		singleParaDescriptor->PortDescriptors =
+		 (const LADSPA_PortDescriptor *)port_descriptors;
+
+		port_range_hints = (LADSPA_PortRangeHint *)calloc(5,
+		 sizeof(LADSPA_PortRangeHint));
+		singleParaDescriptor->PortRangeHints =
+		 (const LADSPA_PortRangeHint *)port_range_hints;
+
+		port_names = (char **)calloc(5, sizeof(char*));
+		singleParaDescriptor->PortNames =
+		 (const char **)port_names;
+
+		/* Parameters for Gain (dB) */
+		port_descriptors[SINGLEPARA_GAIN] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[SINGLEPARA_GAIN] =
+		 D_("Gain (dB)");
+		port_range_hints[SINGLEPARA_GAIN].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[SINGLEPARA_GAIN].LowerBound = -70;
+		port_range_hints[SINGLEPARA_GAIN].UpperBound = +30;
+
+		/* Parameters for Frequency (Hz) */
+		port_descriptors[SINGLEPARA_FC] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[SINGLEPARA_FC] =
+		 D_("Frequency (Hz)");
+		port_range_hints[SINGLEPARA_FC].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_SAMPLE_RATE | LADSPA_HINT_DEFAULT_440;
+		port_range_hints[SINGLEPARA_FC].LowerBound = 0;
+		port_range_hints[SINGLEPARA_FC].UpperBound = (LADSPA_Data) 0.4;
+
+		/* Parameters for Quality Factor */
+		port_descriptors[SINGLEPARA_Q] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_CONTROL;
+		port_names[SINGLEPARA_Q] =
+		 D_("Q");
+		port_range_hints[SINGLEPARA_Q].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE | LADSPA_HINT_DEFAULT_1;
+		port_range_hints[SINGLEPARA_Q].LowerBound = 0;
+		port_range_hints[SINGLEPARA_Q].UpperBound = 100;
+
+		/* Parameters for Input */
+		port_descriptors[SINGLEPARA_INPUT] =
+		 LADSPA_PORT_INPUT | LADSPA_PORT_AUDIO;
+		port_names[SINGLEPARA_INPUT] =
+		 D_("Input");
+		port_range_hints[SINGLEPARA_INPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[SINGLEPARA_INPUT].LowerBound = -1.0;
+		port_range_hints[SINGLEPARA_INPUT].UpperBound = +1.0;
+
+		/* Parameters for Output */
+		port_descriptors[SINGLEPARA_OUTPUT] =
+		 LADSPA_PORT_OUTPUT | LADSPA_PORT_AUDIO;
+		port_names[SINGLEPARA_OUTPUT] =
+		 D_("Output");
+		port_range_hints[SINGLEPARA_OUTPUT].HintDescriptor =
+		 LADSPA_HINT_BOUNDED_BELOW | LADSPA_HINT_BOUNDED_ABOVE;
+		port_range_hints[SINGLEPARA_OUTPUT].LowerBound = -1.0;
+		port_range_hints[SINGLEPARA_OUTPUT].UpperBound = +1.0;
+
+		singleParaDescriptor->activate = activateSinglePara;
+		singleParaDescriptor->cleanup = cleanupSinglePara;
+		singleParaDescriptor->connect_port = connectPortSinglePara;
+		singleParaDescriptor->deactivate = NULL;
+		singleParaDescriptor->instantiate = instantiateSinglePara;
+		singleParaDescriptor->run = runSinglePara;
+		singleParaDescriptor->run_adding = NULL;
+	}
+}
+
+void _fini(void);
+void _fini(void) {
+	if (singleParaDescriptor) {
+		free((LADSPA_PortDescriptor *)singleParaDescriptor->PortDescriptors);
+		free((char **)singleParaDescriptor->PortNames);
+		free((LADSPA_PortRangeHint *)singleParaDescriptor->PortRangeHints);
+		free(singleParaDescriptor);
+	}
+
+}
+
diff --git a/util/biquad.h b/util/biquad.h
deleted file mode 100644
index 49451d8..0000000
--- a/util/biquad.h
+++ /dev/null
@@ -1,331 +0,0 @@
-#ifndef BIQUAD_H
-#define BIQUAD_H
-
-#define LN_2_2 0.34657359f // ln(2)/2
-
-#include "ladspa-util.h"
-#include <math.h>
-
-#ifndef LIMIT
-#define LIMIT(v,l,u) (v<l?l:(v>u?u:v))
-#endif
-
-// rt 8.1.2013: store biquad coefficients and accumulators in double
-// precision, to limit effects of round-off error.  Change this to
-// float if you need more speed: it probably won't make an audible
-// difference unless you need filters with really high Q or low
-// frequency.
-#ifndef BIQUAD_TYPE
-#define BIQUAD_TYPE double
-#endif
-
-// rt 25.6.2013: amplitude of square wave (at Nyquist freq)
-// added to kill denormals ... may need to experiment with
-// this value.  NB: 1.e-18 = -360dB
-#define DENORMALKILLER 1.e-18;
-
-typedef BIQUAD_TYPE bq_t;
-
-/* Biquad filter (adapted from lisp code by Eli Brandt,
-   http://www.cs.cmu.edu/~eli/) */
-
-typedef struct {
-	bq_t a1;
-	bq_t a2;
-	bq_t b0;
-	bq_t b1;
-	bq_t b2;
-	bq_t x1;
-	bq_t x2;
-	bq_t y1;
-	bq_t y2;
-  bq_t dn;  // denormal state (rt 25.6.2013)
-} biquad;
-
-typedef struct {
-	bq_t a1;
-	bq_t b0;
-	bq_t b1;
-	bq_t x1;
-	bq_t y1;
-  bq_t dn;  // denormal state
-} bilin;
-
-
-static inline void biquad_init(biquad *f) {
-	f->x1 = 0.0f;
-	f->x2 = 0.0f;
-	f->y1 = 0.0f;
-	f->y2 = 0.0f;
-  f->dn = DENORMALKILLER;
-}
-
-static inline void bilin_init(bilin *f) {
-	f->x1 = 0.0f;
-	f->y1 = 0.0f;
-  f->dn = DENORMALKILLER;
-}
-
-//static inline void eq_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q,
-//			  bq_t fs);
-static inline void eq_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q, bq_t fs)
-{
-	bq_t w = 2.0f * M_PI * LIMIT(fc, 1.0f, fs/2.0f) / fs;
-	bq_t J = pow(10.0f, gain * 0.025f);
-	bq_t cw = cos(w);
-	bq_t sw = sin(w);
-  Q = Q / J;  // adjust so input Q is standard elec. eng. Q
-//	bq_t g = sw * sinhf(LN_2_2 * LIMIT(bw, 0.0001f, 4.0f) * w / sw); // case: bw
-  bq_t g = sw/(2.0*Q);                                        // case: Q
-//  bq_t g = sin(w0)/2.0 * sqrt( (J + 1.0/J)*(1.0/S - 1.0) + 2.0 )   // case: S
-
-  bq_t a0 = 1.0f + g / J;
-	bq_t a0r = 1.0f / a0;
-
-	f->b0 = (1.0 + (g * J)) * a0r;
-	f->b1 = (-2.0 * cw) * a0r;
-	f->b2 = (1.0 - (g * J)) * a0r;
-	f->a1 = -(f->b1);
-	f->a2 = ((g / J) - 1.0) * a0r;
-}
-
-//static inline void ls_set_params(biquad *f, bq_t fc, bq_t gain, bq_t slope,
-//			  bq_t fs);
-static inline void ls_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q,
-			  bq_t fs)
-{
-	bq_t w = 2.0f * M_PI * LIMIT(fc, 1.0, fs/2.0) / fs;
-	bq_t cw = cos(w);
-	bq_t sw = sin(w);
-	bq_t A = powf(10.0f, (float) (gain * (bq_t) 0.025));
-
-// rt 8.1.2013: increased slope limit from 1.0f to 5.0f:
-//	bq_t b = sqrt(((1.0f + A * A) / LIMIT(slope, 0.0001f, 5.0f)) - ((A -
-//					1.0f) * (A - 1.0)));
-
-//	bq_t apc = cw * (A + 1.0f);
-//	bq_t amc = cw * (A - 1.0f);
-//	bq_t bs = b * sw;
-//	bq_t a0r = 1.0f / (A + 1.0f + amc + bs);
-
-//	f->b0 = a0r * A * (A + 1.0f - amc + bs);
-//	f->b1 = a0r * 2.0f * A * (A - 1.0f - apc);
-//	f->b2 = a0r * A * (A + 1.0f - amc - bs);
-//	f->a1 = a0r * 2.0f * (A - 1.0f + apc);
-//	f->a2 = a0r * (-A - 1.0f - amc + bs);
-
-  // rt 22.1.2013 changed this to use Q instead of slope
-  bq_t alpha = sw / (2.0 * Q);
-  bq_t b = 2.0*sqrt(A)*alpha;
-  bq_t ap = A + 1.0;
-  bq_t am = A - 1.0;
-  bq_t a0 = ap + am*cw + b;
-	bq_t a0r = 1.0 / a0;
-
-	f->b0 = a0r *       A * (ap - am*cw + b);
-	f->b1 = a0r * 2.0 * A * (am - ap*cw);
-	f->b2 = a0r *       A * (ap - am*cw - b);
-	f->a1 = 2.0 * a0r *     (am + ap*cw);
-	f->a2 = -a0r *          (ap + am*cw - b);
-}
-
-//static inline void hs_set_params(biquad *f, bq_t fc, bq_t gain, bq_t slope,
-//			  bq_t fs);
-static inline void hs_set_params(biquad *f, bq_t fc, bq_t gain, bq_t Q, bq_t fs)
-{
-	bq_t w = 2.0f * M_PI * LIMIT(fc, 1.0, fs/2.0) / fs;
-	bq_t cw = cos(w);
-	bq_t sw = sin(w);
-	bq_t A = powf(10.0f, (float) (gain * (bq_t) 0.025));
-// rt 8.1.2013: increased slope limit from 1.0f to 5.0f:
-//	bq_t b = sqrt(((1.0f + A * A) / LIMIT(slope, 0.0001f, 5.0f)) - ((A -
-//					1.0f) * (A - 1.0f)));
-//	bq_t apc = cw * (A + 1.0f);
-//	bq_t amc = cw * (A - 1.0f);
-//	bq_t bs = b * sw;
-//	bq_t a0r = 1.0f / (A + 1.0f - amc + bs);
-
-//	f->b0 = a0r * A * (A + 1.0f + amc + bs);
-//	f->b1 = a0r * -2.0f * A * (A - 1.0f + apc);
-//	f->b2 = a0r * A * (A + 1.0f + amc - bs);
-//	f->a1 = a0r * -2.0f * (A - 1.0f - apc);
-//	f->a2 = a0r * (-A - 1.0f + amc + bs);
-
-  // rt 22.1.2013 changed this to use Q instead of slope
-  bq_t alpha = sw / (2.0 * Q);
-  bq_t b = 2.0*sqrt(A)*alpha;
-  bq_t ap = A + 1.0;
-  bq_t am = A - 1.0;
-  bq_t a0 = ap - am*cw + b;
-	bq_t a0r = 1.0 / a0;
-
-	f->b0 = a0r *       A * (ap + am*cw + b);
-	f->b1 = -a0r * 2.0 * A * (am + ap*cw);
-	f->b2 = a0r *       A * (ap + am*cw - b);
-	f->a1 = -2.0 * a0r *    (am - ap*cw);
-	f->a2 = -a0r *          (ap - am*cw - b);
-}
-
-static inline void lp_set_params(biquad *f, bq_t fc, bq_t Q, bq_t fs)
-{
-	bq_t omega = 2.0 * M_PI * fc/fs;
-	bq_t sn = sin(omega);
-	bq_t cs = cos(omega);
-//	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
-	bq_t alpha = sn / (2.0 * Q);
-
-        const bq_t a0r = 1.0 / (1.0 + alpha);
-        f->b0 = a0r * (1.0 - cs) * 0.5;
-	      f->b1 = a0r * (1.0 - cs);
-        f->b2 = a0r * (1.0 - cs) * 0.5;
-        f->a1 = a0r * (2.0 * cs);
-        f->a2 = a0r * (alpha - 1.0);
-}
-
-static inline void hp_set_params(biquad *f, bq_t fc, bq_t Q, bq_t fs)
-{
-	bq_t omega = 2.0 * M_PI * fc/fs;
-	bq_t sn = sin(omega);
-	bq_t cs = cos(omega);
-//	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
-	bq_t alpha = sn / (2.0 * Q);
-
-        const bq_t a0r = 1.0 / (1.0 + alpha);
-        f->b0 = a0r * (1.0 + cs) * 0.5;
-        f->b1 = a0r * -(1.0 + cs);
-        f->b2 = a0r * (1.0 + cs) * 0.5;
-        f->a1 = a0r * (2.0 * cs);
-        f->a2 = a0r * (alpha - 1.0);
-}
-
-static inline void bp_set_params(biquad *f, bq_t fc, bq_t bw, bq_t fs)
-{
-	bq_t omega = 2.0 * M_PI * fc/fs;
-	bq_t sn = sin(omega);
-	bq_t cs = cos(omega);
-	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
-
-        const bq_t a0r = 1.0 / (1.0 + alpha);
-        f->b0 = a0r * alpha;
-        f->b1 = 0.0;
-        f->b2 = a0r * -alpha;
-        f->a1 = a0r * (2.0 * cs);
-        f->a2 = a0r * (alpha - 1.0);
-}
-
-// rt 8.1.2013: allpass from biquad cookbook
-static inline void ap_set_params(biquad *f, bq_t fc, bq_t Q, bq_t fs)
-{
-	bq_t omega = 2.0 * M_PI * fc/fs;
-	bq_t sn = sin(omega);
-	bq_t cs = cos(omega);
-//	bq_t alpha = sn * sinh(M_LN2 / 2.0 * bw * omega / sn);
-	bq_t alpha = sn / (2.0 * Q);
-
-  bq_t a0 = 1.0 + alpha;
-  bq_t a0r = 1.0 / a0;
-        f->b0 = a0r * (1.0 - alpha);
-        f->b1 = a0r * (-2.0 * cs);
-        f->b2 = 1.0;
-        f->a1 = -f->b1;
-        f->a2 = -f->b0;
-}
-
-static inline void ap1_set_params(bilin *f, bq_t fc, bq_t fs)
-{
-// rt 8.1.2013: implementation of first-order digital allpass found here:
-//  https://ccrma.stanford.edu/realsimple/DelayVar/Phasing_First_Order_Allpass_Filters.html
-// see here for turning transfer function into difference equation:
-//  http://en.wikipedia.org/wiki/Digital_filter
-  bq_t tphi = tan( M_PI * fc / fs);
-  bq_t p = (1.0f - tphi) / (1.0f + tphi);
-
-        // case 1: phase varies from 0 to 180 degrees
-        f->b0 = -p;
-        f->b1 = 1.0f;
-
-        // case 2: phase varies from 180 to 360 degrees
-//        f->b0 = p;
-//        f->b1 = -1.0f;
-
-        f->a1 = p;
-}
-
-// routine that runs a biquad (i.e. 2nd-order) digital filter
-static inline bq_t biquad_run(biquad *f, const bq_t x) {
-	bq_t y;
-
-// rt 15.5.2013: add a Nyquist-frequency square-wave to kill denormals:
-	y = f->b0 * x + f->b1 * f->x1 + f->b2 * f->x2
-		      + f->a1 * f->y1 + f->a2 * f->y2 + f->dn;
-  f->dn = -f->dn;
-
-// see previous commment
-//	y = flush_to_zero(y);
-
-	f->x2 = f->x1;
-	f->x1 = x;
-	f->y2 = f->y1;
-	f->y1 = y;
-
-	return y;
-}
-
-// rt  2.9.2013: special version of biquad_run for 2nd-order
-// allpass; takes advantage of factoring to reduce floating-point
-// multiplications from 5 to 2
-static inline bq_t ap2_run(biquad *f, const bq_t x) {
-	bq_t y;
-
-// rt 15.5.2013: add a Nyquist-frequency square-wave to kill denormals:
-	y = f->b0 * (x - f->y2) + f->b1 * (f->x1 - f->y1) + f->x2 + f->dn;
-  f->dn = -f->dn;
-
-// see previous commment
-//	y = flush_to_zero(y);
-
-	f->x2 = f->x1;
-	f->x1 = x;
-	f->y2 = f->y1;
-	f->y1 = y;
-
-	return y;
-}
-
-// routine that runs a bilinear (i.e. 1st-order) digital filter
-static inline bq_t bilin_run(bilin *f, const bq_t x) {
-	bq_t y;
-
-// rt 15.5.2013: add a Nyquist-frequency square-wave to kill denormals:
-	y = f->b0 * x + f->b1 * f->x1 + f->a1 * f->y1 + f->dn;
-  f->dn = -f->dn;
-
-// see previous commment
-//	y = flush_to_zero(y);
-
-	f->x1 = x;
-	f->y1 = y;
-
-	return y;
-}
-
-// rt  2.9.2013: special version of bilin_run for 2nd-order
-// allpass; takes advantage of factoring to reduce floating-point
-// multiplications from 5 to 2
-static inline bq_t ap1_run(bilin *f, const bq_t x) {
-	bq_t y;
-
-// rt 15.5.2013: adding a Nyquist-frequency square-wave to kill denormals:
-	y = f->b0 * (x - f->y1) + f->x1 + f->dn;
-  f->dn = -f->dn;
-
-// see previous commment
-//	y = flush_to_zero(y);
-
-	f->x1 = x;
-	f->y1 = y;
-
-	return y;
-}
-
-#endif
diff --git a/util/config.h b/util/config.h
deleted file mode 100644
index 1dcbc37..0000000
--- a/util/config.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* config.h.  Generated by configure.  */
-/* config.h.in.  Generated from configure.in by autoheader.  */
-#ifndef _CONFIG_H
-#define _CONFIG_H
-
-/* #undef EXPLICIT_S */
-/* #undef ACCEL_3DNOW */
-#define HAVE_LRINTF 1
-#define PACKAGE_LOCALE_DIR "/usr/local//locale"
-#define PACKAGE_DATA_DIR "/usr/local/share/swh-plugins"
-
-#endif
-
-/* Define to 1 if translation of program messages to the user's native
-   language is requested. */
-#define ENABLE_NLS 1
-
-/* Wether were using FFTW version 3 */
-#define FFTW3 
-
-/* Define if the GNU dcgettext() function is already present or preinstalled.
-   */
-#define HAVE_DCGETTEXT 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define if the GNU gettext() function is already present or preinstalled. */
-#define HAVE_GETTEXT 1
-
-/* Define if you have the iconv() function. */
-/* #undef HAVE_ICONV */
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if you have the `m' library (-lm). */
-#define HAVE_LIBM 1
-
-/* Define to 1 if you have the `mx' library (-lmx). */
-/* #undef HAVE_LIBMX */
-
-/* Define to 1 if you have the `rt' library (-lrt). */
-#define HAVE_LIBRT 1
-
-/* Define if you have C99's lrintf function. */
-#define HAVE_LRINTF 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Name of package */
-#define PACKAGE "swh-plugins"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME ""
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME ""
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION ""
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Version number of package */
-#define VERSION "0.4.15"
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef WORDS_BIGENDIAN */
diff --git a/util/ladspa-util.h b/util/ladspa-util.h
deleted file mode 100644
index 5d3dcc9..0000000
--- a/util/ladspa-util.h
+++ /dev/null
@@ -1,230 +0,0 @@
-/* Some misc util functions for audio DSP work, written by Steve Harris,
- * December 2000
- *
- *  steve@plugin.org.uk
- */
-
-#ifndef LADSPA_UTIL_H
-#define LADSPA_UTIL_H
-
-#include <math.h>
-#include <stdint.h>
-
-#include "config.h"
-
-// 16.16 fixpoint
-typedef union {
-	int32_t all;
-	struct {
-#ifdef WORDS_BIGENDIAN
-		int16_t in;
-		uint16_t fr;
-#else
-		uint16_t fr;
-		int16_t in;
-#endif
-	} part;
-} fixp16;
-
-// 32.32 fixpoint
-typedef union {
-	int64_t all;
-	struct {
-#ifdef WORDS_BIGENDIAN
-		int32_t in;
-		uint32_t fr;
-#else
-		uint32_t fr;
-		int32_t in;
-#endif
-	} part;
-} fixp32;
-
-/* 32 bit "pointer cast" union */
-typedef union {
-        float f;
-        int32_t i;
-} ls_pcast32;
-
-// 1.0 / ln(2)
-#define LN2R 1.442695041f
-
-/* detet floating point denormal numbers by comparing them to the smallest
- * normal, crap, but reliable */
-#define DN_CHECK(x, l) if (fabs(x) < 1e-38) printf("DN: "l"\n")
-
-// Denormalise floats, only actually needed for PIII and recent PowerPC
-//#define FLUSH_TO_ZERO(fv) (((*(unsigned int*)&(fv))&0x7f800000)==0)?0.0f:(fv)
-
-static inline float flush_to_zero(float f)
-{
-	ls_pcast32 v;
-
-	v.f = f;
-
-	// original: return (v.i & 0x7f800000) == 0 ? 0.0f : f;
-	// version from Tim Blechmann
-	return (v.i & 0x7f800000) < 0x08000000 ? 0.0f : f;
-}
-
-static inline void round_to_zero(volatile float *f)
-{
-	*f += 1e-18f;
-	*f -= 1e-18f;
-}
-
-/* A set of branchless clipping operations from Laurent de Soras */
-
-static inline float f_max(float x, float a)
-{
-	x -= a;
-	x += fabsf(x);
-	x *= 0.5f;
-	x += a;
-
-	return x;
-}
-
-static inline float f_min(float x, float b)
-{
-	x = b - x;
-	x += fabsf(x);
-	x *= 0.5f;
-	x = b - x;
-
-	return x;
-}
-
-static inline float f_clamp(float x, float a, float b)
-{
-	const float x1 = fabsf(x - a);
-	const float x2 = fabsf(x - b);
-
-	x = x1 + a + b;
-	x -= x2;
-	x *= 0.5f;
-
-	return x;
-}
-
-// Limit a value to be l<=v<=u
-#define LIMIT(v,l,u) ((v)<(l)?(l):((v)>(u)?(u):(v)))
-
-// Truncate-to-zero modulo (ANSI C doesn't specify) will only work
-// if -m < v < 2m
-#define MOD(v,m) (v<0?v+m:(v>=m?v-m:v))
-
-// Truncate-to-zero modulo (ANSI C doesn't specify) will only work
-// if v > -m and v < m
-#define NEG_MOD(v,m) ((v)<0?((v)+(m)):(v))
-
-// Convert a value in dB's to a coefficent
-#define DB_CO(g) ((g) > -90.0f ? powf(10.0f, (g) * 0.05f) : 0.0f)
-#define CO_DB(v) (20.0f * log10f(v))
-
-// Linearly interpolate [ = a * (1 - f) + b * f]
-#define LIN_INTERP(f,a,b) ((a) + (f) * ((b) - (a)))
-
-// Cubic interpolation function
-static inline float cube_interp(const float fr, const float inm1, const float
-                                in, const float inp1, const float inp2)
-{
-	return in + 0.5f * fr * (inp1 - inm1 +
-	 fr * (4.0f * inp1 + 2.0f * inm1 - 5.0f * in - inp2 +
-	 fr * (3.0f * (in - inp1) - inm1 + inp2)));
-}
-
-/* fast sin^2 aproxiamtion, adapted from jan AT rpgfan's posting to the
- * music-dsp list */
-static inline float f_sin_sq(float angle)
-{
-	const float asqr = angle * angle;
-	float result = -2.39e-08f;
-
-	result *= asqr;
-	result += 2.7526e-06f;
-	result *= asqr;
-	result -= 1.98409e-04f;
-	result *= asqr;
-	result += 8.3333315e-03f;
-	result *= asqr;
-	result -= 1.666666664e-01f;
-	result *= asqr;
-	result += 1.0f;
-	result *= angle;
-
-	return result * result;
-}
-
-#ifdef HAVE_LRINTF
-
-#define f_round(f) lrintf(f)
-
-#else
-
-// Round float to int using IEEE int* hack
-static inline long int f_round(float f)
-{
-	ls_pcast32 p;
-
-	p.f = f;
-	p.f += (3<<22);
-
-	return p.i - 0x4b400000;
-}
-
-#endif
-
-// Truncate float to int
-static inline long int f_trunc(float f)
-{
-	return f_round(floorf(f));
-}
-
-/* Andrew Simper's pow(2, x) aproximation from the music-dsp list */
-
-#if 0
-
-/* original */
-static inline float f_pow2(float x)
-{
-	long *px = (long*)(&x); // store address of float as long pointer
-	const float tx = (x-0.5f) + (3<<22); // temporary value for truncation
-	const long  lx = *((long*)&tx) - 0x4b400000; // integer power of 2
-	const float dx = x-(float)(lx); // float remainder of power of 2
-
-	x = 1.0f + dx*(0.6960656421638072f + // cubic apporoximation of 2^x
-                   dx*(0.224494337302845f +  // for x in the range [0, 1]
-                   dx*(0.07944023841053369f)));
-	*px += (lx<<23); // add integer power of 2 to exponent
-
-	return x;
-}
-
-#else
-
-/* union version */
-static inline float f_pow2(float x)
-{
-	ls_pcast32 *px, tx, lx;
-	float dx;
-
-	px = (ls_pcast32 *)&x; // store address of float as long pointer
-	tx.f = (x-0.5f) + (3<<22); // temporary value for truncation
-	lx.i = tx.i - 0x4b400000; // integer power of 2
-	dx = x - (float)lx.i; // float remainder of power of 2
-
-	x = 1.0f + dx * (0.6960656421638072f + // cubic apporoximation of 2^x
-		   dx * (0.224494337302845f +  // for x in the range [0, 1]
-		   dx * (0.07944023841053369f)));
-	(*px).i += (lx.i << 23); // add integer power of 2 to exponent
-
-	return (*px).f;
-}
-
-#endif
-
-/* Fast exponentiation function, y = e^x */
-#define f_exp(x) f_pow2(x * LN2R)
-
-#endif
-- 
1.9.0

