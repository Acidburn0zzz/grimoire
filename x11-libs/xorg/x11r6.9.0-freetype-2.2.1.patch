--- lib/fontconfig/Imakefile.orig	2005-11-08 07:33:26.000000000 +0100
+++ lib/fontconfig/Imakefile	2006-07-07 17:57:31.000000000 +0200
@@ -49,11 +49,11 @@
 REQUIREDLIBS=$(LDPRELIBS) $(FREETYPE2LIB) $(EXPATLIB)
 
 SRCS=fcatomic.c fcblanks.c fccache.c fccfg.c fccharset.c fcdbg.c \
-     fcdefault.c fcdir.c fcfreetype.c fcfs.c fcinit.c fclang.c fclist.c \
+     fcdefault.c fcdir.c fcfreetype.c fcftglue.c fcfs.c fcinit.c fclang.c fclist.c \
      fcmatch.c fcmatrix.c fcname.c fcpat.c fcstr.c fcxml.c
 
 OBJS=fcatomic.o fcblanks.o fccache.o fccfg.o fccharset.o fcdbg.o \
-     fcdefault.o fcdir.o fcfreetype.o fcfs.o fcinit.o fclang.o fclist.o \
+     fcdefault.o fcdir.o fcfreetype.o fcftglue.o fcfs.o fcinit.o fclang.o fclist.o \
      fcmatch.o fcmatrix.o fcname.o fcpat.o fcstr.o fcxml.o
 
 #include <Library.tmpl>
@@ -186,6 +186,7 @@
 LinkSourceFile(fcdefault.c,$(FONTCONFIGSRC)/src)
 LinkSourceFile(fcdir.c,$(FONTCONFIGSRC)/src)
 /* LinkSourceFile(fcfreetype.c,$(FONTCONFIGSRC)/src) - use custom copy for now */
+LinkSourceFile(fcftglue.c,$(FONTCONFIGSRC)/src)
 LinkSourceFile(fcfs.c,$(FONTCONFIGSRC)/src)
 LinkSourceFile(fcinit.c,$(FONTCONFIGSRC)/src)
 LinkSourceFile(fclang.c,$(FONTCONFIGSRC)/src)
diff -urN xc/lib/fontconfig/fcfreetype.c xc/extras/fontconfig/src/fcfreetype.c
--- lib/fontconfig/fcfreetype.c	2005-04-21 14:37:43.000000000 +0200
+++ lib/fontconfig/fcfreetype.c	2005-07-07 13:17:32.224401218 +0200
@@ -50,14 +50,11 @@
 #include "fcint.h"
 #include <ft2build.h>
 #include FT_FREETYPE_H
-#include FT_INTERNAL_OBJECTS_H
 #include FT_TRUETYPE_TABLES_H
 #include FT_SFNT_NAMES_H
 #include FT_TRUETYPE_IDS_H
 #include FT_TYPE1_TABLES_H
-#include FT_INTERNAL_STREAM_H
-#include FT_INTERNAL_SFNT_H
-#include FT_INTERNAL_TRUETYPE_TYPES_H
+#include "fcftglue.h"
 #if HAVE_FT_GET_X11_FONT_FORMAT
 #include FT_XFREE86_H
 #endif
@@ -65,8 +62,7 @@
 #if HAVE_FT_GET_BDF_PROPERTY
 #include FT_BDF_H
 #include FT_MODULE_H
-#define HAS_BDF_PROPERTY(f) ((f) && (f)->driver && \
-			     (f)->driver->root.clazz->get_interface)
+#define HAS_BDF_PROPERTY(f) ((f))
 #define MY_Get_BDF_Property(f,n,p) (HAS_BDF_PROPERTY(f) ? \
 				    FT_Get_BDF_Property(f,n,p) : \
 				    FT_Err_Invalid_Argument)
@@ -1559,7 +1555,7 @@
      */
     if (FcCharSetCount (cs) == 0)
     {
-	if (!strcmp(FT_MODULE_CLASS(&face->driver->root)->module_name, "pcf"))
+	if (!strcmp(FT_Get_X11_Font_Format(face),"PCF"))
 	    goto bail2;
     }
 
@@ -2706,8 +2702,7 @@
 static FT_Error
 GetScriptTags(FT_Face face, FT_ULong tabletag, FT_ULong **stags, FT_UShort *script_count)
 {
-    FT_ULong         cur_offset, new_offset, base_offset;
-    TT_Face          tt_face = (TT_Face)face;
+    FT_ULong   cur_offset, new_offset, base_offset;
     FT_Stream  stream = face->stream;
     FT_Error   error;
     FT_UShort          n, p;
@@ -2716,51 +2711,43 @@
     if ( !stream )
 	return TT_Err_Invalid_Face_Handle;
 
-    if (( error = tt_face->goto_table( tt_face, tabletag, stream, 0 ) ))
+    if ( (error = fcft_face_goto_table( face, tabletag, stream )) != 0 )
 	return error;
 
-    base_offset = FT_STREAM_POS();
+    base_offset = FCFT_STREAM_POS();
 
     /* skip version */
 
-    if ( FT_STREAM_SEEK( base_offset + 4L ) || FT_FRAME_ENTER( 2L ) )
-	return error;
-
-    new_offset = FT_GET_USHORT() + base_offset;
-
-    FT_FRAME_EXIT();
-
-    cur_offset = FT_STREAM_POS();
-
-    if ( FT_STREAM_SEEK( new_offset ) != TT_Err_Ok )
-	return error;
-
-    base_offset = FT_STREAM_POS();
+    if ( FCFT_STREAM_SEEK( base_offset + 4L ) ||
+         FCFT_READ_USHORT( new_offset )       ) 
+      return error;
+    
+    new_offset += base_offset;
+    cur_offset  = FCFT_STREAM_POS();
 
-    if ( FT_FRAME_ENTER( 2L ) )
+    if ( FCFT_STREAM_SEEK( new_offset ) != TT_Err_Ok )
 	return error;
 
-    *script_count = FT_GET_USHORT();
+    base_offset = FCFT_STREAM_POS();
 
-    FT_FRAME_EXIT();
-
-    if ( FT_SET_ERROR (FT_MEM_ALLOC_ARRAY( *stags, *script_count, FT_ULong )) )
-	return error;
+    if ( FCFT_READ_USHORT(*script_count)                         ||
+         FCFT_MEM_ALLOC_ARRAY( *stags, *script_count, FT_ULong ) )
+ 	return error;
 
     p = 0;
     for ( n = 0; n < *script_count; n++ )
     {
-	if ( FT_FRAME_ENTER( 6L ) )
+	if ( FCFT_FRAME_ENTER( 6L ) )
 	    goto Fail;
 
-	(*stags)[p] = FT_GET_ULONG();
-	new_offset = FT_GET_USHORT() + base_offset;
+	(*stags)[p] = FCFT_GET_ULONG();
+	new_offset  = FCFT_GET_USHORT() + base_offset;
 
-	FT_FRAME_EXIT();
+	FCFT_FRAME_EXIT();
 
-	cur_offset = FT_STREAM_POS();
+	cur_offset = FCFT_STREAM_POS();
 
-	if ( FT_STREAM_SEEK( new_offset ) )
+	if ( FCFT_STREAM_SEEK( new_offset ) )
 	    goto Fail;
 
 	if ( error == TT_Err_Ok )
@@ -2768,7 +2755,7 @@
 	else if ( error != TTO_Err_Empty_Script )
 	    goto Fail;
 
-	(void)FT_STREAM_SEEK( cur_offset );
+	(void)FCFT_STREAM_SEEK( cur_offset );
     }
 
     if (!p)
@@ -2784,7 +2771,7 @@
 
 Fail:
     *script_count = 0;
-    FT_FREE( *stags );
+    FCFT_FREE( *stags );
     return error;
 }
 
@@ -2841,7 +2828,7 @@
     if (FcDebug () & FC_DBG_SCANV)
 	printf("complex features in this font: %s\n", complex);
 bail:
-    FT_FREE(gsubtags);
-    FT_FREE(gpostags);
+    FCFT_FREE(gsubtags);
+    FCFT_FREE(gpostags);
     return complex;
 }
diff -urN xc/extras/fontconfig/src/fcftglue.c xc/extras/fontconfig/src/fcftglue.c
--- extras/fontconfig/src/fcftglue.c	1970-01-01 01:00:00.000000000 +0100
+++ extras/fontconfig/src/fcftglue.c	2005-07-07 13:34:48.630254000 +0200
@@ -0,0 +1,380 @@
+#include "fcftglue.h"
+
+/***************************************************************************/
+/***************************************************************************/
+/*****                                                                 *****/
+/*****                                                                 *****/
+/*****                                                                 *****/
+/***************************************************************************/
+/***************************************************************************/
+
+/* only used internall */
+static FT_Pointer
+fcft_qalloc( FT_Memory  memory,
+             FT_ULong   size,
+             FT_Error  *perror )
+{
+  FT_Error    error = 0;
+  FT_Pointer  block = NULL;
+
+  if ( size > 0 )
+  {
+    block = memory->alloc( memory, size );
+    if ( !block )
+      error = FT_Err_Out_Of_Memory;
+  }
+
+  *perror = error;
+  return block;
+}
+
+#define  FCFT_QALLOC(ptr,size)    ( (ptr) = fcft_qalloc( memory, (size), &error ), error != 0 )
+
+
+FCFT_APIDEF( FT_Pointer )
+fcft_alloc( FT_Memory  memory,
+            FT_ULong   size,
+            FT_Error  *perror )
+{
+  FT_Error    error = 0;
+  FT_Pointer  block = NULL;
+
+  if ( size > 0 )
+  {
+    block = memory->alloc( memory, size );
+    if ( !block )
+      error = FT_Err_Out_Of_Memory;
+    else
+      memset( (char*)block, 0, (size_t)size );
+  }
+
+  *perror = error;
+  return block;
+}
+
+
+FCFT_APIDEF( FT_Pointer )
+fcft_realloc( FT_Memory   memory,
+              FT_Pointer  block,
+              FT_ULong    old_size,
+              FT_ULong    new_size,
+              FT_Error   *perror )
+{
+  FT_Pointer  block2 = NULL;
+  FT_Error    error  = 0;
+
+  if ( block == NULL )
+  {
+    block2 = fcft_alloc( memory, new_size, &error );
+  }
+  else if ( new_size <= 0 )
+  {
+    fcft_free( memory, block );
+  }
+  else
+  {
+    block2 = fcft_alloc( memory, new_size, &error );
+    if ( !error )
+    {
+      memcpy( (char*)block2, (const char*)block, (size_t)old_size );
+      if ( new_size > old_size )
+        memset( (char*)block2 + old_size, 0, (size_t)(new_size - old_size) );
+    }
+  }
+
+  if ( !error )
+    block = block2;
+
+  *perror = error;
+  return block;
+}
+
+
+FCFT_APIDEF( void )
+fcft_free( FT_Memory   memory,
+           FT_Pointer  block )
+{
+  if ( block )
+    memory->free( memory, block );
+}
+
+
+FCFT_APIDEF( FT_Long )
+fcft_stream_pos( FT_Stream   stream )
+{
+  return stream->pos;
+}
+
+
+FCFT_APIDEF( FT_Error )
+fcft_stream_seek( FT_Stream   stream,
+                  FT_Long     pos )
+{
+  FT_Error  error = 0;
+
+  stream->pos = pos;
+  if ( stream->read )
+  {
+    if ( stream->read( stream, pos, 0, 0 ) )
+      error = FT_Err_Invalid_Stream_Operation;
+  }
+  else if ( pos > stream->size )
+    error = FT_Err_Invalid_Stream_Operation;
+
+  return error;
+}
+
+
+FCFT_APIDEF( FT_Error )
+fcft_stream_frame_enter( FT_Stream   stream,
+                         FT_ULong    count )
+{
+  FT_Error  error = FT_Err_Ok;
+  FT_ULong  read_bytes;
+
+  if ( stream->read )
+  {
+    /* allocate the frame in memory */
+    FT_Memory  memory = stream->memory;
+
+
+    if ( FCFT_QALLOC( stream->base, count ) )
+      goto Exit;
+
+    /* read it */
+    read_bytes = stream->read( stream, stream->pos,
+                               stream->base, count );
+    if ( read_bytes < count )
+    {
+      FCFT_FREE( stream->base );
+      error = FT_Err_Invalid_Stream_Operation;
+    }
+    stream->cursor = stream->base;
+    stream->limit  = stream->cursor + count;
+    stream->pos   += read_bytes;
+  }
+  else
+  {
+    /* check current and new position */
+    if ( stream->pos >= stream->size        ||
+         stream->pos + count > stream->size )
+    {
+      error = FT_Err_Invalid_Stream_Operation;
+      goto Exit;
+    }
+
+    /* set cursor */
+    stream->cursor = stream->base + stream->pos;
+    stream->limit  = stream->cursor + count;
+    stream->pos   += count;
+  }
+
+Exit:
+  return error;
+}
+
+
+FCFT_APIDEF( void )
+fcft_stream_frame_exit( FT_Stream  stream )
+{
+  if ( stream->read )
+  {
+    FT_Memory  memory = stream->memory;
+
+    FCFT_FREE( stream->base );
+  }
+  stream->cursor = 0;
+  stream->limit  = 0;
+}
+
+
+FCFT_APIDEF( FT_Byte )
+fcft_stream_get_byte( FT_Stream  stream )
+{
+  FT_Byte  result = 0;
+
+  if ( stream->cursor < stream->limit )
+    result = *stream->cursor++;
+
+  return result;
+}
+
+
+FCFT_APIDEF( FT_Short )
+fcft_stream_get_short( FT_Stream  stream )
+{
+  FT_Byte*  p;
+  FT_Short  result = 0;
+
+  p = stream->cursor;
+  if ( p + 2 <= stream->limit )
+  {
+    result         = (FT_Short)((p[0] << 8) | p[1]);
+    stream->cursor = p+2;
+  }
+  return result;
+}
+
+
+FCFT_APIDEF( FT_Long )
+fcft_stream_get_long( FT_Stream   stream )
+{
+  FT_Byte*  p;
+  FT_Long   result = 0;
+
+  p = stream->cursor;
+  if ( p + 4 <= stream->limit )
+  {
+    result         = (FT_Long)(((FT_Long)p[0] << 24) |
+                               ((FT_Long)p[1] << 16) |
+                               ((FT_Long)p[2] << 8)  |
+                                         p[3]        );
+    stream->cursor = p+4;
+  }
+  return result;
+}
+
+
+static FT_Error
+fcft_stream_readp( FT_Stream   stream,
+                   FT_Byte*   *pbuffer,
+                   FT_ULong    count )
+{
+  FT_Error  error = 0;
+
+  if ( stream->read )
+  {
+    FT_ULong  read_bytes = stream->read( stream, stream->pos, *pbuffer, count );
+
+    if ( read_bytes != count )
+      goto Fail;
+
+    stream->pos += count;
+  }
+  else
+  {
+    if ( stream->pos >= stream->size        ||
+         stream->pos + count > stream->size )
+      goto Fail;
+
+    *pbuffer     = stream->base + stream->pos;
+    stream->pos += count;
+  }
+
+Exit:
+  return error;
+
+Fail:
+  error = FT_Err_Invalid_Stream_Operation;
+  goto Exit;
+}
+
+
+FCFT_API( FT_Byte )
+fcft_stream_read_byte( FT_Stream   stream,
+                       FT_Error   *perror )
+{
+  FT_Byte   temp[1], *p = temp, result = 0;
+  FT_Error  error = fcft_stream_readp( stream, &p, 1 );
+
+  if ( !error )
+    result = *p;
+
+  return error;
+}
+
+FCFT_API( FT_Short )
+fcft_stream_read_short( FT_Stream  stream,
+                        FT_Error  *perror )
+{
+  FT_Byte   temp[2], *p = temp;
+  FT_Short  result = 0;
+  FT_Error  error  = fcft_stream_readp( stream, &p, 2 );
+
+  if ( !error )
+    result = (FT_Short)((p[0] << 8) | p[1]);
+
+  return error;
+}
+
+FCFT_API( FT_Long )
+fcft_stream_read_long( FT_Stream  stream,
+                       FT_Error  *perror )
+{
+  FT_Byte   temp[4], *p = temp;
+  FT_Long   result = 0;
+  FT_Error  error  = fcft_stream_readp( stream, &p, 4 );
+
+  if ( !error )
+    result = (FT_Long)((FT_Long)(p[0] << 24) |
+                       (FT_Long)(p[1] << 16) |
+                                (p[2] << 8)  |
+                                 p[3]        );
+
+  return error;
+}
+
+
+FCFT_APIDEF( FT_Error )
+fcft_face_goto_table( FT_Face    face,
+                      FT_ULong   the_tag,
+                      FT_Stream  stream )
+{
+  FT_Error  error;
+
+  if ( !FT_IS_SFNT(face) )
+    error = FT_Err_Invalid_Face_Handle;
+  else
+  {
+   /* parse the directory table directly, without using
+    * FreeType's built-in data structures
+    */
+    FT_UInt   count, nn;
+    FT_ULong  offset = 0;
+
+    if ( face->num_faces > 1 )
+    {
+      /* deal with TrueType collections */
+      FT_ULong  offset;
+
+      if ( FCFT_STREAM_SEEK( 12 + face->face_index*4 ) ||
+           FCFT_READ_ULONG(offset)                     )
+        goto Exit;
+    }
+
+    if ( FCFT_STREAM_SEEK( offset+4 ) ||
+         FCFT_READ_USHORT(count)      )
+      goto Exit;
+
+
+    if ( FCFT_STREAM_SEEK( offset+12 ) ||
+         FCFT_FRAME_ENTER( count*16 )  )
+      goto Exit;
+
+    for ( nn = 0; nn < count; nn++ )
+    {
+      FT_ULong  tag      = FCFT_GET_TAG();
+      FT_ULong  checksum = FCFT_GET_ULONG();
+      FT_ULong  start    = FCFT_GET_ULONG();
+      FT_ULong  size     = FCFT_GET_ULONG();
+
+      FT_UNUSED(checksum);
+      FT_UNUSED(size);
+
+      if ( tag == the_tag )
+      {
+        error = fcft_stream_seek( stream, offset+start );
+        goto FoundIt;
+      }
+    }
+    error = FT_Err_Table_Missing;
+
+  FoundIt:
+    FCFT_FRAME_EXIT();
+  }
+
+Exit:
+  return error;
+}
+
+#undef FCFT_QALLOC
diff -urN xc/extras/fontconfig/src/fcftglue.h xc/extras/fontconfig/src/fcftglue.h
--- extras/fontconfig/src/fcftglue.h	1970-01-01 01:00:00.000000000 +0100
+++ extras/fontconfig/src/fcftglue.h	2005-07-07 13:15:43.292717000 +0200
@@ -0,0 +1,135 @@
+/* the following contains code used to prevent FontConfig from
+ * abusing FreeType internals. We simply duplicate some of the FreeType
+ * functionality using only publicly defined APIs and structures
+ */
+#ifndef __FONTCONFIG_FTGLUE_H__
+#define __FONTCONFIG_FTGLUE_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+FT_BEGIN_HEADER
+
+
+/* utility macros */
+#define  FCFT_SET_ERR(c)   ( (error = (c)) != 0 )
+
+#ifndef FCFT_API
+#define FCFT_API(x)  extern x
+#endif
+
+#ifndef FCFT_APIDEF
+#define FCFT_APIDEF(x)  x
+#endif
+
+/* stream macros used by the OpenType parser */
+#define  FCFT_STREAM_POS()       fcft_stream_pos( stream )
+#define  FCFT_STREAM_SEEK(pos)   FCFT_SET_ERR( fcft_stream_seek( stream, pos ) )
+#define  FCFT_FRAME_ENTER(size)  FCFT_SET_ERR( fcft_stream_frame_enter( stream, size ) )
+#define  FCFT_FRAME_EXIT()       fcft_stream_frame_exit( stream )
+
+#define  FCFT_GET_BYTE()         fcft_stream_get_byte( stream )
+#define  FCFT_GET_SHORT()        fcft_stream_get_short( stream )
+#define  FCFT_GET_LONG()         fcft_stream_get_long( stream )
+
+#define  FCFT_GET_CHAR()        ((FT_Char)FCFT_GET_BYTE())
+#define  FCFT_GET_USHORT()      ((FT_UShort)FCFT_GET_SHORT())
+#define  FCFT_GET_ULONG()       ((FT_ULong)FCFT_GET_LONG())
+#define  FCFT_GET_TAG()         FCFT_GET_ULONG()
+
+#define  FCFT_READ_(val,type,suffix)   \
+   ( (val) = (type) fcft_stream_read_##suffix (stream, &error), error != 0 )
+
+#define  FCFT_READ_BYTE(val)    FCFT_READ_(val,FT_Byte,byte)
+#define  FCFT_READ_SHORT(val)   FCFT_READ_(val,FT_Short,short)
+#define  FCFT_READ_LONG(val)    FCFT_READ_(val,FT_Long,long)
+
+#define  FCFT_READ_CHAR(val)    FCFT_READ_(val,FT_Char,byte)
+#define  FCFT_READ_USHORT(val)  FCFT_READ_(val,FT_UShort,short)
+#define  FCFT_READ_ULONG(val)   FCFT_READ_(val,FT_ULong,long)
+
+
+FCFT_API( FT_Long )
+fcft_stream_pos( FT_Stream   stream );
+
+FCFT_API( FT_Error )
+fcft_stream_seek( FT_Stream   stream,
+                  FT_Long     pos );
+
+FCFT_API( FT_Error )
+fcft_stream_frame_enter( FT_Stream   stream,
+                         FT_ULong    size );
+
+FCFT_API( void )
+fcft_stream_frame_exit( FT_Stream  stream );
+
+FCFT_API( FT_Byte )
+fcft_stream_get_byte( FT_Stream  stream );
+
+FCFT_API( FT_Short )
+fcft_stream_get_short( FT_Stream  stream );
+
+FCFT_API( FT_Long )
+fcft_stream_get_long( FT_Stream   stream );
+
+FCFT_API( FT_Byte )
+fcft_stream_read_byte( FT_Stream   stream,
+                       FT_Error   *perror );
+
+FCFT_API( FT_Short )
+fcft_stream_read_short( FT_Stream  stream,
+                        FT_Error  *perror );
+
+FCFT_API( FT_Long )
+fcft_stream_read_long( FT_Stream  stream,
+                       FT_Error  *perror );
+
+FCFT_API( FT_Error )
+fcft_face_goto_table( FT_Face    face,
+                      FT_ULong   tag,
+                      FT_Stream  stream );
+
+/* memory macros used by the OpenType parser */
+#define  FCFT_MEM_ALLOC(_ptr,_size)   \
+           ( (_ptr) = fcft_alloc( memory, _size, &error ), error != 0 )
+
+#define  FCFT_MEM_REALLOC(_ptr,_oldsz,_newsz)  \
+           ( (_ptr) = fcft_realloc( memory, (_ptr), (_oldsz), (_newsz), &error ), error != 0 )
+
+#define  FCFT_FREE(_ptr)               \
+  FT_BEGIN_STMNT                       \
+    if ( (_ptr) )                      \
+    {                                  \
+      fcft_free( memory, _ptr );       \
+      _ptr = NULL;                     \
+    }                                  \
+  FT_END_STMNT
+
+#define  FCFT_MEM_ALLOC_ARRAY(_ptr,_count,_type)   \
+           FCFT_MEM_ALLOC(_ptr,(_count)*sizeof(_type))
+
+#define  FCFT_MEM_REALLOC_ARRAY(_ptr,_oldcnt,_newcnt,_type) \
+           FCFT_MEM_REALLOC(_ptr,(_oldcnt)*sizeof(_type),(_newcnt)*sizeof(_type))
+
+
+FCFT_API( FT_Pointer )
+fcft_alloc( FT_Memory  memory,
+            FT_ULong   size,
+            FT_Error  *perror );
+
+FCFT_API( FT_Pointer )
+fcft_realloc( FT_Memory   memory,
+              FT_Pointer  block,
+              FT_ULong    old_size,
+              FT_ULong    new_size,
+              FT_Error   *perror );
+
+FCFT_API( void )
+fcft_free( FT_Memory   memory,
+           FT_Pointer  block );
+
+/* */
+
+FT_END_HEADER
+
+#endif /* __OPENTYPE_FCFT_H__ */
diff -urN xc/extras/fontconfig/src/Makefile.am xc/extras/fontconfig/src/Makefile.am
--- extras/fontconfig/src/Makefile.am	2004-12-05 06:49:20.000000000 +0100
+++ extras/fontconfig/src/Makefile.am	2005-07-07 13:09:15.416637082 +0200
@@ -86,6 +86,7 @@
 	fcdefault.c \
 	fcdir.c \
 	fcfreetype.c \
+	fcftglue.c \
 	fcfs.c \
 	fcinit.c \
 	fclang.c \
diff -urN xc/extras/fontconfig/src/Makefile.in xc/extras/fontconfig/src/Makefile.in
--- extras/fontconfig/src/Makefile.in	2005-04-27 21:08:51.000000000 +0200
+++ extras/fontconfig/src/Makefile.in	2005-07-07 13:09:15.417636939 +0200
@@ -228,6 +228,7 @@
 	fcdefault.c \
 	fcdir.c \
 	fcfreetype.c \
+	fcftglue.c \
 	fcfs.c \
 	fcinit.c \
 	fclang.c \
@@ -257,7 +258,7 @@
 libfontconfig_la_DEPENDENCIES =
 am_libfontconfig_la_OBJECTS = fcatomic.lo fcblanks.lo fccache.lo \
 	fccfg.lo fccharset.lo fcdbg.lo fcdefault.lo fcdir.lo \
-	fcfreetype.lo fcfs.lo fcinit.lo fclang.lo fclist.lo fcmatch.lo \
+	fcfreetype.lo fcftglue.lo fcfs.lo fcinit.lo fclang.lo fclist.lo fcmatch.lo \
 	fcmatrix.lo fcname.lo fcpat.lo fcstr.lo fcxml.lo
 libfontconfig_la_OBJECTS = $(am_libfontconfig_la_OBJECTS)
 


diff -urbN ./lib/font/FreeType/ftfuncs.c ./lib/font/FreeType/ftfuncs.c
--- lib/font/FreeType/ftfuncs.c	2005-10-24 02:32:05.000000000 +0800
+++ lib/font/FreeType/ftfuncs.c	2006-06-25 10:56:24.221147322 +0800
@@ -54,10 +54,7 @@
 #include FT_TYPE1_TABLES_H
 #include FT_XFREE86_H
 #include FT_BBOX_H
-#include FT_INTERNAL_TRUETYPE_TYPES_H
 #include FT_TRUETYPE_TAGS_H
-#include FT_INTERNAL_SFNT_H
-#include FT_INTERNAL_STREAM_H
 /*
  *  If you want to use FT_Outline_Get_CBox instead of 
  *  FT_Outline_Get_BBox, define here.
@@ -123,6 +120,25 @@
 };
 
 
+/* read 2-byte value from a SFNT table */
+static FT_UShort
+sfnt_get_ushort( FT_Face     face,
+                 FT_ULong    table_tag,
+                 FT_ULong    table_offset )
+{
+  FT_Byte    buff[2];
+  FT_ULong   len = sizeof(buff);
+  FT_UShort  result = 0;
+
+  if ( !FT_Load_Sfnt_Table( face, table_tag, table_offset, buff, &len ) );
+    result = (FT_UShort)( (buff[0] << 8) | buff[1] );
+
+  return result;
+}
+
+#define  sfnt_get_short(f,t,o)  ((FT_Short)sfnt_get_ushort((f),(t),(o)))
+
+
 static int ftypeInitP = 0;      /* is the engine initialised? */
 FT_Library ftypeLibrary;
 
@@ -211,6 +227,10 @@
         if(maxp && maxp->maxContours == 0)
             face->bitmap = 1;
     }
+
+    face->num_hmetrics = (FT_UInt) sfnt_get_ushort( face->face,
+                                                    TTAG_hhea, 34 );
+
     /* Insert face in hashtable and return it */
     face->next = faceTable[bucket];
     faceTable[bucket] = face;
@@ -462,6 +482,34 @@
     }
 
     if( FT_IS_SFNT( face->face ) ) {
+#if 1
+        FT_F26Dot6  tt_char_width, tt_char_height, tt_dim_x, tt_dim_y;
+        FT_UInt     nn;
+
+        instance->strike_index=0xFFFFU;
+
+        tt_char_width  = (FT_F26Dot6)(trans->scale*(1<<6) + 0.5);
+        tt_char_height = (FT_F26Dot6)(trans->scale*(1<<6) + 0.5);
+
+        tt_dim_x = FLOOR64( ( tt_char_width  * trans->xres + 36 ) / 72 + 32 );
+        tt_dim_y = FLOOR64( ( tt_char_height * trans->yres + 36 ) / 72 + 32 );
+
+	if ( tt_dim_x && !tt_dim_y )
+	    tt_dim_y = tt_dim_x;
+	else if ( !tt_dim_x && tt_dim_y )
+	    tt_dim_x = tt_dim_y;
+
+        for ( nn = 0; nn < face->face->num_fixed_sizes; nn++ )
+        {
+          FT_Bitmap_Size*  sz = &face->face->available_sizes[nn];
+
+          if ( tt_dim_x == FLOOR64(sz->x_ppem + 32) && tt_dim_y == FLOOR64(sz->y_ppem + 32) )
+          {
+            instance->strike_index = nn;
+            break;
+          }
+        }
+#else
 	/* See Set_Char_Sizes() in ttdriver.c */
 	FT_Error err;
 	TT_Face tt_face;
@@ -486,6 +534,7 @@
 	sfnt   = (SFNT_Service)tt_face->sfnt;
 	err = sfnt->set_sbit_strike(tt_face,tt_x_ppem,tt_y_ppem,&instance->strike_index);
 	if ( err ) instance->strike_index=0xFFFFU;
+#endif
     }
 
     /* maintain a linked list of instances */
@@ -803,31 +852,61 @@
  * parse the htmx field in TrueType font.
  */
 
-/* from src/truetype/ttgload.c */
 static void
-tt_get_metrics( TT_HoriHeader*  header,
+tt_get_metrics( FT_Face         face,
 		FT_UInt         idx,
+		FT_UInt         num_hmetrics,
 		FT_Short*       bearing,
 		FT_UShort*      advance )
-/*  Copyright 1996-2001, 2002 by                      */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg. */
 {
-    TT_LongMetrics  longs_m;
-    FT_UShort       k = header->number_Of_HMetrics;
+   /* read the metrics directly from the horizontal header, we
+    * parse the SFNT table directly through the standard FreeType API.
+    * this works with any version of the library and doesn't need to
+    * peek at its internals. Maybe a bit less
+    */
+    FT_UInt  count  = num_hmetrics;
+    FT_ULong length = 0;
+    FT_ULong offset = 0;
+    FT_Error error;
 
-    if ( k == 0 ) {
-	*bearing = *advance = 0;
-	return;
-    }
+    error = FT_Load_Sfnt_Table( face, TTAG_hmtx, 0, NULL, &length );
 
-    if ( idx < (FT_UInt)k ) {
-	longs_m  = (TT_LongMetrics )header->long_metrics + idx;
-	*bearing = longs_m->bearing;
-	*advance = longs_m->advance;
+    if ( count == 0 || error )
+    {
+      *advance = 0;
+      *bearing = 0;
+    }
+    else if ( idx < count )
+    {
+	offset = idx * 4L;
+	if ( offset + 4 > length )
+	{
+	    *advance = 0;
+	    *bearing = 0;
+	}
+	else
+	{
+	    *advance = sfnt_get_ushort( face, TTAG_hmtx, offset );
+	    *bearing = sfnt_get_short ( face, TTAG_hmtx, offset+2 );
+	}
+    }
+    else
+    {
+	offset = 4L * (count - 1);
+	if ( offset + 4 > length )
+	{
+	    *advance = 0;
+	    *bearing = 0;
+	}
+	else
+	{
+	    *advance = sfnt_get_ushort ( face, TTAG_hmtx, offset );
+	    offset += 4 + 2 * ( idx - count );
+	    if ( offset + 2 > length)
+		*bearing = 0;
+	    else
+		*bearing = sfnt_get_short ( face, TTAG_hmtx, offset );
     }
-    else {
-	*bearing = ((TT_ShortMetrics*)header->short_metrics)[idx - k];
-	*advance = ((TT_LongMetrics )header->long_metrics)[k - 1].advance;
     }
 }
 
@@ -835,6 +914,7 @@
 ft_get_very_lazy_bbox( FT_UInt index,
 		       FT_Face face,
 		       FT_Size size,
+		       FT_UInt num_hmetrics,
 		       double slant,
 		       FT_Matrix *matrix,
 		       FT_BBox *bbox,
@@ -842,15 +922,14 @@
 		       FT_Long *vertAdvance)
 {
     if ( FT_IS_SFNT( face ) ) {
-	TT_Face   ttface = (TT_Face)face;
 	FT_Size_Metrics *smetrics = &size->metrics;
 	FT_Short  leftBearing = 0;
 	FT_UShort advance = 0;
 	FT_Vector p0, p1, p2, p3;
 
 	/* horizontal */
-	tt_get_metrics(&ttface->horizontal, index,
-		       &leftBearing, &advance);
+	tt_get_metrics( face, index, num_hmetrics,
+		       &leftBearing, &advance );
 
 #if 0
 	fprintf(stderr,"x_scale=%f y_scale=%f\n",
@@ -910,7 +989,27 @@
 		    FT_UShort glyph_index, FT_Glyph_Metrics *metrics_return,
 		    int *sbitchk_incomplete_but_exist )
 {
-#if (FREETYPE_VERSION >= 2001008)
+#if 1
+    if ( strike_index != 0xFFFFU && ft_face->available_sizes != NULL )
+    {
+      FT_Error         error;
+      FT_Bitmap_Size*  sz = &ft_face->available_sizes[strike_index];
+
+      error = FT_Set_Pixel_Sizes( ft_face, sz->x_ppem/64, sz->y_ppem/64 );
+      if ( !error )
+      {
+        error = FT_Load_Glyph( ft_face, glyph_index, FT_LOAD_SBITS_ONLY );
+        if ( !error )
+        {
+          if ( metrics_return != NULL )
+            *metrics_return = ft_face->glyph->metrics;
+
+          return 0;
+        }
+      }
+    }
+    return -1;
+#elif (FREETYPE_VERSION >= 2001008)
     SFNT_Service       sfnt;
     TT_Face            face;
     FT_Error           error;
@@ -1043,6 +1142,7 @@
 	    if( bitmap_metrics == NULL ) {
 		if ( sbitchk_incomplete_but_exist==0 && (instance->ttcap.flags & TTCAP_IS_VERY_LAZY) ) {
 		    if( ft_get_very_lazy_bbox( idx, face->face, instance->size, 
+					       face->num_hmetrics,
 					       instance->ttcap.vl_slant,
 					       &instance->transformation.matrix,
 					       &bbox, &outline_hori_advance, 
@@ -1207,10 +1307,27 @@
 	}
 
 	if( face->face->glyph->format != FT_GLYPH_FORMAT_BITMAP ) {
+#ifdef USE_GET_CBOX
+	    FT_Outline_Get_CBox(&face->face->glyph->outline, &bbox);
+	    ftrc = 0;
+#else
+	    ftrc = FT_Outline_Get_BBox(&face->face->glyph->outline, &bbox);
+#endif
+	    if( ftrc != 0 ) return FTtoXReturnCode(ftrc);
+	    bbox.yMin = FLOOR64( bbox.yMin );
+	    bbox.yMax = CEIL64 ( bbox.yMax );
+	    ht_actual = ( bbox.yMax - bbox.yMin ) >> 6;
+	    /* FreeType think a glyph with 0 height control box is invalid. 
+	     * So just let X to create a empty bitmap instead. */
+	    if ( ht_actual == 0 )
+		is_outline = -1;
+	    else
+	    {
 	    ftrc = FT_Render_Glyph(face->face->glyph,FT_RENDER_MODE_MONO);
 	    if( ftrc != 0 ) return FTtoXReturnCode(ftrc);
 	    is_outline = 1;
 	}
+	}
 	else{
 	    is_outline=0;
 	}
@@ -1221,6 +1338,7 @@
 	if( is_outline == 1 ){
 	    if( correct ){
 		if( ft_get_very_lazy_bbox( idx, face->face, instance->size, 
+					   face->num_hmetrics,
 					   instance->ttcap.vl_slant,
 					   &instance->transformation.matrix,
 					   &bbox, &outline_hori_advance, 
diff -urbN ./lib/font/FreeType/ftfuncs.h ./lib/font/FreeType/ftfuncs.h
--- lib/font/FreeType/ftfuncs.h	2005-07-07 22:59:47.000000000 +0800
+++ lib/font/FreeType/ftfuncs.h	2006-06-21 21:05:28.533849804 +0800
@@ -47,6 +47,7 @@
     char *filename;
     FT_Face face;
     int bitmap;
+    FT_UInt num_hmetrics;
     struct _FTInstance *instances;
     struct _FTInstance *active_instance;
     struct _FTFace *next;       /* link to next face in bucket */
diff -urbN ./lib/font/FreeType/ftsystem.c ./lib/font/FreeType/ftsystem.c
--- lib/font/FreeType/ftsystem.c	2005-07-09 14:36:10.000000000 +0800
+++ lib/font/FreeType/ftsystem.c	2006-06-21 21:05:28.534849622 +0800
@@ -35,7 +35,6 @@
 #endif
 #include <ft2build.h>
 #include FT_CONFIG_CONFIG_H
-#include FT_INTERNAL_DEBUG_H
 #include FT_SYSTEM_H
 #include FT_ERRORS_H
 #include FT_TYPES_H
