commit 88ede395cf896c0a14299be553b6084aa6a5e50d
Author: Chandler Carruth <chandlerc@gmail.com>
Date:   Wed Feb 19 22:35:01 2014 +0000

    Teach Clang to provide ::max_align_t in C11 and C++11 modes.
    
    This definition is not chosen idly. There is an unfortunate reality with
    max_align_t -- the specific nature of its definition leaks into the ABI
    almost immediately. Because it is part of C11 and C++11 it becomes
    essential for it to match with other systems on that ABI. There is an
    effort to discourage any further use of this construct as a consequence
    -- using max_align_t introduces an immediate ABI problem. We can never
    update it to have larger alignment even as the microarchitecture changes
    to necessitate higher alignment. =/
    
    The particular definition here exactly matches the ABI of GCC's chosen
    ::max_align_t definition, for better or worse. This was written with the
    help of Richard Smith who was decoding the exact ABI implications of the
    selected definition in GCC. Notably, in-register arguments are impacted
    by the particular definition chosen. =/
    
    No one is under the illusion that this is a "good" or "useful"
    definition of max_align_t, and we are working with the standards
    committee to specify a more useful interface to address this need.
    
    git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@201729 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Headers/stddef.h b/lib/Headers/stddef.h
index 6a64d6d..b692694 100644
--- a/lib/Headers/stddef.h
+++ b/lib/Headers/stddef.h
@@ -84,6 +84,16 @@ using ::std::nullptr_t;
 #endif
 #endif
 
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+typedef struct {
+  long long __clang_max_align_nonce1
+      __attribute__((__aligned__(__alignof__(long long))));
+  long double __clang_max_align_nonce2
+      __attribute__((__aligned__(__alignof__(long double))));
+} max_align_t;
+#define __CLANG_MAX_ALIGN_T_DEFINED
+#endif
+
 #define offsetof(t, d) __builtin_offsetof(t, d)
 
 #endif /* __STDDEF_H */
diff --git a/test/Headers/c11.c b/test/Headers/c11.c
index 11bec19..e335d0c 100644
--- a/test/Headers/c11.c
+++ b/test/Headers/c11.c
@@ -22,6 +22,10 @@ _Static_assert(__alignof(c) == 4, "");
 #define __STDC_WANT_LIB_EXT1__ 1
 #include <stddef.h>
 rsize_t x = 0;
+_Static_assert(sizeof(max_align_t) >= sizeof(long long), "");
+_Static_assert(alignof(max_align_t) >= alignof(long long), "");
+_Static_assert(sizeof(max_align_t) >= sizeof(long double), "");
+_Static_assert(alignof(max_align_t) >= alignof(long double), "");
 
 // If we are freestanding, then also check RSIZE_MAX (in a hosted implementation
 // we will use the host stdint.h, which may not yet have C11 support).

commit 288b33f7afb00418a116215e04567b0d4eb2a01a
Author: David Majnemer <david.majnemer@gmail.com>
Date:   Tue Mar 4 23:43:48 2014 +0000

    Headers: Provide an ABI compatible max_align_t when _MSC_VER is defined
    
    Summary:
    Our usual definition of max_align_t wouldn't match up with MSVC if it
    was used in a template argument.
    
    Reviewers: chandlerc, rsmith, rnk
    
    Reviewed By: chandlerc
    
    CC: cfe-commits
    
    Differential Revision: http://llvm-reviews.chandlerc.com/D2924
    
    git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@202911 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Headers/stddef.h b/lib/Headers/stddef.h
index b692694..97126ed 100644
--- a/lib/Headers/stddef.h
+++ b/lib/Headers/stddef.h
@@ -85,12 +85,16 @@ using ::std::nullptr_t;
 #endif
 
 #if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#ifndef _MSC_VER
 typedef struct {
   long long __clang_max_align_nonce1
       __attribute__((__aligned__(__alignof__(long long))));
   long double __clang_max_align_nonce2
       __attribute__((__aligned__(__alignof__(long double))));
 } max_align_t;
+#else
+typedef double max_align_t;
+#endif
 #define __CLANG_MAX_ALIGN_T_DEFINED
 #endif
 
diff --git a/test/Headers/c11.c b/test/Headers/c11.c
index e335d0c..2debcae 100644
--- a/test/Headers/c11.c
+++ b/test/Headers/c11.c
@@ -1,6 +1,7 @@
 // RUN: %clang_cc1 -fsyntax-only -verify -std=c11 %s
 // RUN: %clang_cc1 -fsyntax-only -verify -std=c11 -fmodules %s
 // RUN: %clang_cc1 -fsyntax-only -verify -std=c11 -ffreestanding %s
+// RUN: %clang_cc1 -fsyntax-only -verify -std=c11 -triple i686-pc-win32 -fmsc-version=1700 %s
 
 noreturn int f(); // expected-error 1+{{}}
 
@@ -27,6 +28,10 @@ _Static_assert(alignof(max_align_t) >= alignof(long long), "");
 _Static_assert(sizeof(max_align_t) >= sizeof(long double), "");
 _Static_assert(alignof(max_align_t) >= alignof(long double), "");
 
+#ifdef _MSC_VER
+_Static_assert(sizeof(max_align_t) == sizeof(double), "");
+#endif
+
 // If we are freestanding, then also check RSIZE_MAX (in a hosted implementation
 // we will use the host stdint.h, which may not yet have C11 support).
 #ifndef __STDC_HOSTED__

commit 7933ecef1047af471f6116acb9ec052cec9e9335
Author: Nico Weber <nicolasweber@gmx.de>
Date:   Wed Apr 30 04:35:09 2014 +0000

    Let stddef.h respect __need_{wchar_t, size_t, NULL, ptrdiff_t, wint_t}.
    
    glibc expects that stddef.h only defines a single thing if either of these
    defines is set.  For example, before this change, a C file containing
    
      #include <stdlib.h>
      int ptrdiff_t = 0;
    
    would compile with gcc but not with clang. Now it compiles with clang too.
    
    This also fixes PR12997, where older versions of the Linux headers would define
    NULL incorrectly, and glibc would define __need_NULL and expect stddef.h to
    redefine NULL with the correct definition.
    
    
    git-svn-id: https://llvm.org/svn/llvm-project/cfe/trunk@207606 91177308-0d34-0410-b5e6-96231b3b80d8

diff --git a/lib/Headers/stddef.h b/lib/Headers/stddef.h
index 97126ed..2dfe0a2 100644
--- a/lib/Headers/stddef.h
+++ b/lib/Headers/stddef.h
@@ -23,9 +23,22 @@
  *===-----------------------------------------------------------------------===
  */
 
-#ifndef __STDDEF_H
+#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
+    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
+    defined(__need_NULL) || defined(__need_wint_t)
+
+#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
+    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
+    !defined(__need_wint_t)
 #define __STDDEF_H
+#define __need_ptrdiff_t
+#define __need_size_t
+#define __need_wchar_t
+#define __need_NULL
+/* __need_wint_t is intentionally not defined here. */
+#endif
 
+#if defined(__need_ptrdiff_t)
 #if !defined(_PTRDIFF_T) || __has_feature(modules)
 /* Always define ptrdiff_t when modules are available. */
 #if !__has_feature(modules)
@@ -33,7 +46,10 @@
 #endif
 typedef __PTRDIFF_TYPE__ ptrdiff_t;
 #endif
+#undef __need_ptrdiff_t
+#endif /* defined(__need_ptrdiff_t) */
 
+#if defined(__need_size_t)
 #if !defined(_SIZE_T) || __has_feature(modules)
 /* Always define size_t when modules are available. */
 #if !__has_feature(modules)
@@ -41,7 +57,10 @@ typedef __PTRDIFF_TYPE__ ptrdiff_t;
 #endif
 typedef __SIZE_TYPE__ size_t;
 #endif
+#undef __need_size_t
+#endif /*defined(__need_size_t) */
 
+#if defined(__STDDEF_H)
 /* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
  * enabled. */
 #if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
@@ -52,7 +71,9 @@ typedef __SIZE_TYPE__ size_t;
 #endif
 typedef __SIZE_TYPE__ rsize_t;
 #endif
+#endif /* defined(__STDDEF_H) */
 
+#if defined(__need_wchar_t)
 #ifndef __cplusplus
 /* Always define wchar_t when modules are available. */
 #if !defined(_WCHAR_T) || __has_feature(modules)
@@ -65,7 +86,10 @@ typedef __SIZE_TYPE__ rsize_t;
 typedef __WCHAR_TYPE__ wchar_t;
 #endif
 #endif
+#undef __need_wchar_t
+#endif /* defined(__need_wchar_t) */
 
+#if defined(__need_NULL)
 #undef NULL
 #ifdef __cplusplus
 #  if !defined(__MINGW32__) && !defined(_MSC_VER)
@@ -76,15 +100,19 @@ typedef __WCHAR_TYPE__ wchar_t;
 #else
 #  define NULL ((void*)0)
 #endif
-
 #ifdef __cplusplus
 #if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
 namespace std { typedef decltype(nullptr) nullptr_t; }
 using ::std::nullptr_t;
 #endif
 #endif
+#undef __need_NULL
+#endif /* defined(__need_NULL) */
+
+#if defined(__STDDEF_H)
 
 #if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#if !defined(__CLANG_MAX_ALIGN_T_DEFINED) || __has_feature(modules)
 #ifndef _MSC_VER
 typedef struct {
   long long __clang_max_align_nonce1
@@ -97,10 +125,10 @@ typedef double max_align_t;
 #endif
 #define __CLANG_MAX_ALIGN_T_DEFINED
 #endif
+#endif
 
 #define offsetof(t, d) __builtin_offsetof(t, d)
-
-#endif /* __STDDEF_H */
+#endif  /* __STDDEF_H */
 
 /* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
 __WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
@@ -114,3 +142,5 @@ typedef __WINT_TYPE__ wint_t;
 #endif
 #undef __need_wint_t
 #endif /* __need_wint_t */
+
+#endif
diff --git a/test/Headers/stddefneeds.cpp b/test/Headers/stddefneeds.cpp
new file mode 100644
index 0000000..304a224
--- /dev/null
+++ b/test/Headers/stddefneeds.cpp
@@ -0,0 +1,69 @@
+// RUN: %clang_cc1 -fsyntax-only -verify -Wsentinel -std=c++11 %s
+
+ptrdiff_t p0; // expected-error{{unknown}}
+size_t s0; // expected-error{{unknown}}
+void* v0 = NULL; // expected-error{{undeclared}}
+wint_t w0; // expected-error{{unknown}}
+max_align_t m0; // expected-error{{unknown}}
+
+#define __need_ptrdiff_t
+#include <stddef.h>
+
+ptrdiff_t p1;
+size_t s1; // expected-error{{unknown}}
+void* v1 = NULL; // expected-error{{undeclared}}
+wint_t w1; // expected-error{{unknown}}
+max_align_t m1; // expected-error{{unknown}}
+
+#define __need_size_t
+#include <stddef.h>
+
+ptrdiff_t p2;
+size_t s2;
+void* v2 = NULL; // expected-error{{undeclared}}
+wint_t w2; // expected-error{{unknown}}
+max_align_t m2; // expected-error{{unknown}}
+
+#define __need_NULL
+#include <stddef.h>
+
+ptrdiff_t p3;
+size_t s3;
+void* v3 = NULL;
+wint_t w3; // expected-error{{unknown}}
+max_align_t m3; // expected-error{{unknown}}
+
+// Shouldn't bring in wint_t by default:
+#include <stddef.h>
+
+ptrdiff_t p4;
+size_t s4;
+void* v4 = NULL;
+wint_t w4; // expected-error{{unknown}}
+max_align_t m4;
+
+#define __need_wint_t
+#include <stddef.h>
+
+ptrdiff_t p5;
+size_t s5;
+void* v5 = NULL;
+wint_t w5;
+max_align_t m5;
+
+
+// linux/stddef.h does something like this for cpp files:
+#undef NULL
+#define NULL 0
+
+// glibc (and other) headers then define __need_NULL and rely on stddef.h
+// to redefine NULL to the correct value again.
+#define __need_NULL
+#include <stddef.h>
+
+// gtk headers then use __attribute__((sentinel)), which doesn't work if NULL
+// is 0.
+void f(const char* c, ...) __attribute__((sentinel));
+void g() {
+  f("", NULL);  // Shouldn't warn.
+}
diff --git a/test/Sema/format-strings.c b/test/Sema/format-strings.c
index ad7b37c..e31644a 100644
--- a/test/Sema/format-strings.c
+++ b/test/Sema/format-strings.c
@@ -1,8 +1,9 @@
 // RUN: %clang_cc1 -fsyntax-only -verify -Wformat-nonliteral -isystem %S/Inputs %s
 // RUN: %clang_cc1 -fsyntax-only -verify -Wformat-nonliteral -isystem %S/Inputs -fno-signed-char %s
 
-#define __need_wint_t
 #include <stdarg.h>
+#include <stddef.h>
+#define __need_wint_t
 #include <stddef.h> // For wint_t and wchar_t
 
 typedef struct _FILE FILE;
